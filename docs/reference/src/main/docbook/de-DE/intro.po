# translation of intro.po to
# Language de-DE translations for Introduction_to_Web_Beans package.
# Automatically generated, 2009.
#
msgid ""
msgstr ""
"Project-Id-Version: intro\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2012-01-16T16:07:16\n"
"PO-Revision-Date: 2009-02-22 13:52+1100\n"
"Last-Translator: \n"
"Language-Team:  <en@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, no-c-format
msgid "Introduction"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "So you're keen to get started writing your first bean? Or perhaps you're skeptical, wondering what kinds of hoops the CDI specification will make you jump through! The good news is that you've probably already written and used hundreds, perhaps thousands of beans. CDI just makes it easier to actually use them to build an application!"
msgstr "Können Sie es jetzt kaum erwarten Ihr erstes Web Bean zu schreiben? Oder sind Sie etwas skeptisch und fragen sich, welche Hürden Ihnen bei der Web Beans Spezifikation bevorstehen? Die gute Nachricht ist, dass Sie wahrscheinlich schon hunderte, wenn nicht tausende von Web Beans geschrieben haben. Vielleicht erinnern Sie sich nicht einmal an das erste Web Bean, das Sie je geschrieben haben."

#. Tag: title
#, fuzzy, no-c-format
msgid "What is a bean?"
msgstr "Was ist ein Web Bean?"

#. Tag: para
#, no-c-format
msgid "A bean is exactly what you think it is. Only now, it has a true identity in the container environment."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Prior to Java EE 6, there was no clear definition of the term \"bean\" in the Java EE platform. Of course, we've been calling Java classes used in web and enterprise applications \"beans\" for years. There were even a couple of different kinds of things called \"beans\" in EE specifications, including EJB beans and JSF managed beans. Meanwhile, other third-party frameworks such as Spring and Seam introduced their own ideas of what it meant to be a \"bean\". What we've been missing is a common definition."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Java EE 6 finally lays down that common definition in the Managed Beans specification. Managed Beans are defined as container-managed objects with minimal programming restrictions, otherwise known by the acronym POJO (Plain Old Java Object). They support a small set of basic services, such as resource injection, lifecycle callbacks and interceptors. Companion specifications, such as EJB and CDI, build on this basic model. But, <emphasis>at last</emphasis>, there's a uniform concept of a bean and a lightweight component model that's aligned across the Java EE platform."
msgstr ""

#. Tag: para
#, no-c-format
msgid "With very few exceptions, almost every concrete Java class that has a constructor with no parameters (or a constructor designated with the annotation <literal>@Inject</literal>) is a bean. This includes every JavaBean and every EJB session bean. If you've already got some JavaBeans or session beans lying around, they're already beans&mdash;you won't need any additional special metadata. There's just little one thing you need to do before you can start injecting them into stuff: you need to put them in an archive (a jar, or a Java EE module such as a war or EJB jar) that contains a special marker file: <literal>META-INF/beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The JavaBeans and EJBs you've been writing every day, up until now, have not been able to take advantage of the new services defined by the CDI specification. But you'll be able to use every one of them with CDI&mdash;allowing the container to create and destroy instances of your beans and associate them with a designated context, injecting them into other beans, using them in EL expressions, specializing them with qualifier annotations, even adding interceptors and decorators to them&mdash;without modifying your existing code. At most, you'll need to add some annotations."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now let's see how to create your first bean that actually uses CDI."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Getting our feet wet"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Suppose that we have two existing Java classes that we've been using for years in various applications. The first class parses a string into a list of sentences:"
msgstr "Nehmen wir an, Sie besitzen zwei bestehende Java Klassen, die bis dato in verschiedenen Anwendungen verwendet wurden. Die erste Klasse parst einen String in eine Liste von Sätzen:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class SentenceParser {\n"
"   public List&lt;String&gt; parse(String text) { ... }\n"
"}"
msgstr ""
"<![CDATA[public class SentenceParser {\n"
"    public List<String> parse(String text) { ... }\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "The second existing class is a stateless session bean front-end for an external system that is able to translate sentences from one language to another:"
msgstr "Bei der zweiten bestehenden Klasse handelt es sich um das Front-End eines \"stateless Session Beans\" für ein externes System, das in der Lage ist Sätze von einer Sprache in eine andere zu übersetzen:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"   public String translate(String sentence) { ... }\n"
"}"
msgstr ""
"<![CDATA[@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"    public String translate(String sentence) { ... }\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>Translator</literal> is the EJB local interface:"
msgstr "Wo <literal>Translator</literal> das lokale Interface ist:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Local\n"
"public interface Translator {\n"
"   public String translate(String sentence);\n"
"}"
msgstr ""
"<![CDATA[@Local\n"
"public interface Translator {\n"
"    public String translate(String sentence);\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Unfortunately, we don't have a class that translates whole text documents. So let's write a bean for this job:"
msgstr "Leider besitzen wir keine bereits bestehende Klasse die ganze Textdokumente übersetzt. Schreiben wir also ein Web Bean, das diesen Job übernimmt:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class TextTranslator {\n"
"   private SentenceParser sentenceParser;\n"
"   private Translator sentenceTranslator;\n"
"    \n"
"   @Inject\n"
"   TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"      this.sentenceParser = sentenceParser;\n"
"      this.sentenceTranslator = sentenceTranslator;\n"
"   }\n"
"    \n"
"   public String translate(String text) {\n"
"      StringBuilder sb = new StringBuilder();\n"
"      for (String sentence: sentenceParser.parse(text)) {\n"
"          sb.append(sentenceTranslator.translate(sentence));\n"
"      }\n"
"      return sb.toString();\n"
"   }\n"
"}"
msgstr ""
"<![CDATA[public class TextTranslator {\n"
"    \n"
"    private SentenceParser sentenceParser;\n"
"    private Translator sentenceTranslator;\n"
"    \n"
"    @Initializer\n"
"    TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"        this.sentenceParser = sentenceParser;\n"
"        this.sentenceTranslator = sentenceTranslator;\n"
"    }\n"
"    \n"
"    public String translate(String text) {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        for (String sentence: sentenceParser.parse(text)) {\n"
"            sb.append(sentenceTranslator.translate(sentence));\n"
"        }\n"
"        return sb.toString();\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "But wait! <literal>TextTranslator</literal> does not have a constructor with no parameters! Is it still a bean? If you remember, a class that does not have a constructor with no parameters can still be a bean if it has a constructor annotated <literal>@Inject</literal>."
msgstr "Aber warten Sie: <literal>TextTranslator</literal> besitzt keinen Konstruktor ohne Parameter! Handelt es sich noch um ein Web Bean? Nun, eine Klasse, die keinen Konstruktor ohne Parameter besitzt, kann nach wie vor Web Bean sein, falls es einen mit <literal>@Initializer</literal> annotierten Konstruktor besitzt."

#. Tag: para
#, fuzzy, no-c-format
msgid "As you've guessed, the <literal>@Inject</literal> annotation has something to do with dependency injection! <literal>@Inject</literal> may be applied to a constructor or method of a bean, and tells the container to call that constructor or method when instantiating the bean. The container will inject other beans into the parameters of the constructor or method."
msgstr "Wie Sie wahrscheinlich bereits erraten haben, hat die <literal>@Initializer</literal>-Annotation etwas mit Dependency-Einspeisung zu tun! <literal>@Initializer</literal> kann am Konstruktor oder der Methode eines Web Beans angewendet werden und teilt dem Web Bean Manager mit, diesen Konstruktor oder diese Methode bei Instantiierung des Web Beans aufzurufen. Der Web Bean Manager speist andere Web Beans in die Parameter des Konstruktors oder der Methode ein."

#. Tag: para
#, no-c-format
msgid "We may obtain an instance of <literal>TextTranslator</literal> by injecting it into a constructor, method or field of a bean, or a field or method of a Java EE component class such as a servlet. The container chooses the object to be injected based on the type of the injection point, not the name of the field, method or parameter."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Let's create a UI controller bean that uses field injection to obtain an instance of the <literal>TextTranslator</literal>, translating the text entered by a user:"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"@Named @RequestScoped\n"
"public class TranslateController {\n"
"   @Inject TextTranslator textTranslator;\n"
"\n"
"   private String inputText;\n"
"   private String translation;\n"
"\n"
"   // JSF action method, perhaps\n"
"   public void translate() {\n"
"      translation = textTranslator.translate(inputText); \n"
"   }\n"
"\n"
"   public String getInputText() {\n"
"      return inputText;\n"
"   }\n"
"\n"
"   public void setInputText(String text) {\n"
"      this.inputText = text;\n"
"   }\n"
"\n"
"   public String getTranslation() {\n"
"      return translation;\n"
"   }\n"
"}"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Field injection of <literal>TextTranslator</literal> instance"
msgstr "Wo <literal>Translator</literal> das lokale Interface ist:"

#. Tag: para
#, no-c-format
msgid "Notice the controller bean is request-scoped and named. Since this combination is so common in web applications, there's a built-in annotation for it in CDI that we could have used as a shorthand. When the (stereotype) annotation <literal>@Model</literal> is declared on a class, it creates a request-scoped and named bean."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Alternatively, we may obtain an instance of <literal>TextTranslator</literal> programmatically from an injected instance of <literal>Instance</literal>, parameterized with the bean type:"
msgstr "Wir erhalten eine Instanz von <literal>TextTranslator</literal> durch dessen Einspeisung in ein Web Bean, Servlet oder EJB:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject Instance&lt;TextTranslator&gt; textTranslatorInstance;\n"
"...\n"
"public void translate() {\n"
"   textTranslatorInstance.get().translate(inputText);\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public setTextTranslator(TextTranslator textTranslator) {\n"
"    this.textTranslator = textTranslator;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Notice that it isn't necessary to create a getter or setter method to inject one bean into another. CDI can access an injected field directly (even if it's private!), which sometimes helps eliminate some wasteful code. The name of the field is arbitrary. It's the field's type that determines what is injected."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "At system initialization time, the container must validate that exactly one bean exists which satisfies each injection point. In our example, if no implementation of <literal>Translator</literal> is available&mdash;if the <literal>SentenceTranslator</literal> EJB was not deployed&mdash;the container would inform us of an <emphasis>unsatisfied dependency</emphasis>. If more than one implementation of <literal>Translator</literal> were available, the container would inform us of the <emphasis>ambiguous dependency</emphasis>."
msgstr "Zum Zeitpunkt der Systeminitialisierung muss der Web Bean Manager validieren, dass genau ein Web Bean existiert, das jedem Einspeisungspunkt gerecht wird. Für unser Beispiel bedeutet das, wenn keine Implementierung von <literal>Translator</literal> verfügbar ist &#151; wenn der <literal>SentenceTranslator</literal> EJB nicht deployt wurde &#151; dass der Web Bean Manager eine <literal>UnsatisfiedDependencyException</literal> melden würde. Wäre mehr als eine Implementierung von <literal>Translator</literal> verfügbar, so würde der Web Bean Manager eine <literal>AmbiguousDependencyException</literal> melden."

#. Tag: para
#, no-c-format
msgid "Before we get too deep in the details, let's pause and examine a bean's anatomy. What aspects of the bean are significant, and what gives it its identity? Instead of just giving examples of beans, we're going to define what <emphasis>makes</emphasis> something a bean."
msgstr ""

#~ msgid "Getting started with Web Beans"
#~ msgstr "Erste Schritte mit Web Beans"

#~ msgid "Your first Web Bean"
#~ msgstr "Ihr erstes Web Bean"

#~ msgid "With certain, very special exceptions, every Java class with a constructor that accepts no parameters is a Web Bean. That includes every JavaBean. Furthermore, every EJB 3-style session bean is a Web Bean. Sure, the JavaBeans and EJBs you've been writing every day have not been able to take advantage of the new services defined by the Web Beans specification, but you'll be able to use every one of them as Web Beans &#151; injecting them into other Web Beans, configuring them via the Web Beans XML configuration facility, even adding interceptors and decorators to them &#151; without touching your existing code."
#~ msgstr "Mit bestimmten, ganz besonderen Ausnahmen ist jede Java-Klasse mit einem Konstruktor, die keine Parameter akzeptiert ein Web Bean. Das beinhaltet jedes JavaBean. Desweiteren ist jedes EJB 3-artige Session Bean ein Web Bean. Sicher, die von Ihnen täglich geschriebenen JavaBeans und EJBs konnten die neuen, in der Web Beans Spezifikation definierten Dienste nicht nutzen, aber Sie werden diese allesamt benutzen können können, das Web Beans &#151; diese in andere Web Beans einspeisen, diese via der Web Beans XML-Konfigurationseinrichtung konfigurieren und diesen sogar Interzeptoren und Dekoratoren hinzufügen, ohne den bestehenden Code anzurühren."

#~ msgid "Alternatively, we may obtain an instance by directly calling a method of the Web Bean manager:"
#~ msgstr "Alternativ erhalten wir eine Instanz durch direkten Aufruf einer Methode des Web Bean Managers:"

#~ msgid "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"
#~ msgstr "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"

#~ msgid "So what, <emphasis>exactly</emphasis>, is a Web Bean?"
#~ msgstr "Was also <emphasis>genau</emphasis> ist ein Web Bean?"

#~ msgid "A Web Bean is an application class that contains business logic. A Web Bean may be called directly from Java code, or it may be invoked via Unified EL. A Web Bean may access transactional resources. Dependencies between Web Beans are managed automatically by the Web Bean manager. Most Web Beans are <emphasis>stateful</emphasis> and <emphasis>contextual</emphasis>. The lifecycle of a Web Bean is always managed by the Web Bean manager."
#~ msgstr "Bei einem Web Bean handelt es sich um eine Anwendungsklasse, die Business Logik enthält. Ein Web Bean kann direkt von Java Code oder via Unified EL aufgerufen werden. Ein Web Bean kann auf transaktionale Ressourcen zugreifen. Abhängigkeiten zwischen Web Beans werden automatisch durch den Web Bean Manager verwaltet. Die meisten Web Beans sind <emphasis>stateful</emphasis> und <emphasis>kontextbezogen</emphasis>. Der Lebenszyklus eines Web Beans wird immer durch den Web Bean Manager verwaltet."

#~ msgid "Let's back up a second. What does it really mean to be \"contextual\"? Since Web Beans may be stateful, it matters <emphasis>which</emphasis> bean instance I have. Unlike a stateless component model (for example, stateless session beans) or a singleton component model (such as servlets, or singleton beans), different clients of a Web Bean see the Web Bean in different states. The client-visible state depends upon which instance of the Web Bean the client has a reference to."
#~ msgstr "Erinnern wir uns. Was genau bedeutet es, \"kontextuell\" zu sein? Da Web Beans \"stateful\" sein können, ist es relevant <emphasis>welche</emphasis> Bean-Instanz ich besitze. Anders als ein Komponentenmodell, das \"stateless\" ist (etwas \"stateless\" Session Beans) oder ein Singleton Komponentenmodell (wie Servlets oder Singleton Beans), sehen verschiedene Clients eines Web Beans das Web Bean in unterschiedlichen Stati. Der Client-sichtbare Status ist abhängig davon, auf welche Instanz des Web Beans der Client verweist (eine Referenz besitzt)."

#~ msgid "However, like a stateless or singleton model, but <emphasis>unlike</emphasis> stateful session beans, the client does not control the lifecycle of the instance by explicitly creating and destroying it. Instead, the <emphasis>scope</emphasis> of the Web Bean determines:"
#~ msgstr "Wie beim \"stateless\" oder \"singleton\" Modell <emphasis>anders</emphasis> jedoch als bei \"stateful\" Session Beans, steuert der Client den Lebenszyklus der Instanz nicht durch expliziertes Erstellen und Löschen. Stattdessen bestimmt der <emphasis>Geltungsbereich</emphasis> des Web Beans:"

#~ msgid "the lifecycle of each instance of the Web Bean and"
#~ msgstr "der Lebenszyklus jeder Instanz des Web Beans und"

#~ msgid "which clients share a reference to a particular instance of the Web Bean."
#~ msgstr "Welche Clients teilen sich eine Referenz zu einer bestimmten Instanz des Web Beans."

#~ msgid "For a given thread in a Web Beans application, there may be an <emphasis>active context</emphasis> associated with the scope of the Web Bean. This context may be unique to the thread (for example, if the Web Bean is request scoped), or it may be shared with certain other threads (for example, if the Web Bean is session scoped) or even all other threads (if it is application scoped)."
#~ msgstr "Für einen bestimmten Thread in einer Web Beans Anwendung kann ein <emphasis>aktiver Kontext</emphasis> mit dem Geltungsbereich des Web Beans assoziiert sein. Dieser Kontext kann eindeutig für den Thread sein (etwa wenn für die Web Bean Anfrage ein Geltungsbereich gilt) oder aber kann mit anderen Threads (etwa wenn für die Web Bean ein Session-Geltungsbereich gilt) oder gar allen Threads (falls ein Anwendungs-Geltungsbereich gilt) geteilt werden."

#~ msgid "Clients (for example, other Web Beans) executing in the same context will see the same instance of the Web Bean. But clients in a different context will see a different instance."
#~ msgstr "Clients (etwa andere Web Beans), die in demselben Kontext ausführen sehen dieselbe Instanz des Web Beans. Clients in einem anderen Kontext aber sehen eine andere Instanz."

#~ msgid "One great advantage of the contextual model is that it allows stateful Web Beans to be treated like services! The client need not concern itself with managing the lifecycle of the Web Bean it is using, <emphasis>nor does it even need to know what that lifecyle is.</emphasis> Web Beans interact by passing messages, and the Web Bean implementations define the lifecycle of their own state. The Web Beans are loosely coupled because:"
#~ msgstr "Ein großer Vorteil des kontextuellen Modells ist es, dass es uns gestattet, stateful Web Beans wie Dienste zu behandeln! Der Client muss sich keine Gedanken um das Management des Lebenszyklus des verwendeten Web Beans machen und <emphasis>muss nicht einmal wissen was der Lebenszyklus ist.</emphasis> Web Beans interagieren durch Weitergabe von Nachrichten und die Web Bean Implementierungen definieren den Lebenszyklus ihres eigenen Status. Die Web Beans sind lose gepaart, weil:"

#~ msgid "they interact via well-defined public APIs"
#~ msgstr "sie interagieren über gut definierte öffentliche APIs"

#~ msgid "their lifecycles are completely decoupled"
#~ msgstr "ihre Lebenszyklen sind vollständig abgekuppelt"

#~ msgid "We can replace one Web Bean with a different Web Bean that implements the same API and has a different lifecycle (a different scope) without affecting the other Web Bean implementation. In fact, Web Beans defines a sophisticated facility for overriding Web Bean implementations at deployment time, as we will see in <xref linkend=\"deploymenttypes\"/>."
#~ msgstr "Wir können ein Web Bean durch ein anderes Web Bean ersetzen, das dasselbe API und einen anderen Lebenszyklus (einen anderen Geltungsbereich) besitzt, ohne dass die übrige Web Bean Implementierung hiervon betroffen ist. Genau genommen definieren Web Beans eine raffinierte Einrichtung zur Außerkraftsetzung von Web Bean Implementierungen zum Zeitpunkt des Deployment wie wir in <xref linkend=\"deploymenttypes\"/> noch sehen werden."

#~ msgid "Note that not all clients of a Web Bean are Web Beans. Other objects such as Servlets or Message-Driven Beans &#151; which are by nature not injectable, contextual objects &#151; may also obtain references to Web Beans by injection."
#~ msgstr "Beachten Sie, dass es sich nicht bei allen Clients eines Web Beans um Web Beans handelt. Andere Objekte wie Servlets oder Message-Driven Beans &#151; die ihrem Wesen nach nicht einspeisbar sind, kontextuelle Objekte &#151; können durch Einspeisung ebenfalls Verweise auf ein Web Beans erhalten."

#~ msgid "Enough hand-waving. More formally, according to the spec:"
#~ msgstr "Formeller gilt, gemäß der Spezifikation:"

#~ msgid "A Web Bean comprises:"
#~ msgstr "Ein Web Bean besteht aus:"

#~ msgid "A (nonempty) set of API types"
#~ msgstr "Einem (nicht leeren) Satz von API-Typen"

#~ msgid "A (nonempty) set of binding annotation types"
#~ msgstr "Einem (nicht leeren) Satz von bindenden Annotationstypen"

#~ msgid "A scope"
#~ msgstr "Einem Geltungsbereich"

#~ msgid "A deployment type"
#~ msgstr "Einem Deployment-Typ"

#~ msgid "Optionally, a Web Bean name"
#~ msgstr "Optional einem Web Bean Namen"

#~ msgid "A set of interceptor binding types"
#~ msgstr "Ein Satz Interzeptor Binding-Typen"

#~ msgid "A Web Bean implementation"
#~ msgstr "Einer Web Bean Implementierung"

#~ msgid "Let's see what some of these terms mean, to the Web Bean developer."
#~ msgstr "Sehen wir uns jetzt genauer an, was diese Begriffe für einen Entwickler von Web Beans bedeuten."

#~ msgid "API types, binding types and dependency injection"
#~ msgstr "API-Typen, Binding-Typen und Dependency-Einspeisung"

#~ msgid "Web Beans usually acquire references to other Web Beans via dependency injection. Any injected attribute specifies a \"contract\" that must be satisfied by the Web Bean to be injected. The contract is:"
#~ msgstr "Web Beans erhalten Verweise auf andere Web Beans in der Regel via \"Dependency\"-Einspeisung. Jedes eingespeiste Attribut legt einen \"Vertrag\" fest, der vom einzuspeisenden Web Bean erfüllt sein muss. Der Vertrag lautet:"

#~ msgid "an API type, together with"
#~ msgstr "ein API-Typ, zusammen mit "

#~ msgid "a set of binding types."
#~ msgstr "einem Satz von Binding-Typen."

#~ msgid "An API is a user-defined class or interface. (If the Web Bean is an EJB session bean, the API type is the <literal>@Local</literal> interface or bean-class local view). A binding type represents some client-visible semantic that is satisfied by some implementations of the API and not by others."
#~ msgstr "Bei einem API handelt es sich um eine benutzerdefinierte Klasse oder Interface. (Falls es sich bei dem Web Bean um ein EJB Session Bean handelt, so ist der API-Typ das <literal>@Local</literal>-Interface oder Bean-Klasse lokale Ansicht). Ein Binding-Typ repräsentiert Client-sichtbare Semantik, die von einigen Implementierungen des API erfüllt wird, von anderen wiederum nicht."

#~ msgid "Binding types are represented by user-defined annotations that are themselves annotated <literal>@BindingType</literal>. For example, the following injection point has API type <literal>PaymentProcessor</literal> and binding type <literal>@CreditCard</literal>:"
#~ msgstr "Binding-Typen werden durch benutzerdefinierte Annotationen repräsentiert, die ihrerseits mit <literal>@BindingType</literal> annotiert sind. Zum Beispiel besitzt der folgende Einspeisungspunkt den API-Typ <literal>PaymentProcessor</literal> und Binding-Typ <literal>@CreditCard</literal>:"

#~ msgid "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"
#~ msgstr "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"

#~ msgid "If no binding type is explicitly specified at an injection point, the default binding type <literal>@Current</literal> is assumed."
#~ msgstr "Wird an einem Einspeisungspunkt kein Binding-Typ explizit festgelegt, so wird vom standardmäßigen Binding-Typ <literal>@Current</literal> ausgegangen."

#~ msgid "For each injection point, the Web Bean manager searches for a Web Bean which satisfies the contract (implements the API, and has all the binding types), and injects that Web Bean."
#~ msgstr "Für jeden Einspeisungspunkt sucht der Web Bean Manager nach einem Web Bean, das den Vertrag erfüllt (das API implementiert und alle Binding-Typen besitzt) und speist dieses Web Bean ein."

#~ msgid "The following Web Bean has the binding type <literal>@CreditCard</literal> and implements the API type <literal>PaymentProcessor</literal>. It could therefore be injected to the example injection point:"
#~ msgstr "Das folgende Web Bean besitzt den Binding-Typ <literal>@CreditCard</literal> und implementiert den API-Typ <literal>PaymentProcessor</literal>. Es könnte daher am Beispiel-Einspeisungspunkt eingespeist werden:"

#~ msgid ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"

#~ msgid "If a Web Bean does not explicitly specify a set of binding types, it has exactly one binding type: the default binding type <literal>@Current</literal>."
#~ msgstr "Falls ein Web Bean nicht explizit einen Satz von Binding-Typen festlegt, so besitzt es genau einen Binding-Typ: den standardmäßigen Binding-Typ <literal>@Current</literal>."

#~ msgid "Web Beans defines a sophisticated but intuitive <emphasis>resolution algorithm</emphasis> that helps the container decide what to do if there is more than one Web Bean that satisfies a particular contract. We'll get into the details in <xref linkend=\"injection\"/>."
#~ msgstr "Web Beans definiert einen fortgeschrittenen aber intuitiven <emphasis>Auflösungsalgorithmus</emphasis>, der dem Container dabei hilft zu entscheiden was geschehen soll, wenn mehr als ein Web Bean einen bestimmten Vertrag erfüllt. Wir gehen in <xref linkend=\"injection\"/> näher darauf ein."

#~ msgid "Deployment types"
#~ msgstr "Deployment-Typen"

#~ msgid "<emphasis>Deployment types</emphasis> let us classify our Web Beans by deployment scenario. A deployment type is an annotation that represents a particular deployment scenario, for example <literal>@Mock</literal>, <literal>@Staging</literal> or <literal>@AustralianTaxLaw</literal>. We apply the annotation to Web Beans which should be deployed in that scenario. A deployment type allows a whole set of Web Beans to be conditionally deployed, with a just single line of configuration."
#~ msgstr "<emphasis>Deployment-Typen</emphasis> gestatten die Klassifizierung unserer Web Beans mittels Deployment Szenario. Ein Deployment-Typ ist eine Annotation, die ein bestimmtes Deployment-Szenario repräsentiert, etwa <literal>@Mock</literal>, <literal>@Staging</literal> oder <literal>@AustralianTaxLaw</literal>. Wir setzen die Annotation bei Web Beans ein, die in diesem Szenario deployt werden sollten. Ein Deployment-Typ gestattet mit nur einer einzelnen Konfigurationszeile einem ganzen Satz von Web Beans unter Vorbehalt in diesem Szenario deployt zu werden."

#~ msgid "Many Web Beans just use the default deployment type <literal>@Production</literal>, in which case no deployment type need be explicitly specified. All three Web Bean in our example have the deployment type <literal>@Production</literal>."
#~ msgstr "Viele Web Beans verwenden nur den standardmäßigen Deployment-Typ <literal>@Production</literal>, in welchem Fall kein Deployment-Typ explizit festgelegt werden muss. Alle drei Web Beans in unserem Beispiel besitzen den Deployment-Typ <literal>@Production</literal>."

#~ msgid "In a testing environment, we might want to replace the <literal>SentenceTranslator</literal> Web Bean with a \"mock object\":"
#~ msgstr "In einer Testumgebung können wir das <literal>SentenceTranslator</literal> Web Bean durch ein \"mock object\" ersetzen:"

#~ msgid ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"

#~ msgid "We would enable the deployment type <literal>@Mock</literal> in our testing environment, to indicate that <literal>MockSentenceTranslator</literal> and any other Web Bean annotated <literal>@Mock</literal> should be used."
#~ msgstr "Wir würden den Deployment-Typ <literal>@Mock</literal> in unserer Testumgebung aktivieren, um anzuzeigen, dass <literal>MockSentenceTranslator</literal> und ein beliebiges anderes mit <literal>@Mock</literal> annotiertes Web Bean verwendet werden sollen."

#~ msgid "We'll talk more about this unique and powerful feature in <xref linkend=\"deploymenttypes\"/>."
#~ msgstr "In <xref linkend=\"deploymenttypes\"/> gehen wir näher auf dieses einzigartige und leistungsfähige Feature ein."

#~ msgid "Scope"
#~ msgstr "Geltungsbereich"

#~ msgid "The <emphasis>scope</emphasis> defines the lifecycle and visibility of instances of the Web Bean. The Web Beans context model is extensible, accommodating arbitrary scopes. However, certain important scopes are built-in to the specification, and provided by the Web Bean manager. A scope is represented by an annotation type."
#~ msgstr "Der <emphasis>Geltungsbereich</emphasis> definiert den Lebenszyklus und die Sichtbarkeit von Instanzen des Web Beans. Das Web Beans Kontextmodell ist erweiterbar, um arbiträre Geltungsbereiche zu ermöglichen. Jedoch sind bestimmte wichtige Geltungsbereiche in die Spezifikation eingebaut und werden vom Web Bean bereitgestellt. Ein Geltungsbereich wird durch einen Annotationstyp repräsentiert."

#~ msgid "For example, any web application may have <emphasis>session scoped</emphasis> Web Beans:"
#~ msgstr "Web-Anwendungen können zum Beispiel <emphasis>Session-begrenzte</emphasis> Web Beans besitzen:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "An instance of a session scoped Web Bean is bound to a user session and is shared by all requests that execute in the context of that session."
#~ msgstr "Eine Instanz eines sessionbegrenzten Web Beans wird an eine Benutzer-Session gebunden und wird von allen im Kontext dieser Session ausführenden Anfragen geteilt."

#~ msgid "By default, Web Beans belong to a special scope called the <emphasis>dependent pseudo-scope</emphasis>. Web Beans with this scope are pure dependent objects of the object into which they are injected, and their lifecycle is bound to the lifecycle of that object."
#~ msgstr "Standardmäßig gehören Web Beans zu einem bestimmten Geltungsbereich namens <emphasis>abhängiger Pseudo-Geltungsbereich</emphasis> (sog. \"dependent pseudo-scope\"). Web Beans mit diesem Geltungsbereich sind reine abhängige Objekte von demjenigen Objekt, in das sie eingespeist werden und ihr Lebenszyklus ist an den Lebenszyklus eben dieses Objekts gebunden."

#~ msgid "We'll talk more about scopes in <xref linkend=\"scopescontexts\"/>."
#~ msgstr "In <xref linkend=\"scopescontexts\"/> gehen wir näher auf Geltungsbereiche ein."

#~ msgid "Web Bean names and Unified EL"
#~ msgstr "Web Bean Namen und Unified EL"

#~ msgid "A Web Bean may have a <emphasis>name</emphasis>, allowing it to be used in Unified EL expressions. It's easy to specify the name of a Web Bean:"
#~ msgstr "Ein Web Bean kann einen <emphasis>Namen</emphasis> besitzen, wodurch es möglich ist, dieses in Unified EL Ausdrücken einzusetzen. Das Festlegen eines Namens für ein Web Bean ist ganz einfach:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "Now we can easily use the Web Bean in any JSF or JSP page:"
#~ msgstr "Jetzt können wir das Web Bean einfach in einer beliebigen JSF- oder JSP-Seite verwenden:"

#~ msgid ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"
#~ msgstr ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"

#~ msgid "It's even easier to just let the name be defaulted by the Web Bean manager:"
#~ msgstr "Es ist sogar noch einfacher den Name vom Web Bean Manager standardisieren zu lassen:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "In this case, the name defaults to <literal>shoppingCart</literal> &#151; the unqualified class name, with the first character changed to lowercase."
#~ msgstr "In diesem Fall wird der Name standardmäßig zu <literal>shoppingCart</literal> &#151; dem nicht vollständigen Klassennamen, wobei der erste Buchstabe klein geschrieben wird."

#~ msgid "Interceptor binding types"
#~ msgstr "Interzeptor Binding-Typen"

#~ msgid "Web Beans supports the interceptor functionality defined by EJB 3, not only for EJB beans, but also for plain Java classes. In addition, Web Beans provides a new approach to binding interceptors to EJB beans and other Web Beans."
#~ msgstr "Web Beans unterstützt die von EJB 3 definierte Interzeptor-Funktionalität nicht nur für EJB-Beans, sondern auch für einfache Java-Klassen. Desweiteren bietet Web Beans eine neue Herangehensweise bei der Bindung von Interzeptoren an EJB-Beans und andere Web-Beans."

#~ msgid "It remains possible to directly specify the interceptor class via use of the <literal>@Interceptors</literal> annotation:"
#~ msgstr "Es bleibt weiterhin möglich, die Interzeptorklasse mittels Verwendung der <literal>@Interceptors</literal>-Annotation direkt festzulegen:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "However, it is more elegant, and better practice, to indirect the interceptor binding through an <emphasis>interceptor binding type</emphasis>:"
#~ msgstr "Es ist aber eleganter und generell besser das Interzeptor-Binding durch einen <emphasis>Interzeptor-Binding-Typ</emphasis> umzuleiten:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "We'll discuss Web Beans interceptors and decorators in <xref linkend=\"interceptors\"/> and <xref linkend=\"decorators\"/>."
#~ msgstr "Wir gehen in <xref linkend=\"interceptors\"/> and <xref linkend=\"decorators\"/> näher auf Web Beans Interzeptoren und Dekoratoren ein."

#~ msgid "What kinds of objects can be Web Beans?"
#~ msgstr "Welche Art von Objekten können Web Beans sein?"

#~ msgid "We've already seen that JavaBeans, EJBs and some other Java classes can be Web Beans. But exactly what kinds of objects are Web Beans?"
#~ msgstr "Wir haben bereits gesehen, dass JavaBeans, EJBs und einige andere Java-Klassen Web Beans sein können. Aber um was für Objekte genau handelt es sich bei Web Beans?"

#~ msgid "Simple Web Beans"
#~ msgstr "Einfache Web Beans"

#~ msgid "The Web Beans specification says that a concrete Java class is a <emphasis>simple</emphasis> Web Bean if:"
#~ msgstr "Die Web Beans Spezifikation besagt, dass eine konkrete Java-Klasse ein <emphasis>einfaches</emphasis> Web Bean ist, wenn:"

#~ msgid "it is not an EE container-managed component, like an EJB, a Servlet or a JPA entity,"
#~ msgstr "Es es sich nicht um eine EE Container-gemanagte Komponente wie ein EJB, ein Servlet oder eine JPA-Entity handelt,"

#~ msgid "it is not a non-static static inner class,"
#~ msgstr "es sich nicht um eine nicht-statische statische innere Klasse handelt,"

#~ msgid "it is not a parameterized type, and"
#~ msgstr "es sich nicht um einen parametisierten Typ handelt und "

#~ msgid "it has a constructor with no parameters, or a constructor annotated <literal>@Initializer</literal>."
#~ msgstr "ein Konstruktor ohne Parameter oder ein mit <literal>@Initializer</literal> annotierter Konstruktor vorhanden ist."

#~ msgid "Thus, almost every JavaBean is a simple Web Bean."
#~ msgstr "Daher handelt es sich bei fast jedem JavaBean um ein einfaches Web Bean."

#~ msgid "Every interface implemented directly or indirectly by a simple Web Bean is an API type of the simple Web Bean. The class and its superclasses are also API types."
#~ msgstr "Jedes direkt oder indirekt durch ein einfaches Web Bean implementierte Interface ist ein API-Typ des einfachen Web Beans. Die Klasse und deren Superklassen sind ebenfalls API-Typen."

#~ msgid "Enterprise Web Beans"
#~ msgstr "Enterprise Web Beans"

#~ msgid "The specification says that all EJB 3-style session and singleton beans are <emphasis>enterprise</emphasis> Web Beans. Message driven beans are not Web Beans &#151; since they are not intended to be injected into other objects &#151; but they can take advantage of most of the functionality of Web Beans, including dependency injection and interceptors."
#~ msgstr "Die Spezifikation besagt, dass alle EJB 3-style Session und Singleton Beans <emphasis>Enterprise</emphasis> Web Beans sind. Message-driven Beans sind keine Web Beans &#151; da sie nicht zur Einspeisung in andere Objekte vorgesehen sind &#151; aber sie können den größten Teil der Funktionalität von Web Beans nutzen, darunter auch \"Dependency\"-Einspeisung und Interzeptoren."

#~ msgid "Every local interface of an enterprise Web Bean that does not have a wildcard type parameter or type variable, and every one of its superinterfaces, is an API type of the enterprise Web Bean. If the EJB bean has a bean class local view, the bean class, and every one of its superclasses, is also an API type."
#~ msgstr "Jedes lokale Interface eines Enterprise Web Beans und jedes seiner Super-Interfaces, das keinen Platzhaltertyp-Parameter oder eine Typenvariable besitzt, ist ein API-Typ des Enterprise Web Beans. Falls das EJB-Bean eine lokale Ansicht der Bean-Klasse besitzt, so handelt es sich auch bei der Bean-Klasse und jede von deren Super-Klassen um einen API-Typ."

#~ msgid "Stateful session beans should declare a remove method with no parameters or a remove method annotated <literal>@Destructor</literal>. The Web Bean manager calls this method to destroy the stateful session bean instance at the end of its lifecycle. This method is called the <emphasis>destructor</emphasis> method of the enterprise Web Bean."
#~ msgstr "Stateful Session Beans sollten eine Entfernungsmethode (\"remove method\") ohne Parameter oder eine Entfernungsmethode mit der Annotation <literal>@Destructor</literal> deklarieren. Der Web Bean Manager ruft diese Methode auf, um die Instanz des stateful Session Beans am Ende von deren Lebenszyklus zu löschen. Diese Methode nennt sich <emphasis>Destructor</emphasis>-Methode des Enterprise Web Beans."

#~ msgid ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"

#~ msgid "So when should we use an enterprise Web Bean instead of a simple Web Bean? Well, whenever we need the advanced enterprise services offered by EJB, such as:"
#~ msgstr "Sollten wir also ein Enterprise Web Bean statt eines einfachen Web Beans verwenden? Nun, wenn wir ausgefeilte, durch EJB bereitgestellte Enterprise-Dienste benötigen, wie etwa:"

#~ msgid "method-level transaction management and security,"
#~ msgstr "Transaktionsmanagement und Sicherheit auf Methodenebene, "

#~ msgid "concurrency management,"
#~ msgstr "Nebenläufigkeits-Management,"

#~ msgid "instance-level passivation for stateful session beans and instance-pooling for stateless session beans,"
#~ msgstr "Passivation für stateful Session Beans und Instance-Pooling für stateless Session Beans auf Instanzebene "

#~ msgid "remote and web service invocation, and"
#~ msgstr "Remote und Web-Service Aufruf und "

#~ msgid "timers and asynchronous methods,"
#~ msgstr "Timer und asynchrone Methoden,"

#~ msgid "we should use an enterprise Web Bean. When we don't need any of these things, a simple Web Bean will serve just fine."
#~ msgstr "so sollten wir ein Enterprise Web Bean verwenden. Wenn wir nichts von alledem brauchen, so reicht ein einfaches Web Bean vollkommen aus."

#~ msgid "Many Web Beans (including any session or application scoped Web Bean) are available for concurrent access. Therefore, the concurrency management provided by EJB 3.1 is especially useful. Most session and application scoped Web Beans should be EJBs."
#~ msgstr "Viele Web Beans (einschließlich session- oder anwendungsbegrenzte Web Beans) sind für nebenläufigen Zugriff verfügbar. Daher ist das durch EJB 3.1 bereitgestellte Nebenläufigkeits-Management besonders nützlich. Die meisten session- oder anwendungsbegrenzten Web Beans sollten EJBs sein."

#~ msgid "Web Beans which hold references to heavy-weight resources, or hold a lot of internal state benefit from the advanced container-managed lifecycle defined by the EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal> model, with its support for passivation and instance pooling."
#~ msgstr "Web Beans, die Verweise auf schwergewichtige Ressourcen oder eine Menge internen Status besitzen, haben Vorteile durch den fortgeschrittenen, Container-gemanagten, durch das EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal>-Modell definierten Lebenszyklus und dessen Support von Passivation und Instanz-Pooling."

#~ msgid "Finally, it's usually obvious when method-level transaction management, method-level security, timers, remote methods or asynchronous methods are needed."
#~ msgstr "Schließlich ist es offenkundig, wenn Transaktions-Management auf Methodenebene, Sicherheit auf Methodenebene, Timer, Remote-Methoden oder asynchrone Methoden benötigt werden."

#~ msgid "It's usually easy to start with simple Web Bean, and then turn it into an EJB, just by adding an annotation: <literal>@Stateless</literal>, <literal>@Stateful</literal> or <literal>@Singleton</literal>."
#~ msgstr "Es ist in der Regel leicht, mit einem einfachen Web Bean zu beginnen und es dann zu einem EJB zu machen, indem man eine Annotation: <literal>@Stateless</literal>, <literal>@Stateful</literal> oder <literal>@Singleton</literal> hinzufügt."

#~ msgid "Producer methods"
#~ msgstr "Producer-Methoden"

#~ msgid "A <emphasis>producer method</emphasis> is a method that is called by the Web Bean manager to obtain an instance of the Web Bean when no instance exists in the current context. A producer method lets the application take full control of the instantiation process, instead of leaving instantiation to the Web Bean manager. For example:"
#~ msgstr "Eine <emphasis>Producer-Methode</emphasis> ist eine Methode, die vom Web Bean Manager aufgerufen wird, um eine Instanz des Web Beans zu erhalten, wenn im aktuellen Kontext keine existiert. Eine Producer-Methodübernehmen, statt die Instantiierung dem Web Bean Manager zu überlassen. Zum Beispiel:"

#~ msgid ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid "The result of a producer method is injected just like any other Web Bean."
#~ msgstr "Einspeisung des Ergebnisses einer Producer-Methode erfolgt wie bei einem regulären Web Bean."

#~ msgid "<![CDATA[@Random int randomNumber]]>"
#~ msgstr "<![CDATA[@Random int randomNumber]]>"

#~ msgid "The method return type and all interfaces it extends/implements directly or indirectly are API types of the producer method. If the return type is a class, all superclasses are also API types."
#~ msgstr "Der Methodenwiedergabetyp (\"Method Return Type\") und alle Interfaces, die er direkt oder indirekt erweitert/implementiert sind API-Typen der Producer-Methode. Handelt es sich beim Wiedergabetyp um eine Klasse, so sind alle Superklassen ebenfalls API-Typen."

#~ msgid "Some producer methods return objects that require explicit destruction:"
#~ msgstr "Einige Producer-Methoden geben Objekte wieder, die explizite Löschung erfordern:"

#~ msgid ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"

#~ msgid "These producer methods may define matching <emphasis>disposal methods</emphasis>:"
#~ msgstr "Diese Producer-Methoden können übereinstimmende <emphasis>Disposal Methods</emphasis> (Entsorgungsmethoden) definieren:"

#~ msgid ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"

#~ msgid "This disposal method is called automatically by the Web Bean manager at the end of the request."
#~ msgstr "Diese Entsorgungsmethode wird am Ende der Anfrage automatisch vom Web Bean Manager aufgerufen."

#~ msgid "We'll talk much more about producer methods in <xref linkend=\"producermethods\"/>."
#~ msgstr "In <xref linkend=\"producermethods\"/> erfahren Sie mehr über Producer-Methoden."

#~ msgid "JMS endpoints"
#~ msgstr "JMS-Endpunkte"

#~ msgid "Finally, a JMS queue or topic can be a Web Bean. Web Beans relieves the developer from the tedium of managing the lifecycles of all the various JMS objects required to send messages to queues and topics. We'll discuss JMS endpoints in <xref linkend=\"jms\"/>."
#~ msgstr "Auch eine JMS-Warteschlange oder ein Topic können Web Beans sein. Web Beans nimmt dem Entwickler die Arbeit des Management der Lebenszyklen aller verschiedener JMS-Objekte ab, die zum Senden von Nachrichten an Warteschlangen und Topics erforderlich sind. Wir gehen in <xref linkend=\"jms\"/> auf JMS-Endpunkte ein."
