# translation of injection.po to Traditional Chinese
# Language zh-TW translations for Introduction_to_Web_Beans package.
#
# Automatically generated, 2009.
# Terry Chuang <tchuang@redhat.com>, 2009.
msgid ""
msgstr ""
"Project-Id-Version: injection\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2012-01-16T16:07:16\n"
"PO-Revision-Date: 2009-01-19 16:05+1000\n"
"Last-Translator: Terry Chuang <tchuang@redhat.com>\n"
"Language-Team: Traditional Chinese <zh@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, fuzzy, no-c-format
msgid "Dependency injection and programmatic lookup"
msgstr "依賴注入（Dependency injection）"

#. Tag: para
#, no-c-format
msgid "One of the most significant features of CDI&mdash;certainly the most recognized&mdash;is dependency injection; excuse me, <emphasis>typesafe</emphasis> dependency injection."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Injection points"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The <literal>@Inject</literal> annotation lets us define an injection point that is injected during bean instantiation. Injection can occur via three different mechanisms."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis>Bean constructor</emphasis> parameter injection:"
msgstr "<emphasis>Initializer</emphasis> method parameter injection："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"        \n"
"   private final ShoppingCart cart;\n"
"    \n"
"   @Inject\n"
"   public Checkout(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private final ShoppingCart cart;\n"
"    \n"
"    @Initializer\n"
"    public Checkout(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "A bean can only have one injectable constructor."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis>Initializer method</emphasis> parameter injection:"
msgstr "<emphasis>Initializer</emphasis> method parameter injection："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"        \n"
"   private ShoppingCart cart;\n"
"\n"
"   @Inject\n"
"   void setShoppingCart(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"    \n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private ShoppingCart cart;\n"
"\n"
"    @Initializer \n"
"    void setShoppingCart(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "A bean can have multiple initializer methods. If the bean is a session bean, the initializer method is not required to be a business method of the session bean."
msgstr ""

#. Tag: para
#, no-c-format
msgid "And direct field injection:"
msgstr "以及 direct field injection："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"\n"
"   private @Inject ShoppingCart cart;\n"
"    \n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"\n"
"    private @Current ShoppingCart cart;\n"
"    \n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Getter and setter methods are not required for field injection to work (unlike with JSF managed beans)."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Dependency injection always occurs when the bean instance is first instantiated by the container. Simplifying just a little, things happen in this order:"
msgstr "每當 Web Bean 的 instance 第一次被例示時，依賴注入就會發生。"

#. Tag: para
#, fuzzy, no-c-format
msgid "First, the container calls the bean constructor (the default constructor or the one annotated <literal>@Inject</literal>), to obtain an instance of the bean."
msgstr "首先，Web Bean 管理員會調用 Web Bean constructor，並取得 Web Bean 的某個 instance。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Next, the container initializes the values of all injected fields of the bean."
msgstr "接下來，Web Bean 管理員便會初始化 Web Bean 所有已注入欄位的值。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Next, the container calls all initializer methods of bean (the call order is not portable, don't rely on it)."
msgstr "然後，Web Bean 管理員將會調用 Web Bean 的所有 initializer method。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Finally, the <literal>@PostConstruct</literal> method, if any, is called."
msgstr "最後，（若存在的話）Web Bean 的 <literal>@PostConstruct</literal> method 將會被調用。"

#. Tag: para
#, no-c-format
msgid "(The only complication is that the container might call initializer methods declared by a superclass before initializing injected fields declared by a subclass.)"
msgstr ""

#. Tag: para
#, no-c-format
msgid "One major advantage of constructor injection is that it allows the bean to be immutable."
msgstr ""

#. Tag: para
#, no-c-format
msgid "CDI also supports parameter injection for some other methods that are invoked by the container. For instance, parameter injection is supported for producer methods:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}"
msgstr ""
"<![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "This is a case where the <literal>@Inject</literal> annotation <emphasis>is not</emphasis> required at the injection point. The same is true for observer methods (which we'll meet in <xref linkend=\"events\" />) and disposer methods."
msgstr ""

#. Tag: title
#, no-c-format
msgid "What gets injected"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "The CDI specification defines a procedure, called <emphasis>typesafe resolution</emphasis>, that the container follows when identifying the bean to inject to an injection point. This algorithm looks complex at first, but once you understand it, it's really quite intuitive. Typesafe resolution is performed at system initialization time, which means that the container will inform the developer immediately if a bean's dependencies cannot be satisfied."
msgstr "Web Bean 規格定義了一個流程，該流程稱為 <emphasis>typesafe resolution algorithm</emphasis>（typesafe 解析演算法），當 Web Bean 要注入至一個注入點時，Web Bean 管理員便會遵照該流程來進行。這個演算法乍看之下非常地複雜，不過當您理解它之後，您會發現它實際上並不複雜。Typesafe 解析會在系統初始化時進行，這也代表了若 Web Bean 的相依性無法被滿足的話，管理員會即刻透過回傳一個 <literal>UnsatisfiedDependencyException</literal> 或是 <literal>AmbiguousDependencyException</literal> 來通知用戶。"

#. Tag: para
#, fuzzy, no-c-format
msgid "The purpose of this algorithm is to allow multiple beans to implement the same bean type and either:"
msgstr "這個演算法就是為了要讓多重 Web Bean 實做相同的 API 類型以及："

#. Tag: para
#, fuzzy, no-c-format
msgid "allow the client to select which implementation it requires using a <emphasis>qualifier</emphasis> or"
msgstr "讓客戶端藉由使用 <emphasis>binding annotations</emphasis> 來選擇需要的實做、"

#. Tag: para
#, fuzzy, no-c-format
msgid "allow the application deployer to select which implementation is appropriate for a particular deployment, without changes to the client, by enabling or disabling an <emphasis>alternative</emphasis>, or"
msgstr "讓應用程式建置人員在不改變客戶端的情況下藉由啟用或停用 <emphasis>deployment types</emphasis> 來選擇用於特定建置的適當實做，或是"

#. Tag: para
#, no-c-format
msgid "allow the beans to be isolated into separate modules."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Obviously, if you have exactly one bean of a given type, and an injection point with that same type, then bean A is going to go into slot A. That's the simplest possible scenario. When you first start your application, you'll likely have lots of those."
msgstr ""

#. Tag: para
#, no-c-format
msgid "But then, things start to get complicated. Let's explore how the container determines which bean to inject in more advanced cases. We'll start by taking a closer look at qualifiers."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Qualifier annotations"
msgstr "綁定標記"

#. Tag: para
#, fuzzy, no-c-format
msgid "If we have more than one bean that implements a particular bean type, the injection point can specify exactly which bean should be injected using a qualifier annotation. For example, there might be two implementations of <literal>PaymentProcessor</literal>:"
msgstr "若我們擁有超過一個實做特定 API 類型的 Web Bean，注入點可藉由使用綁定標記來確切地指定哪個 Web Bean 應該被注入。比方說，<literal>PaymentProcessor</literal> 的實做可能有兩個："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Synchronous\n"
"public class SynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Asynchronous\n"
"public class AsynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>@Synchronous</literal> and <literal>@Asynchronous</literal> are qualifier annotations:"
msgstr "<literal>@PayByCheque</literal> 和 <literal>@PayByCreditCard</literal> 為綁定標記："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Synchronous {}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Asynchronous {}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "A client bean developer uses the qualifier annotation to specify exactly which bean should be injected."
msgstr "客戶端 Web Bean 開發人員會使用綁定標記來確切指定哪個 Web Bean 應被注入。"

#. Tag: para
#, no-c-format
msgid "Using field injection:"
msgstr "使用 field injection："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject @Synchronous PaymentProcessor syncPaymentProcessor;\n"
"@Inject @Asynchronous PaymentProcessor asyncPaymentProcessor;"
msgstr ""
"<![CDATA[@PayByCheque PaymentProcessor chequePaymentProcessor;\n"
"@PayByCreditCard PaymentProcessor creditCardPaymentProcessor;]]>"

#. Tag: para
#, no-c-format
msgid "Using initializer method injection:"
msgstr "使用 initializer method injection："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject\n"
"public void setPaymentProcessors(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                                 @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Using constructor injection:"
msgstr "或使用 constructor injection："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject\n"
"public Checkout(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public Checkout(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Qualifier annotations can also qualify method arguments of producer, disposer and observer methods. Combining qualified arguments with producer methods is a good way to have an implementation of a bean type selected at runtime based on the state of the system:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Produces\n"
"PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor syncPaymentProcessor,\n"
"                                     @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   return isSynchronous() ? syncPaymentProcessor : asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "If an injected field or a parameter of a bean constructor or initializer method is not explicitly annotated with a qualifier, the default qualifier, <literal>@Default</literal>, is assumed."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now, you may be thinking, <emphasis>\"What's the different between using a qualifier and just specifying the exact implementation class you want?\"</emphasis> It's important to understand that a qualifier is like an extension of the interface. It does not create a direct dependency to any particular implementation. There may be multiple alternative implementations of <literal>@Asynchronous PaymentProcessor</literal>!"
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "The built-in qualifiers <literal>@Default</literal> and <literal>@Any</literal>"
msgstr "基本的 Web Bean 只支援 <literal>@PostConstruct</literal> 和 <literal>@PreDestroy</literal> callback。"

#. Tag: para
#, no-c-format
msgid "Whenever a bean or injection point does not explicitly declare a qualifier, the container assumes the qualifier <literal>@Default</literal>. From time to time, you'll need to declare an injection point without specifying a qualifier. There's a qualifier for that too. All beans have the qualifier <literal>@Any</literal>. Therefore, by explicitly specifying <literal>@Any</literal> at an injection point, you suppress the default qualifier, without otherwise restricting the beans that are eligible for injection."
msgstr ""

#. Tag: para
#, no-c-format
msgid "This is especially useful if you want to iterate over all beans with a certain bean type. For example:"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject \n"
"void initServices(@Any Instance&lt;Service&gt; services) { \n"
"   for (Service service: services) {\n"
"      service.init();\n"
"   }\n"
"}"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Qualifiers with members"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Java annotations can have members. We can use annotation members to further discriminate a qualifier. This prevents a potential explosion of new annotations. For example, instead of creating several qualifiers representing different payment methods, we could aggregate them into a single annotation with a member:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayBy {\n"
"    PaymentType value();\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Then we select one of the possible member values when applying the qualifier:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "private @Inject @PayBy(CHECK) PaymentProcessor checkPayment;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "We can force the container to ignore a member of a qualifier type by annotating the member <literal>@Nonbinding</literal>."
msgstr "您可藉由標記 <literal>@NonBinding</literal> 這個 member 來讓 Web Bean 管理員忽略某個綁定標記類型的成員。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"   @Nonbinding String comment() default \"\";\n"
"}"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: title
#, no-c-format
msgid "Multiple qualifiers"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "An injection point may specify multiple qualifiers:"
msgstr "一個注入點甚至有可能會指定多重綁定標記："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Synchronous @Reliable PaymentProcessor syncPaymentProcessor;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Then only a bean which has <emphasis>both</emphasis> qualifier annotations would be eligible for injection."
msgstr "在這種情況下，只有擁有這<emphasis>兩個</emphasis>綁定標記的 Web Bean 可被注入。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Synchronous @Reliable\n"
"public class SynchronousReliablePaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: title
#, no-c-format
msgid "Alternatives"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Alternatives are beans whose implementation is specific to a particular client module or deployment scenario. This alternative defines a mock implementation of both <literal>@Synchronous PaymentProcessor</literal> and <literal>@Asynchronous PaymentProcessor</literal>, all in one:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Alternative @Synchronous @Asynchronous\n"
"public class MockPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "By default, <literal>@Alternative</literal> beans are disabled. We need to <emphasis>enable</emphasis> an alternative in the <literal>beans.xml</literal> descriptor of a bean archive to make it available for instantiation and injection. This activation only applies to the beans in that archive."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"&lt;beans\n"
"   xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"   xsi:schemaLocation=\"\n"
"      http://java.sun.com/xml/ns/javaee\n"
"      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd\"&gt;\n"
"   &lt;alternatives&gt;\n"
"         &lt;class&gt;org.mycompany.mock.MockPaymentProcessor&lt;/class&gt;\n"
"   &lt;/alternatives&gt;\n"
"&lt;/beans&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "When an ambiguous dependency exists at an injection point, the container attempts to resolve the ambiguity by looking for an enabled alternative among the beans that could be injected. If there is exactly one enabled alternative, that's the bean that will be injected."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Fixing unsatisfied and ambiguous dependencies"
msgstr "修正相依性不足（unsatisfied dependencies）的問題"

#. Tag: para
#, fuzzy, no-c-format
msgid "The typesafe resolution algorithm fails when, after considering the qualifier annotations on all beans that implement the bean type of an injection point and filtering out disabled beans (<literal>@Alternative</literal> beans which are not explicitly enabled), the container is unable to identify exactly one bean to inject. The container will abort deployment, informing us of the unsatisfied or ambiguous dependency."
msgstr "就所有實做某個注入點的 API 類型的 Web Bean 綁定標記和 deployment type 來講，若 Web Bean 管理員無法辨識出正好一個需被注入的 Web Bean 為何，那麼 typesafe 解析演算法便會失敗。"

#. Tag: para
#, no-c-format
msgid "During the course of your development, you're going to encounter this situation. Let's learn how to resolve it."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To fix an <emphasis>unsatisfied dependency</emphasis>, either:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "create a bean which implements the bean type and has all the qualifier types of the injection point,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "make sure that the bean you already have is in the classpath of the module with the injection point, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "explicitly enable an <literal>@Alternative</literal> bean that implements the bean type and has the appropriate qualifier types, using <literal>beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To fix an <emphasis>ambiguous dependency</emphasis>, either:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "introduce a qualifier to distinguish between the two implementations of the bean type,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "disable one of the beans by annotating it <literal>@Alternative</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "move one of the implementations to a module that is not in the classpath of the module with the injection point, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "disable one of two <literal>@Alternative</literal> beans that are trying to occupy the same space, using <literal>beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "See <ulink url=\"http://sfwk.org/Documentation/HowDoAResolveAnAmbiguousResolutionExceptionBetweenAProducerMethodAndARawType\">this FAQ</ulink> for step-by-step instructions for how to resolve an ambiguous resolution exception between a raw bean type and a producer method that returns the same bean type."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Just remember: \"There can be only one.\""
msgstr ""

#. Tag: para
#, no-c-format
msgid "On the other hand, if you really do have an optional or multivalued injection point, you should change the type of your injection point to <literal>Instance</literal>, as we'll see in <xref linkend=\"lookup\" />."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Now there's one more issue you need to be aware of when using the dependency injection service."
msgstr "當您在 Web Bean 中使用依賴注入時，您還需要注意一個問題。"

#. Tag: title
#, no-c-format
msgid "Client proxies"
msgstr "客戶端代理伺服器（Client proxies）"

#. Tag: para
#, fuzzy, no-c-format
msgid "Clients of an injected bean do not usually hold a direct reference to a bean instance, unless the bean is a dependent object (scope <literal>@Dependent</literal>)."
msgstr "一個已注入的 Web Bean 的客戶端通常不會持有一個 Web Bean instance 的直接參照。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Imagine that a bean bound to the application scope held a direct reference to a bean bound to the request scope. The application-scoped bean is shared between many different requests. However, each request should see a different instance of the request scoped bean&mdash;the current one!"
msgstr "想像一個綁定至應用程式 scope 的 Web Bean 持有一個綁定至請求 scope 的 Web Bean 的直接參照。這個應用程式 scope 的 Web Bean 會在許多不同的請求之間被共享。不過，各個請求都應要看見一個不同的請求 scope Web Bean 的 instance！"

#. Tag: para
#, fuzzy, no-c-format
msgid "Now imagine that a bean bound to the session scope holds a direct reference to a bean bound to the application scope. From time to time, the session context is serialized to disk in order to use memory more efficiently. However, the application scoped bean instance should not be serialized along with the session scoped bean! It can get that reference any time. No need to hoard it!"
msgstr "現在，請想像一個綁定至 session scope 的 Web Bean 持有一個綁定至應用程式 scope 的 Web Bean 的直接參照。有時，session context 會被序列化至磁碟中以便更有效率地使用記憶體。不過，應用程式 scope 的 Web Bean instance 不該和 session scope 的 Web Bean 一起被序列化！"

#. Tag: para
#, fuzzy, no-c-format
msgid "Therefore, unless a bean has the default scope <literal>@Dependent</literal>, the container must indirect all injected references to the bean through a proxy object. This <emphasis>client proxy</emphasis> is responsible for ensuring that the bean instance that receives a method invocation is the instance that is associated with the current context. The client proxy also allows beans bound to contexts such as the session context to be serialized to disk without recursively serializing other injected beans."
msgstr "因此，除非有個 Web Bean 擁有預設的 <literal>@Dependent</literal> scope，否則 Web Bean 管理員便必須透過一個 proxy 物件來將所有注入的參照重新指向 Web Bean。這個 <emphasis>client proxy</emphasis> 負責確保收到 method 調用的 Web Bean instance 是個和目前 context 相聯的 instance。客戶端 proxy 亦可允許在不遞迴地序列化其它已注入的 Web Bean 的情況下也能讓綁定至 context（例如 session context）的 Web Bean 被序列化至磁碟。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Unfortunately, due to limitations of the Java language, some Java types cannot be proxied by the container. If an injection point declared with one of these types resolves to a bean with any scope other than <literal>@Dependent</literal>, the container will abort deployment, informing us of the problem."
msgstr "不巧的是，礙於 Java 語言的限制，有些 Java 類型無法被 Web Bean 管理員代理（proxied）。因此，若某個注入點的 type 無法被代理的話，Web Bean 管理員便會回傳一個 <literal>UnproxyableDependencyException</literal>。"

#. Tag: para
#, fuzzy, no-c-format
msgid "The following Java types cannot be proxied by the container:"
msgstr "下列 Java 類型無法被 Web Bean 管理員代理："

#. Tag: para
#, fuzzy, no-c-format
msgid "classes which don't have a non-private constructor with no parameters, and"
msgstr "沒有非私密 constructor 的無參數 class，以及"

#. Tag: para
#, no-c-format
msgid "classes which are declared <literal>final</literal> or have a <literal>final</literal> method,"
msgstr "所有被宣告 <literal>final</literal> 或是含有一個 <literal>final</literal> method 的 class、"

#. Tag: para
#, no-c-format
msgid "arrays and primitive types."
msgstr "陣列（array）與基本型別（primitive type）。"

#. Tag: para
#, no-c-format
msgid "It's usually very easy to fix an unproxyable dependency problem. If an injection point of type <literal>X</literal> results in an unproxyable dependency, simply:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "add a constructor with no parameters to <literal>X</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "change the type of the injection point to <literal>Instance&lt;X&gt;</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "introduce an interface <literal>Y</literal>, implemented by the injected bean, and change the type of the injection point to <literal>Y</literal>, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "if all else fails, change the scope of the injected bean to <literal>@Dependent</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "A future release of Weld will likely support a non-standard workaround for this limitation, using non-portable JVM APIs:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Sun, IcedTea, Mac: <literal>Unsafe.allocateInstance()</literal> (The most efficient)"
msgstr ""

#. Tag: para
#, no-c-format
msgid "IBM, JRockit: <literal>ReflectionFactory.newConstructorForSerialization()</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "But we didn't get around to implementing this yet."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Obtaining a contextual instance by programmatic lookup"
msgstr "透過程式性的搜尋來取得一個 Web Bean"

#. Tag: para
#, no-c-format
msgid "In certain situations, injection is not the most convenient way to obtain a contextual reference. For example, it may not be used when:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "the bean type or qualifiers vary dynamically at runtime, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "depending upon the deployment, there may be no bean which satisfies the type and qualifiers, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "we would like to iterate over all beans of a certain type."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "In these situations, the application may obtain an instance of the interface <literal>Instance</literal>, parameterized for the bean type, by injection:"
msgstr "應用程式可透過注入來取得 <literal>Manager</literal> 這個介面的一個 instance："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject Instance&lt;PaymentProcessor&gt; paymentProcessorSource;"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "The <literal>get()</literal> method of <literal>Instance</literal> produces a contextual instance of the bean."
msgstr "用來測試的 <literal>@Mock</literal> 和 <literal>@Staging</literal> deployment type"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "PaymentProcessor p = paymentProcessorSource.get();"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Qualifiers can be specified in one of two ways:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "by annotating the <literal>Instance</literal> injection point, or"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "by passing qualifiers to the <literal>select()</literal> of <literal>Event</literal>."
msgstr "基本的 Web Bean 只支援 <literal>@PostConstruct</literal> 和 <literal>@PreDestroy</literal> callback。"

#. Tag: para
#, no-c-format
msgid "Specifying the qualifiers at the injection point is much, much easier:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Asynchronous Instance&lt;PaymentProcessor&gt; paymentProcessorSource;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Now, the <literal>PaymentProcessor</literal> returned by <literal>get()</literal> will have the qualifier <literal>@Asynchronous</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Alternatively, we can specify the qualifier dynamically. First, we add the <literal>@Any</literal> qualifier to the injection point, to suppress the default qualifier. (All beans have the qualifier <literal>@Any</literal>.)"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Any Instance&lt;PaymentProcessor&gt; paymentProcessorSource;"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Next, we need to obtain an instance of our qualifier type. Since annotations are interfaces, we can't just write <literal>new Asynchronous()</literal>. It's also quite tedious to create a concrete implementation of an annotation type from scratch. Instead, CDI lets us obtain a qualifier instance by subclassing the helper class <literal>AnnotationLiteral</literal>."
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"abstract class AsynchronousQualifier\n"
"extends AnnotationLiteral&lt;Asynchronous&gt; implements Asynchronous {}"
msgstr ""
"<![CDATA[abstract class CreditCardBinding \n"
"    extends AnnotationLiteral<CreditCard> \n"
"    implements CreditCard {}]]>"

#. Tag: para
#, no-c-format
msgid "In some cases, we can use an anonymous class:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"PaymentProcessor p = paymentProcessorSource\n"
"   .select(new AnnotationLiteral&lt;Asynchronous&gt;() {});"
msgstr ""
"<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
"                                               new AnnotationLiteral<CreditCard>(){});]]>"

#. Tag: para
#, no-c-format
msgid "However, we can't use an anonymous class to implement a qualifier type with members."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now, finally, we can pass the qualifier to the <literal>select()</literal> method of <literal>Instance</literal>."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"Annotation qualifier = synchronously ?\n"
"      new SynchronousQualifier() : new AsynchronousQualifier();\n"
"PaymentProcessor p = anyPaymentProcessor.select(qualifier).get().process(payment);"
msgstr ""

#. Tag: title
#, no-c-format
msgid "The <literal>InjectionPoint</literal> object"
msgstr "<literal>InjectionPoint</literal> 物件"

#. Tag: para
#, fuzzy, no-c-format
msgid "There are certain kinds of dependent objects (beans with scope <literal>@Dependent</literal>) that need to know something about the object or injection point into which they are injected in order to be able to do what they do. For example:"
msgstr "有幾種特定相依物件 &#151; 含有 <literal>@Dependent</literal> 這個 scope 的 Web Bean &#151; 需要知道有關於物件或是它們被注入的注入點相關資訊才能進行它們本應進行的工作。比方說："

#. Tag: para
#, no-c-format
msgid "The log category for a <literal>Logger</literal> depends upon the class of the object that owns it."
msgstr "<literal>Logger</literal> 的 log category 取決於擁有它的物件的 class。"

#. Tag: para
#, no-c-format
msgid "Injection of a HTTP parameter or header value depends upon what parameter or header name was specified at the injection point."
msgstr "HTTP 參數或是 header value 的注入取決於在注入點所指定的參數或標頭名稱。"

#. Tag: para
#, no-c-format
msgid "Injection of the result of an EL expression evaluation depends upon the expression that was specified at the injection point."
msgstr "EL 運算式評估（expression evaluation）結果的注入取決於在注入點所指定的運算式。"

#. Tag: para
#, fuzzy, no-c-format
msgid "A bean with scope <literal>@Dependent</literal> may inject an instance of <literal>InjectionPoint</literal> and access metadata relating to the injection point to which it belongs."
msgstr "含有 <literal>@Dependent</literal> 這個 scope 的 Web Bean 能夠注入一個 <literal>InjectionPoint</literal> instance 並存取和它所屬的注入點相關的 metadata。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Let's look at an example. The following code is verbose, and vulnerable to refactoring problems:"
msgstr "讓我們來探討下列範例。下列程式碼較為冗長，並且有重構（refactoring）問題上的弱點："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "Logger log = Logger.getLogger(MyClass.class.getName());"
msgstr "<![CDATA[Logger log = Logger.getLogger(MyClass.class.getName());]]>"

#. Tag: para
#, no-c-format
msgid "This clever little producer method lets you inject a JDK <literal>Logger</literal> without explicitly specifying the log category:"
msgstr "這個 producer method 能讓您在不明確指定 log category 的情況下注入一個 JDK <literal>Logger</literal>："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "We can now write:"
msgstr "現在我們可寫入："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject Logger log;"
msgstr "<![CDATA[@Current Logger log;]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Not convinced? Then here's a second example. To inject HTTP parameters, we need to define a qualifier type:"
msgstr "若您無法被說服的話，我們還有第二個範例。若要注入 HTTP 參數，我們需要定義一個綁定類型："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @Nonbinding public String value();\n"
"}"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "We would use this qualifier type at injection points as follows:"
msgstr "我們可如下在注入點使用此綁定類型："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;"
msgstr ""
"<![CDATA[@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;]]>"

#. Tag: para
#, no-c-format
msgid "The following producer method does the work:"
msgstr "下列 producer method 可完成此工作："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(InjectionPoint ip) {\n"
"      ServletRequest request = (ServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest();\n"
"      return request.getParameter(ip.getAnnotated().getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(ServletRequest request, InjectionPoint ip) {\n"
"      return request.getParameter(ip.getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Note that acquiring of the request in this example is JSF-centric. For a more generic solution you could write your own producer for the request and have it injected as a method parameter."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Note also that the <literal>value()</literal> member of the <literal>HttpParam</literal> annotation is ignored by the container since it is annotated <literal>@Nonbinding.</literal>"
msgstr "（請注意，<literal>HttpParam</literal> 標記的 <literal>value()</literal> 成員已被 Web Bean 管理員忽略掉，因為它已被標記為 <literal>@NonBinding.</literal>）"

#. Tag: para
#, fuzzy, no-c-format
msgid "The container provides a built-in bean that implements the <literal>InjectionPoint</literal> interface:"
msgstr "Web Bean 管理員提供了實做 <literal>InjectionPoint</literal> 介面的內建 Web Bean："

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public interface InjectionPoint { \n"
"   public Type getType();\n"
"   public Set&lt;Annotation&gt; getQualifiers();\n"
"   public Bean&lt;?&gt; getBean();\n"
"   public Member getMember();\n"
"   public Annotated getAnnotated();\n"
"   public boolean isDelegate();\n"
"   public boolean isTransient();\n"
"}"
msgstr ""
"<![CDATA[public interface InjectionPoint { \n"
"   public Object getInstance(); \n"
"   public Bean<?> getBean(); \n"
"   public Member getMember(): \n"
"   public <T extends Annotation> T getAnnotation(Class<T> annotation); \n"
"   public Set<T extends Annotation> getAnnotations(); \n"
"}]]>"

#, fuzzy
#~ msgid "It's usually very easy to fix an unproxyable dependency problem. Simply add a constructor with no parameters to the injected class, introduce an interface, or, if all else fails, change the scope of the injected bean to <literal>@Dependent</literal>."
#~ msgstr "要修正 <literal>UnproxyableDependencyException</literal> 通常相當容易。只要將一個無參數的 constructor 附加至注入的 class、採用一個介面，或將已注入的 Web Bean 的 scope 更改為 <literal>@Dependent</literal> 即可。"

#~ msgid "Web Beans supports three primary mechanisms for dependency injection:"
#~ msgstr "Web Bean 支援了三個主要的依賴注入機制："

#~ msgid "Constructor parameter injection:"
#~ msgstr "Constructor parameter injection："

#~ msgid "Constructor parameter injection is not supported for EJB beans, since the EJB is instantiated by the EJB container, not the Web Bean manager."
#~ msgstr "EJB Bean 不支援 Constructor parameter injection，因為 EJB 是由 EJB container 來例示（instantiate）的，而不是以 Web Bean 管理員。"

#~ msgid "Parameters of constructors and initializer methods need not be explicitly annotated when the default binding type <literal>@Current</literal> applies. Injected fields, however, <emphasis>must</emphasis> specify a binding type, even when the default binding type applies. If the field does not specify a binding type, it will not be injected."
#~ msgstr "當套用了預設的 <literal>@Current</literal> 綁定類型時，Constructor 和 initializer method 的參數不需要被明確地標記。不過，儘管套用了預設的綁定類型，被注入的欄位還是<emphasis>一定</emphasis>要指定綁定類型。若該欄位不指定綁定類型的話，它將不會被注入。"

#~ msgid "Producer methods also support parameter injection:"
#~ msgstr "Producer method 也支援 parameter injection："

#~ msgid "Finally, observer methods (which we'll meet in <xref linkend=\"events\"/>), disposal methods and destructor methods all support parameter injection."
#~ msgstr "最後，observer method（我們會在 <xref linkend=\"events\"/> 中談到）、disposal method 以及 destructor method 全都支援 parameter injection。"

#~ msgid "allow one implementation of an API to override another implementation of the same API at deployment time, without changes to the client, using <emphasis>deployment type precedence</emphasis>."
#~ msgstr "允許建置時透過使用 <emphasis>deployment type precedence</emphasis> 來讓某個 API 的一個實做能在不改變客戶端的情況下置換另一個相同 API 的實做。"

#~ msgid "Let's explore how the Web Beans manager determines a Web Bean to be injected."
#~ msgstr "讓我們來探討 Web Bean 管理員如何判斷某個 Web Bean 要如何被注入。"

#~ msgid ""
#~ "<![CDATA[@PayByCreditCard\n"
#~ "public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
#~ "    public void process(Payment payment) { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@PayByCreditCard\n"
#~ "public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
#~ "    public void process(Payment payment) { ... }\n"
#~ "}]]>"

#~ msgid ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
#~ "@BindingType\n"
#~ "public @interface PayByCreditCard {}]]>"
#~ msgstr ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
#~ "@BindingType\n"
#~ "public @interface PayByCreditCard {}]]>"

#~ msgid "Binding annotations with members"
#~ msgstr "member 和綁定標記"

#~ msgid "Binding annotations may have members:"
#~ msgstr "綁定標記能夠有 member："

#~ msgid "In which case, the member value is significant:"
#~ msgstr "在此情況下，member value 非常重要："

#~ msgid ""
#~ "<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
#~ "@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"
#~ msgstr ""
#~ "<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
#~ "@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"

#~ msgid "Combinations of binding annnotations"
#~ msgstr "綁定標記的組合"

#~ msgid "Binding annotations and producer methods"
#~ msgstr "綁定標記和 producer method"

#~ msgid "Even producer methods may specify binding annotations:"
#~ msgstr "就連 producer method 也能指定綁定標記："

#~ msgid ""
#~ "<![CDATA[@Produces \n"
#~ "@Asynchronous @PayByCheque \n"
#~ "PaymentProcessor createAsyncPaymentProcessor(@PayByCheque PaymentProcessor processor) {\n"
#~ "    return new AsynchronousPaymentProcessor(processor);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces \n"
#~ "@Asynchronous @PayByCheque \n"
#~ "PaymentProcessor createAsyncPaymentProcessor(@PayByCheque PaymentProcessor processor) {\n"
#~ "    return new AsynchronousPaymentProcessor(processor);\n"
#~ "}]]>"

#~ msgid "The default binding type"
#~ msgstr "預設綁定類型"

#~ msgid "Web Beans defines a binding type <literal>@Current</literal> that is the default binding type for any injection point or Web Bean that does not explicitly specify a binding type."
#~ msgstr "Web Bean 定義了一個綁定類型 <literal>@Current</literal>，這是個任何未明確指定綁定類型的注入點或 Web Bean 的預設綁定類型。"

#~ msgid "There are two common circumstances in which it is necessary to explicitly specify <literal>@Current</literal>:"
#~ msgstr "一般來講，在兩個情況下會需要明確地指定 <literal>@Current</literal>："

#~ msgid "on a field, in order to declare it as an injected field with the default binding type, and"
#~ msgstr "在一個 field 上，為了要將該 field 宣告為含有預設綁定類型的已注入欄位，以及"

#~ msgid "on a Web Bean which has another binding type in addition to the default binding type."
#~ msgstr "在一個除了預設綁定類型之外還另擁有一個綁定類型的 Web Bean 上。"

#~ msgid "Deployment types"
#~ msgstr "建置類型"

#~ msgid "All Web Beans have a <emphasis>deployment type</emphasis>. Each deployment type identifies a set of Web Beans that should be conditionally installed in some deployments of the system."
#~ msgstr "所有 Web Bean 都有一個 <emphasis>deployment type（建置類型）</emphasis>。各個 deployment type 都可標識一組應依照條件性地被安裝在系統的某些 deployment 中的 Web Bean。"

#~ msgid "For example, we could define a deployment type named <literal>@Mock</literal>, which would identify Web Beans that should only be installed when the system executes inside an integration testing environment:"
#~ msgstr "比方說，我們可定義一個名為 <literal>@Mock</literal> 的 deployment type，它會找出只應在系統執行於一個整合測試環境中的時候才會被安裝的 Web Bean："

#~ msgid ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "  @Target({TYPE, METHOD})\n"
#~ "  @DeploymentType\n"
#~ "  public @interface Mock {}]]>"
#~ msgstr ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "  @Target({TYPE, METHOD})\n"
#~ "  @DeploymentType\n"
#~ "  public @interface Mock {}]]>"

#~ msgid "Suppose we had some Web Bean that interacted with an external system to process payments:"
#~ msgstr "假設我們有一些和外部系統進行互動以便處理款項的 Web Bean："

#~ msgid ""
#~ "<![CDATA[public class ExternalPaymentProcessor {\n"
#~ "        \n"
#~ "    public void process(Payment p) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public class ExternalPaymentProcessor {\n"
#~ "        \n"
#~ "    public void process(Payment p) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"

#~ msgid "Since this Web Bean does not explicitly specify a deployment type, it has the default deployment type <literal>@Production</literal>."
#~ msgstr "因為這個 Web Bean 並未明確地指定一個 deployment type，因此它的 deployment type 會是預設的 <literal>@Production</literal>。"

#~ msgid "For integration or unit testing, the external system is slow or unavailable. So we would create a mock object:"
#~ msgstr "假設要進行整合或是單元測試（unit testing），不過外部系統較慢或是無法使用。因此我們將建立一個 mock 物件："

#~ msgid ""
#~ "<![CDATA[@Mock \n"
#~ "public class MockPaymentProcessor implements PaymentProcessor {\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void process(Payment p) {\n"
#~ "        p.setSuccessful(true);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock \n"
#~ "public class MockPaymentProcessor implements PaymentProcessor {\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void process(Payment p) {\n"
#~ "        p.setSuccessful(true);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid "But how does the Web Bean manager determine which implementation to use in a particular deployment?"
#~ msgstr "不過 Web Bean 管理員要如何判斷在特定建置中該使用哪個實做？"

#~ msgid "Enabling deployment types"
#~ msgstr "啟用 deployment type"

#~ msgid "Web Beans defines two built-in deployment types: <literal>@Production</literal> and <literal>@Standard</literal>. By default, only Web Beans with the built-in deployment types are enabled when the system is deployed. We can identify additional deployment types to be enabled in a particular deployment by listing them in <literal>web-beans.xml</literal>."
#~ msgstr "Web Bean 定義了兩個內建的 deployment type：<literal>@Production</literal> 和 <literal>@Standard</literal>。就預設值，當系統被建置時，只有含有內建 deployment type 的 Web Bean 會被啟用。我們可藉由將特定 deployment type 列在 <literal>web-beans.xml</literal> 中來識別在特定 deployment 中可啟用的額外 deployment type。"

#~ msgid "Going back to our example, when we deploy our integration tests, we want all our <literal>@Mock</literal> objects to be installed:"
#~ msgstr "回到我們的範例，當我們建置我們的整合測試時，我們希望我們所有的 <literal>@Mock</literal> 物件都會被安裝："

#~ msgid ""
#~ "<![CDATA[<WebBeans>\n"
#~ "    <Deploy>\n"
#~ "        <Standard/>\n"
#~ "        <Production/>\n"
#~ "        <test:Mock/>\n"
#~ "    </Deploy>\n"
#~ "</WebBeans>]]>"
#~ msgstr ""
#~ "<![CDATA[<WebBeans>\n"
#~ "    <Deploy>\n"
#~ "        <Standard/>\n"
#~ "        <Production/>\n"
#~ "        <test:Mock/>\n"
#~ "    </Deploy>\n"
#~ "</WebBeans>]]>"

#~ msgid "Now the Web Bean manager will identify and install all Web Beans annotated <literal>@Production</literal>, <literal>@Standard</literal> or <literal>@Mock</literal> at deployment time."
#~ msgstr "現在，Web Bean 管理員將會在 deployment time 找出並安裝所有標記為 <literal>@Production</literal>、<literal>@Standard</literal> 或 <literal>@Mock</literal> 的 Web Bean。"

#~ msgid "The deployment type <literal>@Standard</literal> is used only for certain special Web Beans defined by the Web Beans specification. We can't use it for our own Web Beans, and we can't disable it."
#~ msgstr "<literal>@Standard</literal> 這個 deployment type 只會被用於 Web Bean 規格所定義的特定特殊 Web Bean。我們無法將它使用於我們自己的 Web Bean 上，並且我們無法將它停用。"

#~ msgid "The deployment type <literal>@Production</literal> is the default deployment type for Web Beans which don't explicitly declare a deployment type, and may be disabled."
#~ msgstr "<literal>@Production</literal> 這個 deployment type 屬於未明確定義 deployment type 的 Web Bean 的預設 deployment type，並且可被停用。"

#~ msgid "Deployment type precedence"
#~ msgstr "Deployment type 優先權"

#~ msgid "If you've been paying attention, you're probably wondering how the Web Bean manager decides which implementation &#151; <literal>ExternalPaymentProcessor</literal> or <literal>MockPaymentProcessor</literal> &#151; to choose. Consider what happens when the manager encounters this injection point:"
#~ msgstr "若您有在細心注意的話，您應該會疑惑 Web Bean 管理員如何決定哪個實做 &#151; <literal>ExternalPaymentProcessor</literal> 和 <literal>MockPaymentProcessor</literal> &#151; 中選擇哪一個。請思考當管理員遇上了這個注入點時會如何："

#~ msgid "There are now two Web Beans which satisfy the <literal>PaymentProcessor</literal> contract. Of course, we can't use a binding annotation to disambiguate, since binding annotations are hard-coded into the source at the injection point, and we want the manager to be able to decide at deployment time!"
#~ msgstr "有兩個 Web Bean 可滿足 <literal>PaymentProcessor</literal> 合同。當然，我們無法使用綁定標記來消除語意上的含糊意義，因為綁定標記已寫死（hard-coded）在注入點的來源之中，而且我們希望管理員能夠在 deployment time 時作決定！"

#~ msgid "The solution to this problem is that each deployment type has a different <emphasis>precedence</emphasis>. The precedence of the deployment types is determined by the order in which they appear in <literal>web-beans.xml</literal>. In our example, <literal>@Mock</literal> appears later than <literal>@Production</literal> so it has a higher precedence."
#~ msgstr "這項問題的解決方式就是利用各個 deployment type 的不同<emphasis>優先權</emphasis>。Deployment type 的優先權是透過它們出現在 <literal>web-beans.xml</literal> 中的順序來決定的。在我們的範例中，<literal>@Mock</literal> 出現的順序在 <literal>@Production</literal> 之後，因此它會有較高的優先權。"

#~ msgid "Whenever the manager discovers that more than one Web Bean could satisfy the contract (API type plus binding annotations) specified by an injection point, it considers the relative precedence of the Web Beans. If one has a higher precedence than the others, it chooses the higher precedence Web Bean to inject. So, in our example, the Web Bean manager will inject <literal>MockPaymentProcessor</literal> when executing in our integration testing environment (which is exactly what we want)."
#~ msgstr "每當管理員發現了多於一個 Web Bean 可滿足由某個注入點所指定的合同（API 類型加上綁定標記）時，它會考量到 Web Bean 的相關優先權。若有一方的優先權較高，它便會選擇優先權較高的那個 Web Bean 來注入。因此，在我們的範例中，當 Web Bean 管理員執行於我們的整合測試環境中的時候（這正是我們想要的），它將會注入 <literal>MockPaymentProcessor</literal>。"

#~ msgid "It's interesting to compare this facility to today's popular manager architectures. Various \"lightweight\" containers also allow conditional deployment of classes that exist in the classpath, but the classes that are to be deployed must be explicity, individually, listed in configuration code or in some XML configuration file. Web Beans does support Web Bean definition and configuration via XML, but in the common case where no complex configuration is required, deployment types allow a whole set of Web Beans to be enabled with a single line of XML. Meanwhile, a developer browsing the code can easily identify what deployment scenarios the Web Bean will be used in."
#~ msgstr "和現今多人使用的管理員架構相較之下，這個功能相當地有趣。各種「lightweight」的 container 都允許存在 classpath 中的 class 的條件性建置，不過要被建置的 class 必須要明確、各別地列在配置程式碼或是一些 XML 配置檔案中。Web Bean 不支援透過 XML 的 Web Bean 定義與配置，不過在一般情況下當不需要複雜的配置時，deployment type 允許一整組 Web Bean 能夠透過 XML 中的一個單獨行列來被啟用。其間，瀏覽程式碼的開發人員能夠輕易地分辨出 Web Bean 將會使用哪種建置方案（deployment scenario）。"

#~ msgid "Example deployment types"
#~ msgstr "範例 deployment type"

#~ msgid "Deployment types are useful for all kinds of things, here's some examples:"
#~ msgstr "Deployment type 針對於許多情況都相當便於使用，以下為一些範例："

#~ msgid "<literal>@AustralianTaxLaw</literal> for site-specific Web Beans"
#~ msgstr "<literal>@AustralianTaxLaw</literal> 可用於網站特屬的 Web Bean"

#~ msgid "<literal>@SeamFramework</literal>, <literal>@Guice</literal> for third-party frameworks which build on Web Beans"
#~ msgstr "<literal>@SeamFramework</literal>、<literal>@Guice</literal> 可用於建立在 Web Bean 上的第三方 framework"

#~ msgid "<literal>@Standard</literal> for standard Web Beans defined by the Web Beans specification"
#~ msgstr "<literal>@Standard</literal> 可用於以 Web Bean 規格所定義的標準 Web Bean"

#~ msgid "I'm sure you can think of more applications..."
#~ msgstr "我們相信您還能夠聯想到更多應用程式..."

#~ msgid "It's usually easy to fix an <literal>UnsatisfiedDependencyException</literal> or <literal>AmbiguousDependencyException</literal>."
#~ msgstr "要修正一個 <literal>UnsatisfiedDependencyException</literal> 或 <literal>AmbiguousDependencyException</literal> 通常相當容易。"

#~ msgid "To fix an <literal>UnsatisfiedDependencyException</literal>, simply provide a Web Bean which implements the API type and has the binding types of the injection point &#151; or enable the deployment type of a Web Bean that already implements the API type and has the binding types."
#~ msgstr "若要修正一項 <literal>UnsatisfiedDependencyException</literal>，只要提供一個實做 API 類型並且擁有注入點的綁定類型的 Web Bean 即可 &#151; 或是啟用一個已實做 API 類型並且擁有綁定類型的 Web Bean 的 deployment type 即可。"

#~ msgid "To fix an <literal>AmbiguousDependencyException</literal>, introduce a binding type to distinguish between the two implementations of the API type, or change the deployment type of one of the implementations so that the Web Bean manager can use deployment type precedence to choose between them. An <literal>AmbiguousDependencyException</literal> can only occur if two Web Beans share a binding type and have exactly the same deployment type."
#~ msgstr "若要修正一項 <literal>AmbiguousDependencyException</literal>，您可加入一個綁定類型來在兩個 API 類型的實做之間進行分辨，或是更改其中一個實做的 deployment type，這樣一來 Web Bean 管理員便可透過使用 deployment type 優先權來在它們之間作選擇。<literal>AmbiguousDependencyException</literal> 只會在有兩個 Web Bean 共享一個綁定類型並擁有相同 deployment type 的情況下才會發生。"

#~ msgid "<![CDATA[@Current Manager manager;]]>"
#~ msgstr "<![CDATA[@Current Manager manager;]]>"

#~ msgid "The <literal>Manager</literal> object provides a set of methods for obtaining a Web Bean instance programatically."
#~ msgstr "<literal>Manager</literal> 這個物件提供了一組用來程式性地取得 Web Bean instance 的 method。"

#~ msgid "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class);]]>"
#~ msgstr "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class);]]>"

#~ msgid "Binding annotations may be specified by subclassing the helper class <literal>AnnotationLiteral</literal>, since it is otherwise difficult to instantiate an annotation type in Java."
#~ msgstr "綁定標記能被透過建立 helper class 的 subclass <literal>AnnotationLiteral</literal> 來指定，否則在 Java 中很難例示一個標記類型。"

#~ msgid "If the binding type has an annotation member, we can't use an anonymous subclass of <literal>AnnotationLiteral</literal> &#151; instead we'll need to create a named subclass:"
#~ msgstr "若綁定類型有個標記成員，我們便無法使用 <literal>AnnotationLiteral</literal> 的一個匿名 subclass &#151; 我們需要建立一個有命名的 subclass："

#~ msgid ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
#~ "                                               new CreditCardBinding() { \n"
#~ "                                                   public void value() { return paymentType; } \n"
#~ "                                               } );]]>"
#~ msgstr ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
#~ "                                               new CreditCardBinding() { \n"
#~ "                                                   public void value() { return paymentType; } \n"
#~ "                                               } );]]>"

#~ msgid "Lifecycle callbacks, <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal>"
#~ msgstr "Lifecycle callback、<literal>@Resource</literal>、<literal>@EJB</literal> 和 <literal>@PersistenceContext</literal>"

#~ msgid "Enterprise Web Beans support all the lifecycle callbacks defined by the EJB specification: <literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>, <literal>@PrePassivate</literal> and <literal>@PostActivate</literal>."
#~ msgstr "企業級的 Web Bean 支援 EJB 規格所定義的所有 lifecycle callback：<literal>@PostConstruct</literal>、<literal>@PreDestroy</literal>、<literal>@PrePassivate</literal> 和 <literal>@PostActivate</literal>。"

#~ msgid "Both enterprise and simple Web Beans support the use of <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal> for injection of Java EE resources, EJBs and JPA persistence contexts, respectively. Simple Web Beans do not support the use of <literal>@PersistenceContext(type=EXTENDED)</literal>."
#~ msgstr "企業級和基本的 Web Bean 皆支援使用 <literal>@Resource</literal>、<literal>@EJB</literal> 和 <literal>@PersistenceContext</literal> 來相應地注入 Java EE 資源、EJB 和 JPA 的 persistence context。基本的 Web Bean 不支援使用 <literal>@PersistenceContext(type=EXTENDED)</literal>。"

#~ msgid "The <literal>@PostConstruct</literal> callback always occurs after all dependencies have been injected."
#~ msgstr "<literal>@PostConstruct</literal> callback 一定會在所有相依性都被注入後才會發生。"
