# Language it-IT translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2012-01-16T16:07:16\n"
"PO-Revision-Date: 2009-06-08 21:35+0100\n"
"Last-Translator: Nicola Benaglia <nico.benaz@gmail.com>\n"
"Language-Team: none\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, fuzzy, no-c-format
msgid "Integrating Weld into other environments"
msgstr "Integrazione di Web Beans in altri ambienti"

#. Tag: para
#, no-c-format
msgid "If you want to use Weld in another environment, you will need to provide certain information to Weld via the integration SPI. In this Appendix we will briefly discuss the steps needed."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Enterprise Services"
msgstr "Servizi di risorse"

#. Tag: para
#, no-c-format
msgid "If you just want to use managed beans, and not take advantage of enterprise services (EE resource injection, CDI injection into EE component classes, transactional events, support for CDI services in EJBs) and non-flat deployments, then the generic servlet support provided by the \"Weld: Servlets\" extension will be sufficient, and will work in any container supporting the Servlet API."
msgstr ""

#. Tag: para
#, no-c-format
msgid "All SPIs and APIs described have extensive JavaDoc, which spell out the detailed contract between the container and Weld."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "The Weld SPI"
msgstr "Web Beans SPI"

#. Tag: para
#, fuzzy, no-c-format
msgid "The Weld SPI is located in the <literal>weld-spi</literal> module, and packaged as <literal>weld-spi.jar</literal>. Some SPIs are optional, and should only be implemented if you need to override the default behavior; others are required."
msgstr "Web Beans SPI è collocato nel modulo <literal>webbeans-spi</literal>, ed è impacchettato come <literal>webbeans-spi.jar</literal>. Alcuni SPI sono opzionali se occorre fare override del comportamento di default, altri sono richiesti."

#. Tag: para
#, no-c-format
msgid "All interfaces in the SPI support the decorator pattern and provide a <literal>Forwarding</literal> class located in the <literal>helpers</literal> sub package. Additional, commonly used, utility classes, and standard implementations are also located in the <literal>helpers</literal> sub package."
msgstr "Tutte le interfacce in SPI supportano il pattern decorator e forniscono una classe <literal>Forwarding</literal> situata nel sottopacchetto <literal>helpers</literal>. Anche altre classi utility ed implementazioni standard sono collocate nel sottopacchetto <literal>helpers</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "Weld supports multiple environments. An environment is defined by an implementation of the <literal>Environment</literal> interface. A number of standard environments are built in, and described by the <literal>Environments</literal> enumeration. Different environments require different services to be present (for example a Servlet container doesn't require transaction, EJB or JPA services). By default an EE environment is assumed, but you can adjust the environment by calling <literal>bootstrap.setEnvironment()</literal>."
msgstr "Il bootstrap supporta più ambienti. Un ambiente viene definito da un'implementazione dell'interfaccia <literal>Environment</literal>. Un numero di ambienti standard sono predefiniti nell'enumeration <literal>Environments</literal>. Diversi ambienti richiedono diversi servizi presenti (per esempio servlet non richiede i servizi di transazione, EJB o JPA). Di default viene assunto un ambiente EE, ma si può impostare un ambiente chiamando <literal>bootstrap.setEnvironment()</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "Weld uses a generic-typed service registry to allow services to be registered. All services implement the <literal>Service</literal> interface. The service registry allows services to be added and retrieved."
msgstr "Web Beans usa un registro di servizio con tipo generico per consentire ai servizi di essere registrati. Tutti i servizi implementano l'interfaccia <literal>Service</literal>. Il registro di servizio consente ai servizio di essere aggiunti e recuperati."

#. Tag: title
#, no-c-format
msgid "Deployment structure"
msgstr ""

#. Tag: para
#, no-c-format
msgid "An application is often comprised of a number of modules. For example, a Java EE deployment may contain a number of EJB modules (containing business logic) and war modules (containing the user interface). A container may enforce certain <emphasis>accessibility</emphasis> rules which limit the visibility of classes between modules. CDI allows these same rules to apply to bean and observer method resolution. As the accessibility rules vary between containers, Weld requires the container to <emphasis>describe</emphasis> the deployment structure, via the <literal>Deployment</literal> SPI."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The CDI specification discusses <emphasis>Bean Deployment Archives</emphasis> (BDAs)&mdash;archives which are marked as containing beans which should be deployed to the CDI container, and made available for injection and resolution. Weld reuses this description of <emphasis>Bean Deployment Archives</emphasis> in its deployment structure SPI. Each deployment exposes the BDAs which it contains; each BDA may also reference other which it can access. Together, the transitive closure of this graph forms the beans which are deployed in the application."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To describe the deployment structure to Weld, the container should provide an implementation of <literal>Deployment</literal>. <literal>Deployment.getBeanDeploymentArchives()</literal> allows Weld to discover the modules which make up the application. The CDI specification also allows beans to be specified programmatically as part of the bean deployment. These beans may, or may not, be in an existing BDA. For this reason, Weld will call <literal>Deployment.loadBeanDeploymentArchive(Class clazz)</literal> for each programmatically described bean."
msgstr ""

#. Tag: para
#, no-c-format
msgid "As programmatically described beans may result in additional BDAs being added to the graph, Weld will discover the BDA structure every time an unknown BDA is returned by <literal>Deployment.loadBeanDeploymentArchive</literal>."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Virtual BDAs"
msgstr ""

#. Tag: para
#, no-c-format
msgid "In a strict container, each BDA might have to explicitly specify which other BDAs it can access. However many containers will allow an easy mechanism to make BDAs bi-directionally accessible (such as a library directory). In this case, it is allowable (and reasonable) to describe all such archives as a single, 'virtual' <literal>BeanDeploymentArchive</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "A container, might, for example, use a flat accessibility structure for the application. In this case, a single <literal>BeanDeploymentArchive</literal> would be attached to the <literal>Deployment</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>BeanDeploymentArchive</literal> provides three methods which allow it's contents to be discovered by Weld&mdash;<literal>BeanDeploymentArchive.getBeanClasses()</literal> must return all the classes in the BDA, <literal>BeanDeploymentArchive.getBeansXml()</literal> must return a data structure representing the <code>beans.xml</code> deployment descriptor for the archive, and <literal>BeanDeploymentArchive.getEjbs()</literal> must provide an EJB descriptor for every EJB in the BDA, or an empty list if it is not an EJB archive."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To aid container integrator, Weld provides a built-in <code>beans.xml</code> parser. To parse a <code>beans.xml</code> into the data-structure required by <code>BeanDeploymentArchive</code>, the container should call <code>Bootstrap.parseBeansXml(URL)</code>. Weld can also parse multiple <code>beans.xml</code> files, merging them to become a single data-structure. This can be achieved by calling <code>Bootstrap.parseBeansXml(Iterable&lt;URL&gt;)</code>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "BDA X may also reference another BDA Y whose beans can be resolved by, and injected into, any bean in BDA X. These are the accessible BDAs, and every BDA that is directly accessible by BDA X should be returned. A BDA will also have BDAs which are accessible transitively, and the transitive closure of the sub-graph of BDA X describes all the beans resolvable by BDA X."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Matching the classloader structure for the deployment"
msgstr ""

#. Tag: para
#, no-c-format
msgid "In practice, you can regard the deployment structure represented by <literal>Deployment</literal>, and the virtual BDA graph as a mirror of the classloader structure for a deployment. If a class can from BDA X can be loaded by another in BDA Y, it is accessible, and therefore BDA Y's accessible BDAs should include BDA X."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To specify the directly accessible BDAs, the container should provide an implementation of <literal>BeanDeploymentArchive.getBeanDeploymentArchives()</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Weld allows the container to describe a circular graph, and will convert a graph to a tree as part of the deployment process."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Certain services are provided for the whole deployment, whilst some are provided per-BDA. BDA services are provided using <literal>BeanDeploymentArchive.getServices()</literal> and only apply to the BDA on which they are provided."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The contract for <code>Deployment</code> requires the container to specify the portable extensions (see chapter 12 of the CDI specification) which should be loaded by the application. To aid the container integrator, Weld provides the method <code>Bootstrap.loadExtensions(ClassLoader)</code> which will load the extensions for the specified classloader."
msgstr ""

#. Tag: title
#, no-c-format
msgid "EJB descriptors"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Weld delegates EJB 3 bean discovery to the container so that it doesn't duplicate the work done by the EJB container, and respects any vendor-extensions to the EJB definition."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "The <literal>EjbDescriptor</literal> should return the relevant metadata as defined in the EJB specification. Each business interface of a session bean should be described using a <literal>BusinessInterfaceDescriptor</literal>."
msgstr "Il <literal>EjbDescriptor</literal> è abbastanza auto-esplicatorio e dovrebbe restituire i metadati rilevanti definiti nella specifica EJB. In aggiunta a queste due interfacce, vi è <literal>BusinessInterfaceDescriptor</literal> a rappresentare un'interfaccia locale di business (che incapsula la classe d'interfaccia ed il nome jndi usato per la ricerca di una istanza EJB)."

#. Tag: title
#, no-c-format
msgid "EE resource injection and resolution services"
msgstr ""

#. Tag: para
#, no-c-format
msgid "All the EE resource services are per-BDA services, and may be provided using one of two methods. Which method to use is at the discretion of the integrator."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The integrator may choose to provide all EE resource injection services themselves, using another library or framework. In this case the integrator should use the <literal>EE</literal> environment, and implement the <xref linkend=\"injection.services\" /> SPI."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Alternatively, the integrator may choose to use CDI to provide EE resource injection. In this case, the <literal>EE_INJECT</literal> environment should be used, and the integrator should implement the <xref linkend=\"ejb.services.resolution\" />, <xref linkend=\"resource.services\" /> and <xref linkend=\"jpa.services\" />."
msgstr ""

#. Tag: para
#, no-c-format
msgid "CDI only provides annotation-based EE resource injection; if you wish to provide deployment descriptor (e.g. <literal>ejb-jar.xml</literal>) injection, you must use <xref linkend=\"injection.services\" />."
msgstr ""

#. Tag: para
#, no-c-format
msgid "If the container performs EE resource injection, the injected resources must be serializable. If EE resource injection is provided by Weld, the resolved resource must be serializable."
msgstr ""

#. Tag: para
#, no-c-format
msgid "If you use a non-EE environment then you may implement any of the EE service SPIs, and Weld will provide the associated functionality. There is no need to implement those services you don't need!"
msgstr ""

#. Tag: title
#, no-c-format
msgid "EJB services"
msgstr "Servizi EJB"

#. Tag: para
#, no-c-format
msgid "EJB services are split between two interfaces which are both per-BDA."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>EJBServices</literal> is used to resolve local EJBs used to back session beans, and must always be provided in an EE environment. <literal>EJBServices.resolveEjb(EjbDescriptor ejbDescriptor)</literal> returns a wrapper&mdash;<literal>SessionObjectReference</literal>&mdash;around the EJB reference. This wrapper allows Weld to request a reference that implements the given business interface, and, in the case of SFSBs, both request the removal of the EJB from the container and query whether the EJB has been previously removed."
msgstr "Risolvendo gli EJB locali (usati per mappare i session bean) viene restituito un wrapper (<literal>SessionObjectReference</literal>) attorno al riferimento EJB. Questo wrapper consente a Web Beans di richiedere un riferimento che implementi l'interfaccia di business data e, nel caso di SFSB, la richiesta di rimozione dell'EJB dal container."

#. Tag: para
#, fuzzy, no-c-format
msgid "<literal>EJBResolutionServices.resolveEjb(InjectionPoint ij)</literal> allows the resolution of <literal>@EJB</literal> (for injection into managed beans). This service is not required if the implementation of <xref linkend=\"injection.services\" /> takes care of <literal>@EJB</literal> injection."
msgstr "La risoluzione di di riferimenti web service (per l'iniezione come risorse Java EE) è delegata al container. Occorre fornire un'implementazione di <literal>WebServices</literal> che rende disponibili queste operazioni. Per risolvere la risorsa Java EE verrà fornito <literal>jndiName</literal> o <literal>mappedName</literal>"

#. Tag: title
#, no-c-format
msgid "JPA services"
msgstr "Servizi JPA"

#. Tag: para
#, fuzzy, no-c-format
msgid "Just as EJB resolution is delegated to the container, resolution of <literal>@PersistenceContext</literal> for injection into managed beans (with the <literal>InjectionPoint</literal> provided), is delegated to the container."
msgstr "Così come la risoluzione EJB è delegataal container, vengono delegate al container anche la risoluzione del <literal>@PersistenceContext</literal> per l'iniezione in semplici bean (con <literal>InjectionPoint</literal> fornito), e la risoluzione dei contesti di persistenza e delle unità di persistenza (con <literal>InjectionPoint</literal> fornito) per l'iniezione come risorse Java EE."

#. Tag: para
#, fuzzy, no-c-format
msgid "To allow JPA integration, the <literal>JpaServices</literal> interface should be implemented. This service is not required if the implementation of <xref linkend=\"injection.services\" /> takes care of <literal>@PersistenceContext</literal> injection."
msgstr "La risoluzione di di riferimenti web service (per l'iniezione come risorse Java EE) è delegata al container. Occorre fornire un'implementazione di <literal>WebServices</literal> che rende disponibili queste operazioni. Per risolvere la risorsa Java EE verrà fornito <literal>jndiName</literal> o <literal>mappedName</literal>"

#. Tag: title
#, no-c-format
msgid "Transaction Services"
msgstr "Servizi di transazione"

#. Tag: para
#, fuzzy, no-c-format
msgid "Weld delegates JTA activities to the container. The SPI provides a couple hooks to easily achieve this with the <literal>TransactionServices</literal> interface."
msgstr "Web Beans deve delegare le attività JTA al container. SPI fornisce un paio di modi per ottenere ciò tramite l'interfaccia <literal>TransactionServices</literal>."

#. Tag: para
#, no-c-format
msgid "Any <literal>javax.transaction.Synchronization</literal> implementation may be passed to the <literal>registerSynchronization()</literal> method and the SPI implementation should immediately register the synchronization with the JTA transaction manager used for the EJBs."
msgstr "Qualsiasi implementazione di <literal>javax.transaction.Synchronization</literal> può essere passata al metodo <literal>registerSynchronization()</literal> e l'implementazione SPI deve immediatamente registrare la sincronizzazione con il gestore della transazione JTA usato per EJB."

#. Tag: para
#, no-c-format
msgid "To make it easier to determine whether or not a transaction is currently active for the requesting thread, the <literal>isTransactionActive()</literal> method can be used. The SPI implementation should query the same JTA transaction manager used for the EJBs."
msgstr "Per facilitare la determinazione se o no una transazione è attualmente attiva per il thread di richiesta, può essere usato il metodo <literal>isTransactionActive()</literal>. L'implementazione SPI deve interrogare lo stesso gestore della transazione JTA usato per EJB."

#. Tag: title
#, no-c-format
msgid "Resource Services"
msgstr "Servizi di risorse"

#. Tag: para
#, fuzzy, no-c-format
msgid "The resolution of <literal>@Resource</literal> (for injection into managed beans) is delegated to the container. You must provide an implementation of <literal>ResourceServices</literal> which provides these operations. This service is not required if the implementation of <xref linkend=\"injection.services\" /> takes care of <literal>@Resource</literal> injection."
msgstr "La risoluzione di di riferimenti web service (per l'iniezione come risorse Java EE) è delegata al container. Occorre fornire un'implementazione di <literal>WebServices</literal> che rende disponibili queste operazioni. Per risolvere la risorsa Java EE verrà fornito <literal>jndiName</literal> o <literal>mappedName</literal>"

#. Tag: title
#, fuzzy, no-c-format
msgid "Injection Services"
msgstr "Servizi di transazione"

#. Tag: para
#, no-c-format
msgid "An integrator may wish to use <literal>InjectionServices</literal> to provide additional field or method injection over-and-above that provided by Weld. An integration into a Java EE environment may use <literal>InjectionServices</literal> to provide EE resource injection for managed beans."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>InjectionServices</literal> provides a very simple contract, the <literal>InjectionServices.aroundInject(InjectionContext ic);</literal> interceptor will be called for every instance that CDI injects, whether it is a contextual instance, or a non-contextual instance injected by <literal>InjectionTarget.inject()</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The <literal>InjectionContext</literal> can be used to discover additional information about the injection being performed, including the <literal>target</literal> being injected. <literal>ic.proceed()</literal> should be called to perform CDI-style injection, and call initializer methods."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Security Services"
msgstr "Servizi di risorse"

#. Tag: para
#, no-c-format
msgid "In order to obtain the <literal>Principal</literal> representing the current caller identity, the container should provide an implementation of <literal>SecurityServices</literal>."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Bean Validation Services"
msgstr "Servizi di transazione"

#. Tag: para
#, no-c-format
msgid "In order to obtain the default <literal>ValidatorFactory</literal> for the application deployment, the container should provide an implementation of <literal>ValidationServices</literal>."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Identifying the BDA being addressed"
msgstr ""

#. Tag: para
#, no-c-format
msgid "When a client makes a request to an application which uses Weld, the request may be addressed at any of the BDAs in the application deployment. To allow Weld to correctly service the request, it needs to know which BDA the request is addressed at. Where possible, Weld will provide some context, but use of these by the integrator is optional."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Most Servlet contains use a classloader-per-war, this may provide a good way to identify the BDA in use for web requests."
msgstr ""

#. Tag: para
#, no-c-format
msgid "When Weld needs to identify the BDA, it will use one of these services, depending on what is servicing the request:"
msgstr ""

#. Tag: term
#, no-c-format
msgid "<literal>ServletServices.getBeanDeploymentArchive(ServletContext ctx)</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Identify the war in use. The <literal>ServletContext</literal> is provided for additional context."
msgstr ""

#. Tag: title
#, no-c-format
msgid "The bean store"
msgstr "Il bean store"

#. Tag: para
#, fuzzy, no-c-format
msgid "Weld uses a map like structure to store bean instances - <literal>org.jboss.weld.context.api.BeanStore</literal>. You may find <literal>org.jboss.weld.context.api.helpers.ConcurrentHashMapBeanStore</literal> useful."
msgstr "Web Beans utilizza una mappa come struttura per memorizzare le istanze bean - <literal>org.jboss.webbeans.context.api.BeanStore</literal>. Si potrebbe trovare molto utile <literal>org.jboss.webbeans.context.api.helpers.ConcurrentHashMapBeanStore</literal>."

#. Tag: title
#, no-c-format
msgid "The application context"
msgstr "Il contesto applicazione"

#. Tag: para
#, fuzzy, no-c-format
msgid "Weld expects the Application Server or other container to provide the storage for each application's context. The <literal>org.jboss.weld.context.api.BeanStore</literal> should be implemented to provide an application scoped storage."
msgstr "Web Beans si aspetta che l'Application Server od un altro container fornisca la memorizzazione per ogni contesto applicazione. <literal>org.jboss.webbeans.context.api.BeanStore</literal> dovrebbe essere implementato per fornire uno storage con scope applicazione."

#. Tag: title
#, fuzzy, no-c-format
msgid "Initialization and shutdown"
msgstr "Bootstrap e spegnimento"

#. Tag: para
#, fuzzy, no-c-format
msgid "The <literal>org.jboss.weld.bootstrap.api.Bootstrap</literal> interface defines the initialization for Weld, bean deployment and bean validation. To boot Weld, you must create an instance of <literal>org.jboss.weld.bootstrap.WeldBeansBootstrap</literal> (which implements <literal>Boostrap</literal>), tell it about the services in use, and then request the container start."
msgstr "L'interfaccia <literal>org.jboss.webbeans.bootstrap.api.Bootstrap</literal> definisce il bootstrap per Web Beans. Per avviare Web Beans occorre ottenere un'istanza di <literal>org.jboss.webbeans.bootstrap.WebBeansBootstrap</literal> (che implementa <literal>Boostrap</literal>), e comunicare le SPI in uso, e poi chiedere che il container venga avviato."

#. Tag: para
#, fuzzy, no-c-format
msgid "The bootstrap is split into phases, container initialization, bean deployment, bean validation and shutdown. Initialization will create a manager, and add the built-in contexts, and examine the deployment structure. Bean deployment will deploy any beans (defined using annotations, programmatically, or built in). Bean validation will validate all beans."
msgstr "Il bootstrap è suddiviso in più fasi, inizializzazione del bootstrap, bootstrap e shutdown. L'inizializzazione creerà un manager, e aggiungerà i contesti standard (definiti dalla specifica). Bootstrap scoprirà EJB, classi e XML; aggiungerà i bean definiti con le annotazioni; aggiungerà i bean definiti con XML; e validerà tutti i bean."

#. Tag: para
#, fuzzy, no-c-format
msgid "To initialize the container, you call <literal>Bootstrap.startInitialization()</literal>. Before calling <literal>startInitialization()</literal>, you must register any services required by the environment. You can do this by calling, for example, <literal>bootstrap.getServices().add(JpaServices.class, new MyJpaServices())</literal>. You must also provide the application context bean store."
msgstr "Per inizializzare il bootstrap si chiama <literal>Bootstrap.initialize()</literal>. Prima della chiamata di <literal>initialize()</literal> occorre registrare i servizi richiesti dal proprio ambiente. Si può fare questo chiamando <literal>bootstrap.getServices().add(JpaServices.class, new MyJpaServices())</literal>. Occorre anche fornire l'application context bean store."

#. Tag: para
#, fuzzy, no-c-format
msgid "Having called <literal>startInitialization()</literal>, the <literal>Manager</literal> for each BDA can be obtained by calling <literal>Bootstrap.getManager(BeanDeploymentArchive bda)</literal>."
msgstr "Dopo aver chiamato <literal>initialize()</literal>, il <literal>Manager</literal> può essere ottenuto chiamando <literal>Bootstrap.getManager()</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "To deploy the discovered beans, call <literal>Bootstrap.deployBeans()</literal>."
msgstr "Per avviare il container chiamare <literal>Bootstrap.boot()</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "To validate the deployed beans, call <literal>Bootstrap.validateBeans()</literal>."
msgstr "Per avviare il container chiamare <literal>Bootstrap.boot()</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "To place the container into a state where it can service requests, call <literal>Bootstrap.endInitialization()</literal>"
msgstr "Per avviare il container chiamare <literal>Bootstrap.boot()</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "To shutdown the container you call <literal>Bootstrap.shutdown()</literal>. This allows the container to perform any cleanup operations needed."
msgstr "Per spegnere il container si chiama <literal>Bootstrap.shutdown()</literal> o <literal>webBeansManager.shutdown()</literal>. Questo consente al container di eseguire ogni pulizia necessaria delle operazioni."

#. Tag: title
#, no-c-format
msgid "Resource loading"
msgstr "Caricamento risorse"

#. Tag: para
#, fuzzy, no-c-format
msgid "Weld needs to load classes and resources from the classpath at various times. By default, they are loaded from the Thread Context ClassLoader if available, if not the same classloader that was used to load Weld, however this may not be correct for some environments. If this is case, you can implement <literal>org.jboss.weld.spi.ResourceLoader</literal>."
msgstr "Web Beans deve caricare le classi e le risorse dal classpath in vari momenti. Di default vengono caricati dal Thread Context ClassLoader se disponibile, se non lo stesso classloader che è stato usato per caricare Web Beans, comunque questo potrebbe non essere corretto in alcuni ambienti. Se è questo il caso si può implementare  <literal>org.jboss.webbeans.spi.ResourceLoader</literal>:"

#. Tag: title
#, no-c-format
msgid "The contract with the container"
msgstr "Il contratto con il container"

#. Tag: para
#, fuzzy, no-c-format
msgid "There are a number of requirements that Weld places on the container for correct functioning that fall outside implementation of APIs."
msgstr "Per il corretto funzionamento al di fuori dell'implementazione delle API, ci sono un numero di requisiti che Web Beans RI pone nel container."

#. Tag: term
#, no-c-format
msgid "Classloader isolation"
msgstr "Isolamento del classloader"

#. Tag: para
#, fuzzy, no-c-format
msgid "If you are integrating Weld into an environment that supports deployment of multiple applications, you must enable, automatically, or through user configuration, classloader isolation for each CDI application."
msgstr "Se si integra Web Beans in un ambiente che supporta il deploy di applicazioni, occorre abilitare, automaticamente o attraverso la configurazione utente, l'isolamento del classloader per ogni applicazione Web Beans."

#. Tag: term
#, no-c-format
msgid "Servlet"
msgstr "Servlet"

#. Tag: para
#, fuzzy, no-c-format
msgid "If you are integrating Weld into a Servlet environment you must register <literal>org.jboss.weld.servlet.WeldListener</literal> as a Servlet listener, either automatically, or through user configuration, for each CDI application which uses Servlet."
msgstr "Se si integra Web Beans in un ambiente Servlet occorre registrare <literal>org.jboss.webbeans.servlet.WebBeansListener</literal> come Servlet listener, o automaticamente, o attraverso una configurazione utente, per ciascuna applicazione Web Beans che usa Servlet."

#. Tag: para
#, no-c-format
msgid "You must ensure that <literal>WeldListener.contextInitialized()</literal> is called after beans are deployed is complete (<literal>Bootstrap.deployBeans()</literal> has been called)."
msgstr ""

#. Tag: term
#, no-c-format
msgid "JSF"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "If you are integrating Weld into a JSF environment you must register <literal>org.jboss.weld.jsf.WeldPhaseListener</literal> as a phase listener."
msgstr "Se si integra Web Beans in un ambiente Servlet occorre registrare <literal>org.jboss.webbeans.servlet.WebBeansListener</literal> come Servlet listener, o automaticamente, o attraverso una configurazione utente, per ciascuna applicazione Web Beans che usa Servlet."

#. Tag: para
#, fuzzy, no-c-format
msgid "If you are integrating Weld into a JSF environment you must register <literal>org.jboss.weld.el.WeldELContextListener</literal> as an EL Context listener."
msgstr "Se si integra Web Beans in un ambiente Servlet occorre registrare <literal>org.jboss.webbeans.servlet.WebBeansListener</literal> come Servlet listener, o automaticamente, o attraverso una configurazione utente, per ciascuna applicazione Web Beans che usa Servlet."

#. Tag: para
#, fuzzy, no-c-format
msgid "If you are integrating Weld into a JSF environment you must register <literal>org.jboss.weld.jsf.ConversationAwareViewHandler</literal> as a delegating view handler."
msgstr "Se si integra Web Beans in un ambiente Servlet occorre registrare <literal>org.jboss.webbeans.servlet.WebBeansListener</literal> come Servlet listener, o automaticamente, o attraverso una configurazione utente, per ciascuna applicazione Web Beans che usa Servlet."

#. Tag: para
#, no-c-format
msgid "If you are integrating Weld into a JSF environment you must obtain the bean manager for the module and then call <literal>BeanManager.wrapExpressionFactory()</literal>, passing <literal>Application.getExpressionFactory()</literal> as the argument. The wrapped expression factory must be used in all EL expression evaluations performed by JSF in this web application."
msgstr ""

#. Tag: para
#, no-c-format
msgid "If you are integrating Weld into a JSF environment you must obtain the bean manager for the module and then call <literal>BeanManager.getELResolver()</literal>, The returned EL resolver should be registered with JSF for this web application."
msgstr ""

#. Tag: para
#, no-c-format
msgid "There are a number of ways you can obtain the bean manager for the module. You could call <literal>Bootstrap.getManager()</literal>, passing in the BDA for this module. Alternatively, you could use the injection into Java EE component classes, or look up the bean manager in JNDI."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "If you are integrating Weld into a JSF environment you must register <literal>org.jboss.weld.servlet.ConversationPropagationFilter</literal> as a Servlet listener, either automatically, or through user configuration, for each CDI application which uses JSF. This filter can be registered for all Servlet deployment safely."
msgstr "Se si integra Web Beans in un ambiente Servlet occorre registrare <literal>org.jboss.webbeans.servlet.ConversationPropagationFilter</literal> come Servlet listener, o automaticamente, o attraverso una configurazione utente, per ciascuna applicazione Web Beans che usa JSF. Questo filtro può venir registrato in modo sicuro per tutti i deploy dei servlet."

#. Tag: para
#, fuzzy, no-c-format
msgid "Weld only supports JSF 1.2 and above."
msgstr "Web Beans supporta solo JSF 1.2 e superiori."

#. Tag: term
#, no-c-format
msgid "JSP"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "If you are integrating Weld into a JSP environment you must register <literal>org.jboss.weld.el.WeldELContextListener</literal> as an EL Context listener."
msgstr "Se si integra Web Beans in un ambiente Servlet occorre registrare <literal>org.jboss.webbeans.servlet.WebBeansListener</literal> come Servlet listener, o automaticamente, o attraverso una configurazione utente, per ciascuna applicazione Web Beans che usa Servlet."

#. Tag: para
#, no-c-format
msgid "If you are integrating Weld into a JSP environment you must obtain the bean manager for the module and then call <literal>BeanManager.wrapExpressionFactory()</literal>, passing <literal>Application.getExpressionFactory()</literal> as the argument. The wrapped expression factory must be used in all EL expression evaluations performed by JSP."
msgstr ""

#. Tag: para
#, no-c-format
msgid "If you are integrating Weld into a JSP environment you must obtain the bean manager for the module and then call <literal>BeanManager.getELResolver()</literal>, The returned EL resolver should be registered with JSP for this web application."
msgstr ""

#. Tag: term
#, no-c-format
msgid "Session Bean Interceptor"
msgstr "Session Bean Interceptor"

#. Tag: para
#, fuzzy, no-c-format
msgid "If you are integrating Weld into an EJB environment you must register the <literal>aroundInvoke</literal> method of <literal>org.jboss.weld.ejb.SessionBeanInterceptor</literal> as a EJB around-invoke interceptor for all EJBs in the application, either automatically, or through user configuration, for each CDI application which uses enterprise beans. If you are running in a EJB 3.1 environment, you should register this as an around-timeout interceptor as well."
msgstr "Se si integra Web Beans in un ambiente EJB occorre registrare <literal>org.jboss.webbeans.ejb.SessionBeanInterceptor</literal> come interceptor EJB per ogni EJB dell'applicazione, o automaticamente o attraverso una configurazione utente, per ciascuna applicazione Web Beans che utilizza bean enterprise."

#. Tag: para
#, no-c-format
msgid "You must register the <literal>SessionBeanInterceptor</literal> as the inner most interceptor in the stack for all EJBs."
msgstr "Occorre registrare il <literal>SessionBeanInterceptor</literal> come interceptor più interno allo stack per tutti gli EJB."

#. Tag: term
#, fuzzy, no-c-format
msgid "The <literal>weld-core.jar</literal>"
msgstr "<literal>webbeans-core.jar</literal>"

#. Tag: para
#, no-c-format
msgid "Weld can reside on an isolated classloader, or on a shared classloader. If you choose to use an isolated classloader, the default <literal>SingletonProvider</literal>, <literal>IsolatedStaticSingletonProvider</literal>, can be used. If you choose to use a shared classloader, then you will need to choose another strategy."
msgstr ""

#. Tag: para
#, no-c-format
msgid "You can provide your own implementation of <literal>Singleton</literal> and <literal>SingletonProvider</literal> and register it for use using <literal>SingletonProvider.initialize(SingletonProvider provider)</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Weld also provides an implementation of Thread Context Classloader per application strategy, via the <literal>TCCLSingletonProvider</literal>."
msgstr ""

#. Tag: term
#, no-c-format
msgid "Binding the manager in JNDI"
msgstr "Associare il manager a JNDI"

#. Tag: para
#, fuzzy, no-c-format
msgid "You should bind the bean manager for the bean deployment archive into JNDI at <literal>java:comp/BeanManager</literal>. The type should be <literal>javax.enterprise.inject.spi.BeanManager</literal>. To obtain the correct bean manager for the bean deployment archive, you may call <literal>bootstrap.getBeanManager(beanDeploymentArchive)</literal>"
msgstr "Occorre associare <literal>Reference</literal> al Manager <literal>ObjectFactory</literal> in JNDI all'indirizzo <literal>java:app/Manager</literal>. Il tipo dovrebbe essere <literal>javax.inject.manager.Manager</literal> e la classe di factory è <literal>org.jboss.webbeans.resources.ManagerObjectFactory</literal>"

#. Tag: term
#, no-c-format
msgid "Performing CDI injection on Java EE component classes"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The CDI specification requires the container to provide injection into non-contextual resources for all Java EE component classes. Weld delegates this responsibility to the container. This can be achieved using the CDI defined <literal>InjectionTarget</literal> SPI. Furthermore, you must perform this operation on the correct bean manager for the bean deployment archive containing the EE component class."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The CDI specification also requires that a <literal>ProcessInjectionTarget</literal> event is fired for every Java EE component class. Furthermore, if an observer calls <literal>ProcessInjectionTarget.setInjectionTarget()</literal> the container must use <emphasis>the specified</emphasis> injection target to perform injection."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To help the integrator, Weld provides <literal>WeldManager.fireProcessInjectionTarget()</literal> which returns the <literal>InjectionTarget</literal> to use."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"// Fire ProcessInjectionTarget, returning the InjectionTarget\n"
"// to use\n"
"InjectionTarget it = weldBeanManager.fireProcessInjectionTarget(clazz);\n"
"\n"
"// Per instance required, create the creational context\n"
"CreationalContext&lt;?&gt; cc = beanManager.createCreationalContext(null);\n"
"\n"
"// Produce the instance, performing any constructor injection required\n"
"Object instance = it.produce();\n"
"\n"
"// Perform injection and call initializers\n"
"it.inject(instance, cc);\n"
"\n"
"// Call the post-construct callback\n"
"it.postConstruct(instance);\n"
"\n"
"// Call the pre-destroy callback\n"
"it.preDestroy(instance);\n"
"\n"
"// Clean up the instance\n"
"it.dispose();\n"
"cc.release();"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The container may intersperse other operations between these calls. Further, the integrator may choose to implement any of these calls in another manner, assuming the contract is fulfilled."
msgstr ""

#. Tag: para
#, no-c-format
msgid "When performing injections on EJBs you must use the Weld-defined SPI, <literal>WeldManager</literal>. Furthermore, you must perform this operation on the correct bean manager for the bean deployment archive containing the EJB."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"// Obtain the EjbDescriptor for the EJB\n"
"// You may choose to use this utility method to get the descriptor\n"
"EjbDescriptor&lt;?&gt; ejbDescriptor = beanManager.getEjbDescriptor(ejbName);\n"
"\n"
"// Get an the Bean object\n"
"Bean&lt;?&gt; bean = beanManager.getBean(ejbDescriptor);\n"
"\n"
"// Create the injection target\n"
"InjectionTarget it = deploymentBeanManager.createInjectionTarget(ejbDescriptor);\n"
"\n"
"// Per instance required, create the creational context\n"
"CreationalContext&lt;?&gt; cc = deploymentBeanManager.createCreationalContext(bean);\n"
"\n"
"// Perform injection and call initializers\n"
"it.inject(instance, cc);\n"
"\n"
"// You may choose to have CDI call the post construct and pre destroy\n"
"// lifecycle callbacks\n"
"\n"
"// Call the post-construct callback\n"
"it.postConstruct(instance);\n"
"\n"
"// Call the pre-destroy callback\n"
"it.preDestroy(instance);\n"
"\n"
"// Clean up the instance\n"
"it.dispose();\n"
"cc.release();"
msgstr ""

#~ msgid "<term>JSF</term>"
#~ msgstr "<term>JSF</term>"

#, fuzzy
#~ msgid "<term>JSP</term>"
#~ msgstr "<term>JSF</term>"

#~ msgid "Currently Web Beans only runs in JBoss AS 5; integrating the RI into other EE environments (for example another application server like Glassfish), into a servlet container (like Tomcat), or with an Embedded EJB3.1 implementation is fairly easy. In this Appendix we will briefly discuss the steps needed."
#~ msgstr "Attualmente Web Beans funziona solo in JBoss AS 5; l'integrazione di RI in altri ambienti EE (per esempio in un application server come Glassfish), in un servlet container (come Tomcat), o con un'implementazione EJB3.1 Embedded è abbastanza facile. In questo appendice si discuterà brevemente dei passi necessari."

#~ msgid "Web Bean Discovery"
#~ msgstr "Web Bean Discovery"

#~ msgid ""
#~ "<![CDATA[/**\n"
#~ "    * Gets list of all classes in classpath archives with META-INF/beans.xml (or\n"
#~ "    * for WARs WEB-INF/beans.xml) files\n"
#~ "    * \n"
#~ "    * @return An iterable over the classes \n"
#~ "    */\n"
#~ "   public Iterable<Class<?>> discoverWebBeanClasses();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a list of all deployment descriptors in the app classpath\n"
#~ "    * \n"
#~ "    * @return An iterable over the beans.xml files \n"
#~ "    */\n"
#~ "   public Iterable<URL> discoverWebBeansXml();]]>"
#~ msgstr ""
#~ "<![CDATA[/**\n"
#~ "    * Gets list of all classes in classpath archives with META-INF/beans.xml (or\n"
#~ "    * for WARs WEB-INF/beans.xml) files\n"
#~ "    * \n"
#~ "    * @return An iterable over the classes \n"
#~ "    */\n"
#~ "   public Iterable<Class<?>> discoverWebBeanClasses();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a list of all deployment descriptors in the app classpath\n"
#~ "    * \n"
#~ "    * @return An iterable over the beans.xml files \n"
#~ "    */\n"
#~ "   public Iterable<URL> discoverWebBeansXml();]]>"

#~ msgid "The discovery of Web Bean classes and <literal>beans.xml</literal> files is self-explanatory (the algorithm is described in Section 11.1 of the JSR-299 specification, and isn't repeated here)."
#~ msgstr "L'analisi dei file delle classi Web Bean e di <literal>beans.xml</literal> è molto istruttiva (l'algoritmo è descritto nella sezione 11.1 della specifica JSR-299 e non viene qua ripetuto)."

#~ msgid "Web Beans will run without an EJB container; in this case you don't need to implement the EJB SPI."
#~ msgstr "Web Beans girerà senza EJB container; in questo caso non serve implementare EJB SPI."

#~ msgid "Web Beans also delegates EJB3 bean discovery to the container so that it doesn't have to scan for EJB3 annotations or parse <literal>ejb-jar.xml</literal>. For each EJB in the application an EJBDescriptor should be discovered:"
#~ msgstr "Web Beans delega al container la rilevazione dei bean EJB3 e quindi risulta non essere necessario eseguire lo scan delle annotazioni EJB3 o fare il parsing di <literal>ejb-jar.xml</literal>. Per ciascun EJB nell'applicazione dovrebbe essere rilevato un EJBDescriptor:"

#~ msgid ""
#~ "<![CDATA[public interface EjbDescriptor<T>\n"
#~ "{\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets the EJB type\n"
#~ "    * \n"
#~ "    * @return The EJB Bean class\n"
#~ "    */\n"
#~ "   public Class<T> getType();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Gets the local business interfaces of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the local business interfaces\n"
#~ "    */\n"
#~ "   public Iterable<BusinessInterfaceDescriptor<?>> getLocalBusinessInterfaces();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets the remote business interfaces of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the remote business interfaces\n"
#~ "    */\n"
#~ "   public Iterable<BusinessInterfaceDescriptor<?>> getRemoteBusinessInterfaces();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Get the remove methods of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the remove methods\n"
#~ "    */\n"
#~ "   public Iterable<Method> getRemoveMethods();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the bean is stateless\n"
#~ "    * \n"
#~ "    * @return True if stateless, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isStateless();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the bean is a EJB 3.1 Singleton\n"
#~ "    * \n"
#~ "    * @return True if the bean is a singleton, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isSingleton();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the EJB is stateful\n"
#~ "    * \n"
#~ "    * @return True if the bean is stateful, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isStateful();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the EJB is and MDB\n"
#~ "    * \n"
#~ "    * @return True if the bean is an MDB, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isMessageDriven();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Gets the EJB name\n"
#~ "    * \n"
#~ "    * @return The name\n"
#~ "    */\n"
#~ "   public String getEjbName();]]>"
#~ msgstr ""
#~ "<![CDATA[public interface EjbDescriptor<T>\n"
#~ "{\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets the EJB type\n"
#~ "    * \n"
#~ "    * @return The EJB Bean class\n"
#~ "    */\n"
#~ "   public Class<T> getType();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Gets the local business interfaces of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the local business interfaces\n"
#~ "    */\n"
#~ "   public Iterable<BusinessInterfaceDescriptor<?>> getLocalBusinessInterfaces();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets the remote business interfaces of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the remote business interfaces\n"
#~ "    */\n"
#~ "   public Iterable<BusinessInterfaceDescriptor<?>> getRemoteBusinessInterfaces();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Get the remove methods of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the remove methods\n"
#~ "    */\n"
#~ "   public Iterable<Method> getRemoveMethods();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the bean is stateless\n"
#~ "    * \n"
#~ "    * @return True if stateless, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isStateless();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the bean is a EJB 3.1 Singleton\n"
#~ "    * \n"
#~ "    * @return True if the bean is a singleton, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isSingleton();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the EJB is stateful\n"
#~ "    * \n"
#~ "    * @return True if the bean is stateful, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isStateful();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the EJB is and MDB\n"
#~ "    * \n"
#~ "    * @return True if the bean is an MDB, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isMessageDriven();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Gets the EJB name\n"
#~ "    * \n"
#~ "    * @return The name\n"
#~ "    */\n"
#~ "   public String getEjbName();]]>"

#~ msgid "The resolution of <literal>@EJB</literal> (for injection into simple beans), the resolution of local EJBs (for backing session beans) and remote EJBs (for injection as a Java EE resource) is delegated to the container. You must provide an implementation of <literal>org.jboss.webbeans.ejb.spi.EjbServices</literal> which provides these operations. For resolving the <literal>@EJB</literal> injection point, Web Beans will provide the <literal>InjectionPoint</literal>; for resolving local EJBs, the <literal>EjbDescriptor</literal> will be provided, and for remote EJBs the <literal>jndiName</literal>, <literal>mappedName</literal>, or <literal>ejbLink</literal> will be provided."
#~ msgstr "La risoluzione di <literal>@EJB</literal> (per l'injection in bean semplici), la risoluzione di EJB locali (per backing bean di sessione) ed EJB remoti (per l'injection come risorsa Java EE) è delegata al container. Occorre fornire un'implementazione di <literal>org.jboss.webbeans.ejb.spi.EjbServices</literal> che rende disponibili queste operazioni. Web Beans fornisce <literal>InjectionPoint</literal>; per risolvere gli EJB locali, viene fornito <literal>EjbDescriptor</literal>, e per gli EJB remoti vengono forniti <literal>jndiName</literal>, <literal>mappedName</literal>, o <literal>ejbLink</literal>."

#~ msgid "To allow JPA integration, the <literal>JpaServices</literal> interface should be implemented."
#~ msgstr "Per consentire l'integrazione con JPA, deve essere implementata l'interfaccia <literal>JpaServices</literal>."

#~ msgid "Web Beans also needs to know what entities are in a deployment (so that they aren't managed by Web Beans). An implementation that detects entities through <literal>@Entity</literal> and <literal>orm.xml</literal> is provided by default. If you want to provide support for a entities defined by a JPA provider (such as Hibernate's <literal>.hbm.xml</literal> you can wrap or replace the default implementation."
#~ msgstr "Web Beans necessitaanche di sapere quali entità sono in deploy (quindi non sono gestite da Web Beans). Un'implementazione che rileva le entità attraverso <literal>@Entity</literal> e <literal>orm.xml</literal> viene fornita di default. Se si vuole fornire support alle entity definite da un provider JPA (quali gli <literal>.hbm.xml</literal> di Hibernate) si può fare il wrap o sostituire l'implementazione di default."

#~ msgid "<![CDATA[EntityDiscovery delegate = bootstrap.getServices().get(EntityDiscovery.class);]]>"
#~ msgstr "<![CDATA[EntityDiscovery delegate = bootstrap.getServices().get(EntityDiscovery.class);]]>"

#~ msgid ""
#~ "<![CDATA[public interface TransactionServices\n"
#~ "{\n"
#~ "   /**\n"
#~ "    * Possible status conditions for a transaction. This can be used by SPI\n"
#~ "    * providers to keep track for which status an observer is used.\n"
#~ "    */\n"
#~ "   public static enum Status\n"
#~ "   {\n"
#~ "      ALL, SUCCESS, FAILURE\n"
#~ "   }\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Registers a synchronization object with the currently executing\n"
#~ "    * transaction.\n"
#~ "    * \n"
#~ "    * @see javax.transaction.Synchronization\n"
#~ "    * @param synchronizedObserver\n"
#~ "    */\n"
#~ "   public void registerSynchronization(Synchronization synchronizedObserver);\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Queries the status of the current execution to see if a transaction is\n"
#~ "    * currently active.\n"
#~ "    * \n"
#~ "    * @return true if a transaction is active\n"
#~ "    */\n"
#~ "   public boolean isTransactionActive();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public interface TransactionServices\n"
#~ "{\n"
#~ "   /**\n"
#~ "    * Possible status conditions for a transaction. This can be used by SPI\n"
#~ "    * providers to keep track for which status an observer is used.\n"
#~ "    */\n"
#~ "   public static enum Status\n"
#~ "   {\n"
#~ "      ALL, SUCCESS, FAILURE\n"
#~ "   }\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Registers a synchronization object with the currently executing\n"
#~ "    * transaction.\n"
#~ "    * \n"
#~ "    * @see javax.transaction.Synchronization\n"
#~ "    * @param synchronizedObserver\n"
#~ "    */\n"
#~ "   public void registerSynchronization(Synchronization synchronizedObserver);\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Queries the status of the current execution to see if a transaction is\n"
#~ "    * currently active.\n"
#~ "    * \n"
#~ "    * @return true if a transaction is active\n"
#~ "    */\n"
#~ "   public boolean isTransactionActive();\n"
#~ "}]]>"

#~ msgid "The enumeration <literal>Status</literal> is a convenience for implementors to be able to keep track of whether a synchronization is supposed to notify an observer only when the transaction is successful, or after a failure, or regardless of the status of the transaction."
#~ msgstr "La enumeration <literal>Status</literal> serve agli implementatori per poter essere in grado di tracciare se una sincronizzazione deve notificare un osservatore solo quando la transazione ha avuto successo, o dopo un errore, o indipendentemente dallo stato della transazione."

#~ msgid "JMS services"
#~ msgstr "Servizi JMS"

#~ msgid "A number of JMS operations are not container specific, and so should be provided via the SPI <literal>JmsServices</literal>. JMS does not specify how to obtain a <literal>ConnectionFactory</literal> so the SPI provides a method which should be used to look up a factory. Web Beans also delegates <literal>Destination</literal> lookup to the container via the SPI."
#~ msgstr "Un numero di operazioni JMS non sono specifiche del container e dovrebbero essere fornite via <literal>JmsServices</literal> SPI. JMS non specifica come ottenere una <literal>ConnectionFactory</literal> quindi SPI fornisce un metodo che dovrebbe essere usato per cercare una factory. Web Beans delega anche la ricerca di <literal>Destination</literal> al container tramite SPI."

#~ msgid "The resolution of <literal>@Resource</literal> (for injection into simple beans) and the resolution of resources (for injection as a Java EE resource) is delegated to the container. You must provide an implementation of <literal>ResourceServices</literal> which provides these operations. For resolving the <literal>@Resource</literal> injection, Web Beans will provide the <literal>InjectionPoint</literal>; and for Java EE resources, the <literal>jndiName</literal> or <literal>mappedName</literal> will be provided."
#~ msgstr "La risoluzione di <literal>@Resource</literal> (per l'injection in bean semplici) e la risoluzione delle risorse (per l'injection come risorsa Java EE) è delegata al container. Occorre fornire un'implementazione di <literal>ResourceServices</literal> che rende disponibili queste operazioni. Per la risoluzione dell'injection <literal>@Resource</literal>, Web Beans fornirà l'<literal>InjectionPoint</literal>; e per le risorse Java EE, verrà fornito <literal>jndiName</literal> o <literal>mappedName</literal>"

#~ msgid "Web Services"
#~ msgstr "Web Service"

#~ msgid "JNDI"
#~ msgstr "JNDI"

#~ msgid "Web Beans delegates all JNDI operations to the container through the SPI."
#~ msgstr "Web Beans delega tutte le operazioni JNDI al container attraverso SPI."

#~ msgid "A number of the SPI interface require JNDI lookup, and the class <literal>AbstractResourceServices</literal> provides JNDI/Java EE spec compliant lookup methods."
#~ msgstr "Un numero di interfacce SPI richiede il lookup JNDI e la classe <literal>AbstractResourceServices</literal> fornisce metodi di lookup secondo la specifica JNDI/Java EE."

#~ msgid ""
#~ "<![CDATA[\n"
#~ "         public interface ResourceLoader {\n"
#~ "    \n"
#~ "   /**\n"
#~ "    * Creates a class from a given FQCN\n"
#~ "    * \n"
#~ "    * @param name The name of the clsas\n"
#~ "    * @return The class\n"
#~ "    */\n"
#~ "   public Class<?> classForName(String name);\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a resource as a URL by name\n"
#~ "    * \n"
#~ "    * @param name The name of the resource\n"
#~ "    * @return An URL to the resource\n"
#~ "    */\n"
#~ "   public URL getResource(String name);\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets resources as URLs by name\n"
#~ "    * \n"
#~ "    * @param name The name of the resource\n"
#~ "    * @return An iterable reference to the URLS\n"
#~ "    */\n"
#~ "   public Iterable<URL> getResources(String name);\n"
#~ "   \n"
#~ "}\n"
#~ "         ]]>"
#~ msgstr ""
#~ "<![CDATA[\n"
#~ "         public interface ResourceLoader {\n"
#~ "    \n"
#~ "   /**\n"
#~ "    * Creates a class from a given FQCN\n"
#~ "    * \n"
#~ "    * @param name The name of the clsas\n"
#~ "    * @return The class\n"
#~ "    */\n"
#~ "   public Class<?> classForName(String name);\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a resource as a URL by name\n"
#~ "    * \n"
#~ "    * @param name The name of the resource\n"
#~ "    * @return An URL to the resource\n"
#~ "    */\n"
#~ "   public URL getResource(String name);\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets resources as URLs by name\n"
#~ "    * \n"
#~ "    * @param name The name of the resource\n"
#~ "    * @return An iterable reference to the URLS\n"
#~ "    */\n"
#~ "   public Iterable<URL> getResources(String name);\n"
#~ "   \n"
#~ "}\n"
#~ "         ]]>"

#~ msgid "Servlet injection"
#~ msgstr "Iniezione dei servlet"

#~ msgid "Java EE / Servlet does not provide any hooks which can be used to provide injection into Servlets, so Web Beans provides an API to allow the container to request JSR-299 injection for a Servlet."
#~ msgstr "Java EE / Servlet non fornisce alcun hook da usare per fornire l'iniezione nei Servlet, quindi Web Beans fornisce un'API per consentire al container di richiedere l'iniezione JSR-299 per un Servlet."

#~ msgid "To be compliant with JSR-299, the container should request servlet injection for each newly instantiated servlet after the constructor returns and before the servlet is placed into service."
#~ msgstr "Per soddisfare la JSR-299 il container deve richiedere l'iniezione servlet per ogni nuovo servlet istanziato dopo che il costruttore ritorni e prima che il servlet sia messo in servizio."

#~ msgid "To perform injection on a servlet call <literal>WebBeansManager.injectServlet()</literal>. The manager can be obtained from <literal>Bootstrap.getManager()</literal>."
#~ msgstr "Per eseguire l'iniezione su un servlet si chiami <literal>WebBeansManager.injectServlet()</literal>. Il manager può essere ottenuto da <literal>Bootstrap.getManager()</literal>."

#~ msgid "If you are integrating the Web Beans into a JSF environment you must register <literal>org.jboss.webbeans.jsf.WebBeansPhaseListener</literal> as a phase listener, and <literal>org.jboss.webbeans.el.WebBeansELREsolver</literal> as an EL resolver, either automatically, or through user configuration, for each Web Beans application which uses JSF."
#~ msgstr "Se si integra Web Beans in un ambiente JSF occorre registrare <literal>org.jboss.webbeans.jsf.WebBeansPhaseListener</literal> come phase listener, e <literal>org.jboss.webbeans.el.WebBeansELREsolver</literal> come EL resolver, sia automaticamente, o attraverso la configurazione utente, per ogni applicazione Web Beans che usa JSF."

#~ msgid "If you are integrating the Web Beans into an environment that supports deployment of applications, you must insert the <literal>webbeans-core.jar</literal> into the applications isolated classloader. It cannot be loaded from a shared classloader."
#~ msgstr "Se si integra Web Beans in un ambiente che supporta il deploy di applicazioni, occorre inserire <literal>webbeans-core.jar</literal> nel classloader isolato delle applicazioni. Non può essere caricato da un classloader condiviso."

#~ msgid "It should be possible to run Web Beans in an SE environment, but you'll to do more work, adding your own contexts and lifecycle. The Web Beans RI currently doesn't expose lifecycle extension points, so you would have to code directly against Web Beans RI classes."
#~ msgstr "Dovrebbe essere possibile far funzionare Web Beans in un ambiente SE, ma occorre molto lavoro per aggiungere i propri contesti ed il ciclo di vita. Web Beans RI attualmente non espone punti di estensione del ciclo di vita, così occorre codificare direttamente nelle classi Web Beans RI."

#~ msgid "All interfaces in the SPI support the decorator pattern and provide a <literal>Forwarding</literal> class."
#~ msgstr "Tutte le interfacce in SPI supportano il pattern decorator e forniscono una classe <literal>Forwarding</literal>."

#~ msgid ""
#~ "<![CDATA[public interface EjbServices\n"
#~ "{\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a descriptor for each EJB in the application\n"
#~ "    * \n"
#~ "    * @return The bean class to descriptor map \n"
#~ "    */\n"
#~ "   public Iterable<EjbDescriptor<?>> discoverEjbs();]]>"
#~ msgstr ""
#~ "<![CDATA[public interface EjbServices\n"
#~ "{\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a descriptor for each EJB in the application\n"
#~ "    * \n"
#~ "    * @return The bean class to descriptor map \n"
#~ "    */\n"
#~ "   public Iterable<EjbDescriptor<?>> discoverEjbs();]]>"
