# Language pt-BR translations for Introduction_to_Web_Beans package.
# Automatically generated, 2009.
# 
# Bruno Leonardo Gonçalves <brunolmfg@gmail.com>, 2012. #zanata
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2012-01-16T16:07:16\n"
"PO-Revision-Date: 2010-04-14 17:23-0300\n"
"Last-Translator: Bruno Leonardo Gonçalves <brunolmfg@gmail.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: \n"

#. Tag: title
#, no-c-format
msgid "Dependency injection and programmatic lookup"
msgstr "Injeção e pesquisa programática de dependências"

#. Tag: para
#, no-c-format
msgid ""
"One of the most significant features of CDI&mdash;certainly the most "
"recognized&mdash;is dependency injection; excuse me, "
"<emphasis>typesafe</emphasis> dependency injection."
msgstr ""
"Uma das características mais significativas do CDI&mdash;certamente a mais "
"reconhecida&mdash;é injeção de dependência; desculpe-me, injeção de "
"dependência com <emphasis>typesafe</emphasis>."

#. Tag: title
#, no-c-format
msgid "Injection points"
msgstr "Pontos de injeção"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>@Inject</literal> annotation lets us define an injection point "
"that is injected during bean instantiation. Injection can occur via three "
"different mechanisms."
msgstr ""
"A anotação <literal>@Inject</literal> nos permite definir um ponto de "
"injeção que é injetado durante a instanciação do bean. A injeção pode "
"ocorrer por meio de três diferentes mecanismos."

#. Tag: para
#, no-c-format
msgid "<emphasis>Bean constructor</emphasis> parameter injection:"
msgstr "Injeção por parâmetro no <emphasis>construtor do bean</emphasis>:"

#. Tag: programlisting
#, no-c-format
msgid ""
"public class Checkout {\n"
"        \n"
"   private final ShoppingCart cart;\n"
"    \n"
"   @Inject\n"
"   public Checkout(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"\n"
"}"
msgstr ""
"public class Checkout {\n"
"        \n"
"   private final ShoppingCart cart;\n"
"    \n"
"   @Inject\n"
"   public Checkout(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"\n"
"}"

#. Tag: para
#, no-c-format
msgid "A bean can only have one injectable constructor."
msgstr "Um bean pode possuir somente um construtor injetável."

#. Tag: para
#, no-c-format
msgid "<emphasis>Initializer method</emphasis> parameter injection:"
msgstr "Injeção por parâmetro em <emphasis>método inicializador</emphasis>:"

#. Tag: programlisting
#, no-c-format
msgid ""
"public class Checkout {\n"
"        \n"
"   private ShoppingCart cart;\n"
"\n"
"   @Inject\n"
"   void setShoppingCart(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"    \n"
"}"
msgstr ""
"public class Checkout {\n"
"        \n"
"   private ShoppingCart cart;\n"
"\n"
"   @Inject\n"
"   void setShoppingCart(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"    \n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"A bean can have multiple initializer methods. If the bean is a session bean,"
" the initializer method is not required to be a business method of the "
"session bean."
msgstr ""
"Um bean pode possuir múltiplos métodos inicializadores. Se o bean é um "
"session bean, o método inicializador não é necessário ser um método de "
"negócio do session bean."

#. Tag: para
#, no-c-format
msgid "And direct field injection:"
msgstr "E injeção direta de campos:"

#. Tag: programlisting
#, no-c-format
msgid ""
"public class Checkout {\n"
"\n"
"   private @Inject ShoppingCart cart;\n"
"    \n"
"}"
msgstr ""
"public class Checkout {\n"
"\n"
"   private @Inject ShoppingCart cart;\n"
"    \n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"Getter and setter methods are not required for field injection to work "
"(unlike with JSF managed beans)."
msgstr ""
"Métodos getter e setter não são necessários para injeção em campo funcionar "
"(exceto com managed beans do JSF)."

#. Tag: para
#, no-c-format
msgid ""
"Dependency injection always occurs when the bean instance is first "
"instantiated by the container. Simplifying just a little, things happen in "
"this order:"
msgstr ""
"A injeção de dependências sempre ocorre quando a instância do bean é "
"instanciada pela primeira vez no contêiner. Simplificando um pouco, as "
"coisas acontecem nesta ordem:"

#. Tag: para
#, no-c-format
msgid ""
"First, the container calls the bean constructor (the default constructor or "
"the one annotated <literal>@Inject</literal>), to obtain an instance of the "
"bean."
msgstr ""
"Em primeiro lugar, o contêiner chama o construtor do bean (o construtor "
"padrão ou um anotado com <literal>@Inject</literal>) para obter uma "
"instância do bean."

#. Tag: para
#, no-c-format
msgid ""
"Next, the container initializes the values of all injected fields of the "
"bean."
msgstr ""
"Em seguida, o contêiner inicializa os valores de todos os campos injetados "
"do bean."

#. Tag: para
#, no-c-format
msgid ""
"Next, the container calls all initializer methods of bean (the call order is"
" not portable, don't rely on it)."
msgstr ""
"Em seguida, o contêiner chama todos os métodos inicializadores do bean (a "
"ordem de chamada não é portável, não confie nela)."

#. Tag: para
#, no-c-format
msgid ""
"Finally, the <literal>@PostConstruct</literal> method, if any, is called."
msgstr ""
"Finalmente, o método <literal>@PostConstruct</literal>, se for o caso, é "
"chamado."

#. Tag: para
#, no-c-format
msgid ""
"(The only complication is that the container might call initializer methods "
"declared by a superclass before initializing injected fields declared by a "
"subclass.)"
msgstr ""
"(A única complicação é que o contêiner pode chamar métodos inicializadores "
"declarados por uma superclasse antes de inicializar campos injetados "
"declarados por uma subclasse.)"

#. Tag: para
#, no-c-format
msgid ""
"One major advantage of constructor injection is that it allows the bean to "
"be immutable."
msgstr ""
"Uma grande vantagem de injeção em construtores é que isto nos permite que o "
"bean seja imutável."

#. Tag: para
#, no-c-format
msgid ""
"CDI also supports parameter injection for some other methods that are "
"invoked by the container. For instance, parameter injection is supported for"
" producer methods:"
msgstr ""
"CDI também suporta injeção de parâmetro para alguns outros métodos que são "
"invocados pelo contêiner. Por exemplo, a injeção de parâmetro é suportada em"
" métodos produtores:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}"
msgstr ""
"@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"This is a case where the <literal>@Inject</literal> annotation <emphasis>is "
"not</emphasis> required at the injection point. The same is true for "
"observer methods (which we'll meet in <xref linkend=\"events\" />) and "
"disposer methods."
msgstr ""
"Este é um caso onde a anotação <literal>@Inject</literal> <emphasis>não "
"é</emphasis> necessária no ponto de injeção. O mesmo é verdade para métodos "
"observadores (os quais encontraremos no <xref linkend=\"events\" />) e "
"métodos destruidores."

#. Tag: title
#, no-c-format
msgid "What gets injected"
msgstr "Como as injeções são obtidas"

#. Tag: para
#, no-c-format
msgid ""
"The CDI specification defines a procedure, called <emphasis>typesafe "
"resolution</emphasis>, that the container follows when identifying the bean "
"to inject to an injection point. This algorithm looks complex at first, but "
"once you understand it, it's really quite intuitive. Typesafe resolution is "
"performed at system initialization time, which means that the container will"
" inform the developer immediately if a bean's dependencies cannot be "
"satisfied."
msgstr ""
"A especificação CDI define um procedimento, chamado de <emphasis>resolução "
"segura de tipos</emphasis>, que o contêiner segue ao indentificar o bean a "
"ser injetado em um ponto de injeção. Este algoritmo parece complexo no "
"início, mas uma vez quq você o entende, é realmente muito intuitivo. A "
"resolução segura de tipos é realizada durante a inicialização do sistema, o "
"que significa que o contêiner informará ao desenvolvedor imediatamente se "
"alguma das dependências de um bean não puder ser satisfeita."

#. Tag: para
#, no-c-format
msgid ""
"The purpose of this algorithm is to allow multiple beans to implement the "
"same bean type and either:"
msgstr ""
"O objetivo deste algoritmo é permitir que múltiplos beans implementem o "
"mesmo tipo de bean e também:"

#. Tag: para
#, no-c-format
msgid ""
"allow the client to select which implementation it requires using a "
"<emphasis>qualifier</emphasis> or"
msgstr ""
"permitir que o cliente escolha qual implementação ele necessita utilizando "
"um <emphasis>qualificador</emphasis> ou"

#. Tag: para
#, no-c-format
msgid ""
"allow the application deployer to select which implementation is appropriate"
" for a particular deployment, without changes to the client, by enabling or "
"disabling an <emphasis>alternative</emphasis>, or"
msgstr ""
"permitir ao implantador (deployer) da aplicação escolher qual implentação é "
"adequada para uma determinada implantação, sem alterações para o cliente, ao"
" ativar ou desativar um <emphasis>alternativo</emphasis>, ou"

#. Tag: para
#, no-c-format
msgid "allow the beans to be isolated into separate modules."
msgstr "permitir que os beans sejam isolados dentro de módulos separados."

#. Tag: para
#, no-c-format
msgid ""
"Obviously, if you have exactly one bean of a given type, and an injection "
"point with that same type, then bean A is going to go into slot A. That's "
"the simplest possible scenario. When you first start your application, "
"you'll likely have lots of those."
msgstr ""
"Obviamente, se você possui exatamente um bean de um dado tipo, e um ponto de"
" injeção com este mesmo tipo, então o bean A irá para onde pedir um A. Este "
"é o cenário mais simples possível. Quando você começar sua aplicação, você "
"terá provavelmente vários desses."

#. Tag: para
#, no-c-format
msgid ""
"But then, things start to get complicated. Let's explore how the container "
"determines which bean to inject in more advanced cases. We'll start by "
"taking a closer look at qualifiers."
msgstr ""
"Mas então, as coisas começam a ficar complicadas. Vamos explorar como o "
"contêiner determina qual bean injetar em casos mais avançados. Nós "
"iniciaremos dando um olhar mais atento em qualificadores."

#. Tag: title
#, no-c-format
msgid "Qualifier annotations"
msgstr "Anotações de qualificadores"

#. Tag: para
#, no-c-format
msgid ""
"If we have more than one bean that implements a particular bean type, the "
"injection point can specify exactly which bean should be injected using a "
"qualifier annotation. For example, there might be two implementations of "
"<literal>PaymentProcessor</literal>:"
msgstr ""
"Se temos mais do que um bean que implementa um tipo de bean específico, o "
"ponto de injeção pode especificar exatamente qual bean deve ser injetado "
"usando uma anotação de qualificador. Por exemplo, pode haver duas "
"implementações de <literal>PaymentProcessor</literal>:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Synchronous\n"
"public class SynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"@Synchronous\n"
"public class SynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Asynchronous\n"
"public class AsynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"@Asynchronous\n"
"public class AsynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"Where <literal>@Synchronous</literal> and <literal>@Asynchronous</literal> "
"are qualifier annotations:"
msgstr ""
"Onde <literal>@Synchronous</literal> e <literal>@Asynchronous</literal> são "
"anotações de qualificadores:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Synchronous {}"
msgstr ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Synchronous {}"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Asynchronous {}"
msgstr ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Asynchronous {}"

#. Tag: para
#, no-c-format
msgid ""
"A client bean developer uses the qualifier annotation to specify exactly "
"which bean should be injected."
msgstr ""
"Um desenvolvedor de um bean cliente utiliza a anotação de qualificador para "
"especificar exatamente qual bean deve ser injetado."

#. Tag: para
#, no-c-format
msgid "Using field injection:"
msgstr "Utilizando injeção por campos (field injection):"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject @Synchronous PaymentProcessor syncPaymentProcessor;\n"
"@Inject @Asynchronous PaymentProcessor asyncPaymentProcessor;"
msgstr ""
"@Inject @Synchronous PaymentProcessor syncPaymentProcessor;\n"
"@Inject @Asynchronous PaymentProcessor asyncPaymentProcessor;"

#. Tag: para
#, no-c-format
msgid "Using initializer method injection:"
msgstr "Utilizando injeção de método de inicialização:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject\n"
"public void setPaymentProcessors(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                                 @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"
msgstr ""
"@Inject\n"
"public void setPaymentProcessors(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                                 @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"

#. Tag: para
#, no-c-format
msgid "Using constructor injection:"
msgstr "Usando injeção no construtor:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject\n"
"public Checkout(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"
msgstr ""
"@Inject\n"
"public Checkout(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"Qualifier annotations can also qualify method arguments of producer, "
"disposer and observer methods. Combining qualified arguments with producer "
"methods is a good way to have an implementation of a bean type selected at "
"runtime based on the state of the system:"
msgstr ""
"Anotações de qualificadores podem também qualificar argumentos de métodos "
"produtores, destruidores ou observadores. Combinar argumentos qualificados "
"com métodos produtores é uma boa forma para ter uma implementação de um tipo"
" de bean selecionado em tempo de execução com base no estado do sistema:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Produces\n"
"PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor syncPaymentProcessor,\n"
"                                     @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   return isSynchronous() ? syncPaymentProcessor : asyncPaymentProcessor;\n"
"}"
msgstr ""
"@Produces\n"
"PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor syncPaymentProcessor,\n"
"                                     @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   return isSynchronous() ? syncPaymentProcessor : asyncPaymentProcessor;\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"If an injected field or a parameter of a bean constructor or initializer "
"method is not explicitly annotated with a qualifier, the default qualifier, "
"<literal>@Default</literal>, is assumed."
msgstr ""
"Se um campo injetado ou um parâmetro de um construtor de bean ou método "
"inicializador não é explicitamente anotado com um qualificador, o "
"qualificador padrão, <literal>@Default</literal>, é assumido."

#. Tag: para
#, no-c-format
msgid ""
"Now, you may be thinking, <emphasis>\"What's the different between using a "
"qualifier and just specifying the exact implementation class you "
"want?\"</emphasis> It's important to understand that a qualifier is like an "
"extension of the interface. It does not create a direct dependency to any "
"particular implementation. There may be multiple alternative implementations"
" of <literal>@Asynchronous PaymentProcessor</literal>!"
msgstr ""
"Agora, você pode estar pensando, <emphasis>\"Qual a diferença entre usar um "
"qualificador e apenas especificar a exata classe de implementação que você "
"deseja?\"</emphasis> É importante entender que um qualificador é como uma "
"extensão da interface. Ele não cria uma dependência direta para qualquer "
"implementação em particular. Podem existir várias implementações "
"alternativas de <literal>@Asynchronous PaymentProcessor</literal>!"

#. Tag: title
#, no-c-format
msgid ""
"The built-in qualifiers <literal>@Default</literal> and "
"<literal>@Any</literal>"
msgstr ""
"Os qualificadores embutidos <literal>@Default</literal> e "
"<literal>@Any</literal>"

#. Tag: para
#, no-c-format
msgid ""
"Whenever a bean or injection point does not explicitly declare a qualifier, "
"the container assumes the qualifier <literal>@Default</literal>. From time "
"to time, you'll need to declare an injection point without specifying a "
"qualifier. There's a qualifier for that too. All beans have the qualifier "
"<literal>@Any</literal>. Therefore, by explicitly specifying "
"<literal>@Any</literal> at an injection point, you suppress the default "
"qualifier, without otherwise restricting the beans that are eligible for "
"injection."
msgstr ""
"Sempre que um bean ou ponto de injeção não declara explicitamente um "
"qualificador, o contêiner assume o qualificador <literal>@Default</literal>."
" Em algum momento, você precisará declarar um ponto de injeção sem "
"especificar um qualificador. Existe um qualificador para isso também. Todos "
"os beans possuem o qualificador <literal>@Any</literal>. Portanto, ao "
"especificar explicitamente <literal>@Any</literal> em um ponto de injeção, "
"você suprime o qualificador padrão, sem restringir os beans que são "
"elegíveis para injeção."

#. Tag: para
#, no-c-format
msgid ""
"This is especially useful if you want to iterate over all beans with a "
"certain bean type. For example:"
msgstr ""
"Isto é especialmente útil se você quiser iterar sobre todos os beans com um "
"certo tipo de bean. Por exemplo:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject \n"
"void initServices(@Any Instance&lt;Service&gt; services) { \n"
"   for (Service service: services) {\n"
"      service.init();\n"
"   }\n"
"}"
msgstr ""
"@Inject \n"
"void initServices(@Any Instance&lt;Service&gt; services) { \n"
"   for (Service service: services) {\n"
"      service.init();\n"
"   }\n"
"}"

#. Tag: title
#, no-c-format
msgid "Qualifiers with members"
msgstr "Qualificadores com membros"

#. Tag: para
#, no-c-format
msgid ""
"Java annotations can have members. We can use annotation members to further "
"discriminate a qualifier. This prevents a potential explosion of new "
"annotations. For example, instead of creating several qualifiers "
"representing different payment methods, we could aggregate them into a "
"single annotation with a member:"
msgstr ""
"As anotações Java podem possuir membros. Podemos usar membros de anotação "
"para discriminar melhor um qualificador. Isso impede uma potencial explosão "
"de novas anotações. Por exemplo, em vez de criar vários qualificadores "
"representando diferentes métodos de pagamento, podemos agregá-los em uma "
"única anotação com um membro:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"}"
msgstr ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"Then we select one of the possible member values when applying the "
"qualifier:"
msgstr ""
"Então selecionamos um dos possíveis valores do membro ao aplicar o "
"qualificador:"

#. Tag: programlisting
#, no-c-format
msgid "private @Inject @PayBy(CHECK) PaymentProcessor checkPayment;"
msgstr "private @Inject @PayBy(CHECK) PaymentProcessor checkPayment;"

#. Tag: para
#, no-c-format
msgid ""
"We can force the container to ignore a member of a qualifier type by "
"annotating the member <literal>@Nonbinding</literal>."
msgstr ""
"Podemos forçar o contêiner a ignorar um membro de um tipo de qualificador ao"
" anotar o membro com <literal>@Nonbinding</literal>."

#. Tag: programlisting
#, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"   @Nonbinding String comment() default \"\";\n"
"}"
msgstr ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"   @Nonbinding String comment() default \"\";\n"
"}"

#. Tag: title
#, no-c-format
msgid "Multiple qualifiers"
msgstr "Múltiplos qualificadores"

#. Tag: para
#, no-c-format
msgid "An injection point may specify multiple qualifiers:"
msgstr "Um ponto de injeção pode especificar múltiplos qualificadores:"

#. Tag: programlisting
#, no-c-format
msgid "@Inject @Synchronous @Reliable PaymentProcessor syncPaymentProcessor;"
msgstr "@Inject @Synchronous @Reliable PaymentProcessor syncPaymentProcessor;"

#. Tag: para
#, no-c-format
msgid ""
"Then only a bean which has <emphasis>both</emphasis> qualifier annotations "
"would be eligible for injection."
msgstr ""
"Neste caso, somente um bean que possua <emphasis>ambas</emphasis> anotações "
"de qualificador seriam elegíveis para injeção."

#. Tag: programlisting
#, no-c-format
msgid ""
"@Synchronous @Reliable\n"
"public class SynchronousReliablePaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"@Synchronous @Reliable\n"
"public class SynchronousReliablePaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"

#. Tag: title
#, no-c-format
msgid "Alternatives"
msgstr "Alternativos"

#. Tag: para
#, no-c-format
msgid ""
"Alternatives are beans whose implementation is specific to a particular "
"client module or deployment scenario. This alternative defines a mock "
"implementation of both <literal>@Synchronous PaymentProcessor</literal> and "
"<literal>@Asynchronous PaymentProcessor</literal>, all in one:"
msgstr ""
"Os alternativos são beans cuja implementação é específica para um módulo "
"cliente ou cenário de implantação específico. Este alternativo define uma "
"implementação simulada de <literal>@Synchronous PaymentProcessor</literal> e"
" <literal>@Asynchronous PaymentProcessor</literal>, tudo em um:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Alternative @Synchronous @Asynchronous\n"
"public class MockPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"@Alternative @Synchronous @Asynchronous\n"
"public class MockPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"By default, <literal>@Alternative</literal> beans are disabled. We need to "
"<emphasis>enable</emphasis> an alternative in the "
"<literal>beans.xml</literal> descriptor of a bean archive to make it "
"available for instantiation and injection. This activation only applies to "
"the beans in that archive."
msgstr ""
"Por padrão, os beans com <literal>@Alternative</literal> estão "
"desabilitados. Precisamos <emphasis>habilitar</emphasis> um alternativo no "
"descritor <literal>beans.xml</literal> de um arquivo de bean para torná-lo "
"disponível para instanciação e injeção. Esta ativação somente se aplica aos "
"beans neste arquivo."

#. Tag: programlisting
#, no-c-format
msgid ""
"&lt;beans\n"
"   xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"   xsi:schemaLocation=\"\n"
"      http://java.sun.com/xml/ns/javaee\n"
"      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd\"&gt;\n"
"   &lt;alternatives&gt;\n"
"         &lt;class&gt;org.mycompany.mock.MockPaymentProcessor&lt;/class&gt;\n"
"   &lt;/alternatives&gt;\n"
"&lt;/beans&gt;"
msgstr ""
"&lt;beans\n"
"   xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"   xsi:schemaLocation=\"\n"
"      http://java.sun.com/xml/ns/javaee\n"
"      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd\"&gt;\n"
"   &lt;alternatives&gt;\n"
"         &lt;class&gt;org.mycompany.mock.MockPaymentProcessor&lt;/class&gt;\n"
"   &lt;/alternatives&gt;\n"
"&lt;/beans&gt;"

#. Tag: para
#, no-c-format
msgid ""
"When an ambiguous dependency exists at an injection point, the container "
"attempts to resolve the ambiguity by looking for an enabled alternative "
"among the beans that could be injected. If there is exactly one enabled "
"alternative, that's the bean that will be injected."
msgstr ""
"Quando uma dependência ambígua houver em um ponto de injeção, o contêiner "
"tenta resolver a ambiguidade procurando por um bean alternativo habilitado "
"entre os beans que podem ser injetados. Se existir exatamente um alternativo"
" habilitado, este será o bean a ser injetado."

#. Tag: title
#, no-c-format
msgid "Fixing unsatisfied and ambiguous dependencies"
msgstr "Corrigindo dependências não satisfeitas e ambíguas"

#. Tag: para
#, no-c-format
msgid ""
"The typesafe resolution algorithm fails when, after considering the "
"qualifier annotations on all beans that implement the bean type of an "
"injection point and filtering out disabled beans "
"(<literal>@Alternative</literal> beans which are not explicitly enabled), "
"the container is unable to identify exactly one bean to inject. The "
"container will abort deployment, informing us of the unsatisfied or "
"ambiguous dependency."
msgstr ""
"O algoritmo de resolução segura de tipos falha quando, após considerar as "
"anotações de qualificadores em todos os beans que implementam o tipo de bean"
" de um ponto de injeção e filtrar os beans desabilitados (beans com "
"<literal>@Alternative</literal> que não estão explicitamente habilitados), o"
" contêiner não é capaz de identificar exatamente um bean para injetar. O "
"contêiner abortará a implantação, nos informando sobre as dependências não "
"satisfeitas ou ambíguas."

#. Tag: para
#, no-c-format
msgid ""
"During the course of your development, you're going to encounter this "
"situation. Let's learn how to resolve it."
msgstr ""
"Durante o progresso de seu desenvolvimento, você vai encontrar essa "
"situação. Vamos aprender como resolvê-la."

#. Tag: para
#, no-c-format
msgid "To fix an <emphasis>unsatisfied dependency</emphasis>, either:"
msgstr "Para corrigir uma <emphasis>dependência não satisfeita</emphasis>:"

#. Tag: para
#, no-c-format
msgid ""
"create a bean which implements the bean type and has all the qualifier types"
" of the injection point,"
msgstr ""
"crie um bean que implemente o tipo de bean e possua todos os tipos de "
"qualificador do ponto de injeção,"

#. Tag: para
#, no-c-format
msgid ""
"make sure that the bean you already have is in the classpath of the module "
"with the injection point, or"
msgstr ""
"certifique-se que o bean que você já possui esteja no classpath do módulo "
"com o ponto de injeção, ou"

#. Tag: para
#, no-c-format
msgid ""
"explicitly enable an <literal>@Alternative</literal> bean that implements "
"the bean type and has the appropriate qualifier types, using "
"<literal>beans.xml</literal>."
msgstr ""
"habilite explicitamente um bean <literal>@Alternative</literal> que "
"implemente o tipo de bean e possua os tipos de qualificador apropriados, "
"usando <literal>beans.xml</literal>."

#. Tag: para
#, no-c-format
msgid "To fix an <emphasis>ambiguous dependency</emphasis>, either:"
msgstr "Para corrigir uma <emphasis>dependência ambígua</emphasis>:"

#. Tag: para
#, no-c-format
msgid ""
"introduce a qualifier to distinguish between the two implementations of the "
"bean type,"
msgstr ""
"introduza um qualificador para distinguir entre as duas implementações do "
"tipo de bean,"

#. Tag: para
#, no-c-format
msgid ""
"disable one of the beans by annotating it <literal>@Alternative</literal>,"
msgstr ""
"desabilite um dos beans anotando-o com <literal>@Alternative</literal>,"

#. Tag: para
#, no-c-format
msgid ""
"move one of the implementations to a module that is not in the classpath of "
"the module with the injection point, or"
msgstr ""
"mova uma das implementações para um módulo que não está no classpath do "
"módulo com o ponto de injeção, ou"

#. Tag: para
#, no-c-format
msgid ""
"disable one of two <literal>@Alternative</literal> beans that are trying to "
"occupy the same space, using <literal>beans.xml</literal>."
msgstr ""
"desabilite um dos beans <literal>@Alternative</literal> que estão tentando "
"ocupar o mesmo espaço, usando <literal>beans.xml</literal>."

#. Tag: para
#, no-c-format
msgid ""
"See <ulink "
"url=\"http://sfwk.org/Documentation/HowDoAResolveAnAmbiguousResolutionExceptionBetweenAProducerMethodAndARawType\">this"
" FAQ</ulink> for step-by-step instructions for how to resolve an ambiguous "
"resolution exception between a raw bean type and a producer method that "
"returns the same bean type."
msgstr ""
"Veja <ulink "
"url=\"http://sfwk.org/Documentation/HowDoAResolveAnAmbiguousResolutionExceptionBetweenAProducerMethodAndARawType\">este"
" FAQ</ulink> para instruções passo-a-passo de como resolver uma exceção de "
"resolução ambígua entre um tipo de bean e um método produtor que retorna o "
"mesmo tipo de bean."

#. Tag: para
#, no-c-format
msgid "Just remember: \"There can be only one.\""
msgstr "Apenas lembre-se: \"Só pode haver um.\""

#. Tag: para
#, no-c-format
msgid ""
"On the other hand, if you really do have an optional or multivalued "
"injection point, you should change the type of your injection point to "
"<literal>Instance</literal>, as we'll see in <xref linkend=\"lookup\" />."
msgstr ""
"Por outro lado, se você realmente tem um ponto de injeção opcional ou "
"multivalorado, você deveria mudar o tipo de seu ponto de injeção para "
"<literal>Instance</literal>, como veremos na <xref linkend=\"lookup\" />."

#. Tag: para
#, no-c-format
msgid ""
"Now there's one more issue you need to be aware of when using the dependency"
" injection service."
msgstr ""
"Agora há mais uma questão que você precisa estar ciente quando usar o "
"serviço de injeção de dependência."

#. Tag: title
#, no-c-format
msgid "Client proxies"
msgstr "Proxies clientes"

#. Tag: para
#, no-c-format
msgid ""
"Clients of an injected bean do not usually hold a direct reference to a bean"
" instance, unless the bean is a dependent object (scope "
"<literal>@Dependent</literal>)."
msgstr ""
"Os clientes de um bean injetado não costumam manter uma referência direta "
"para uma instância do bean, a menos que o bean seja um objeto dependente "
"(com escopo <literal>@Dependent</literal>)."

#. Tag: para
#, no-c-format
msgid ""
"Imagine that a bean bound to the application scope held a direct reference "
"to a bean bound to the request scope. The application-scoped bean is shared "
"between many different requests. However, each request should see a "
"different instance of the request scoped bean&mdash;the current one!"
msgstr ""
"Imagine que um bean vinculado ao escopo da aplicação mantenha uma referência"
" direta para um bean vinculado ao escopo da solicitação. O bean com escopo "
"de aplicação é compatilhado entre várias solicitações diferentes. No "
"entanto, cada solicitação deverá ver uma instância diferente do bean com "
"escopo de solicitação&mdash;a atual!"

#. Tag: para
#, no-c-format
msgid ""
"Now imagine that a bean bound to the session scope holds a direct reference "
"to a bean bound to the application scope. From time to time, the session "
"context is serialized to disk in order to use memory more efficiently. "
"However, the application scoped bean instance should not be serialized along"
" with the session scoped bean! It can get that reference any time. No need "
"to hoard it!"
msgstr ""
"Agora imagine que um bean vinculado ao escopo da sessão mantenha uma "
"referência direta para um bean vinculado ao escopo da aplicação. Em algum "
"momento, o contexto da sessão é serializado para o disco, a fim de usar a "
"memória de forma mais eficiente. No entanto, a instância do bean com escopo "
"de aplicação não deve ser serializado junto com o bean de escopo de sessão! "
"Ele pode obter esta referência a qualquer momento. Não há necessidade de "
"armazená-lo!"

#. Tag: para
#, no-c-format
msgid ""
"Therefore, unless a bean has the default scope "
"<literal>@Dependent</literal>, the container must indirect all injected "
"references to the bean through a proxy object. This <emphasis>client "
"proxy</emphasis> is responsible for ensuring that the bean instance that "
"receives a method invocation is the instance that is associated with the "
"current context. The client proxy also allows beans bound to contexts such "
"as the session context to be serialized to disk without recursively "
"serializing other injected beans."
msgstr ""
"Portanto, a menos que um bean possua o escopo padrão "
"<literal>@Dependent</literal>, o contêiner deve injetar indiretamente todas "
"as referências para o bean através de um objeto proxy. Este <emphasis>proxy "
"cliente</emphasis> é responsável por assegurar que a instância do bean que "
"recebe uma invocação de método seja a instância que está associada ao "
"contexto atual. O proxy cliente também permite que beans vinculados a "
"contextos, como o contexto de sessão, sejam serializados para o disco sem "
"serializar recursivamente outros beans injetados."

#. Tag: para
#, no-c-format
msgid ""
"Unfortunately, due to limitations of the Java language, some Java types "
"cannot be proxied by the container. If an injection point declared with one "
"of these types resolves to a bean with any scope other than "
"<literal>@Dependent</literal>, the container will abort deployment, "
"informing us of the problem."
msgstr ""
"Infelizmente, devido às limitações da linguagem Java, alguns tipos Java não "
"podem ser feitos proxies pelo contêiner. Se um ponto de injeção declarado "
"com um destes tipos referencia um bean com qualquer escopo diferente de "
"<literal>@Dependent</literal>, o contêiner abortará a implantação, nos "
"informando sobre o problema."

#. Tag: para
#, no-c-format
msgid "The following Java types cannot be proxied by the container:"
msgstr "Os seguintes tipos Java não podem ser \"proxied\" pelo contêiner:"

#. Tag: para
#, no-c-format
msgid ""
"classes which don't have a non-private constructor with no parameters, and"
msgstr "classes que não possuem um construtor não privado sem parâmetros, e"

#. Tag: para
#, no-c-format
msgid ""
"classes which are declared <literal>final</literal> or have a "
"<literal>final</literal> method,"
msgstr ""
"classes que são declaradas <literal>final</literal> ou que tenham um método "
"<literal>final</literal>,"

#. Tag: para
#, no-c-format
msgid "arrays and primitive types."
msgstr "arrays e tipos primitivos."

#. Tag: para
#, no-c-format
msgid ""
"It's usually very easy to fix an unproxyable dependency problem. If an "
"injection point of type <literal>X</literal> results in an unproxyable "
"dependency, simply:"
msgstr ""
"Geralmente é muito fácil de corrigir um problema de dependência com proxies."
" Se um ponto de injeção do tipo <literal>X</literal> resulta em uma "
"dependência que não pode ser feito um proxy, simplesmente:"

#. Tag: para
#, no-c-format
msgid "add a constructor with no parameters to <literal>X</literal>,"
msgstr "adicione um construtor sem parâmetros em <literal>X</literal>,"

#. Tag: para
#, no-c-format
msgid ""
"change the type of the injection point to "
"<literal>Instance&lt;X&gt;</literal>,"
msgstr ""
"modifique o tipo do ponto de injeção para "
"<literal>Instance&lt;X&gt;</literal>,"

#. Tag: para
#, no-c-format
msgid ""
"introduce an interface <literal>Y</literal>, implemented by the injected "
"bean, and change the type of the injection point to <literal>Y</literal>, or"
msgstr ""
"introduza uma interface <literal>Y</literal>, implementada pelo bean "
"injetado, e mude o tipo do ponto de injeção para <literal>Y</literal>, ou"

#. Tag: para
#, no-c-format
msgid ""
"if all else fails, change the scope of the injected bean to "
"<literal>@Dependent</literal>."
msgstr ""
"se tudo isso falhar, mude o escopo do bean a injetar para "
"<literal>@Dependent</literal>."

#. Tag: para
#, no-c-format
msgid ""
"A future release of Weld will likely support a non-standard workaround for "
"this limitation, using non-portable JVM APIs:"
msgstr ""
"Uma versão futura do Weld provavelmente suportará uma solução não padrão "
"para esta limitação, usando APIs não portáveis da JVM:"

#. Tag: para
#, no-c-format
msgid ""
"Sun, IcedTea, Mac: <literal>Unsafe.allocateInstance()</literal> (The most "
"efficient)"
msgstr ""
"Sun, IcedTea, Mac: <literal>Unsafe.allocateInstance()</literal> (A mais "
"eficiente)"

#. Tag: para
#, no-c-format
msgid ""
"IBM, JRockit: "
"<literal>ReflectionFactory.newConstructorForSerialization()</literal>"
msgstr ""
"IBM, JRockit: "
"<literal>ReflectionFactory.newConstructorForSerialization()</literal>"

#. Tag: para
#, no-c-format
msgid "But we didn't get around to implementing this yet."
msgstr "Mas não somos obrigados a implementar isto ainda."

#. Tag: title
#, no-c-format
msgid "Obtaining a contextual instance by programmatic lookup"
msgstr "Obtendo uma instância contextual através de pesquisa programática"

#. Tag: para
#, no-c-format
msgid ""
"In certain situations, injection is not the most convenient way to obtain a "
"contextual reference. For example, it may not be used when:"
msgstr ""
"Em certas situações, injeção não é o meio mais conveniente de obter uma "
"referência contextual. Por exemplo, não pode ser usada quando:"

#. Tag: para
#, no-c-format
msgid "the bean type or qualifiers vary dynamically at runtime, or"
msgstr ""
"o tipo do bean ou qualificadores variam dinamicamente em tempo de execução, "
"ou"

#. Tag: para
#, no-c-format
msgid ""
"depending upon the deployment, there may be no bean which satisfies the type"
" and qualifiers, or"
msgstr ""
"dependendo da implantação, pode haver nenhum bean que satisfaça o tipo e "
"qualificadores, ou"

#. Tag: para
#, no-c-format
msgid "we would like to iterate over all beans of a certain type."
msgstr ""
"gostaríamos de realizar uma iteração sobre todos os beans de um certo tipo."

#. Tag: para
#, no-c-format
msgid ""
"In these situations, the application may obtain an instance of the interface"
" <literal>Instance</literal>, parameterized for the bean type, by injection:"
msgstr ""
"Nestas situações, a aplicação pode obter uma instância da interface "
"<literal>Instance</literal>, parametrizada para o tipo do bean, por injeção:"

#. Tag: programlisting
#, no-c-format
msgid "@Inject Instance&lt;PaymentProcessor&gt; paymentProcessorSource;"
msgstr "@Inject Instance&lt;PaymentProcessor&gt; paymentProcessorSource;"

#. Tag: para
#, no-c-format
msgid ""
"The <literal>get()</literal> method of <literal>Instance</literal> produces "
"a contextual instance of the bean."
msgstr ""
"O método <literal>get()</literal> de <literal>Instance</literal> produz uma "
"instância contextual do bean."

#. Tag: programlisting
#, no-c-format
msgid "PaymentProcessor p = paymentProcessorSource.get();"
msgstr "PaymentProcessor p = paymentProcessorSource.get();"

#. Tag: para
#, no-c-format
msgid "Qualifiers can be specified in one of two ways:"
msgstr "Qualificadores podem ser especificados em uma de duas maneiras:"

#. Tag: para
#, no-c-format
msgid "by annotating the <literal>Instance</literal> injection point, or"
msgstr "anotando o ponto de injeção <literal>Instance</literal>, ou"

#. Tag: para
#, no-c-format
msgid ""
"by passing qualifiers to the <literal>select()</literal> of "
"<literal>Event</literal>."
msgstr ""
"passando qualificadores para o método <literal>select()</literal> de "
"<literal>Event</literal>."

#. Tag: para
#, no-c-format
msgid "Specifying the qualifiers at the injection point is much, much easier:"
msgstr ""
"Especificar os qualificadores no ponto de injeção é muito, muito mais fácil:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject @Asynchronous Instance&lt;PaymentProcessor&gt; "
"paymentProcessorSource;"
msgstr ""
"@Inject @Asynchronous Instance&lt;PaymentProcessor&gt; "
"paymentProcessorSource;"

#. Tag: para
#, no-c-format
msgid ""
"Now, the <literal>PaymentProcessor</literal> returned by "
"<literal>get()</literal> will have the qualifier "
"<literal>@Asynchronous</literal>."
msgstr ""
"Agora, o <literal>PaymentProcessor</literal> retornado por "
"<literal>get()</literal> terá o qualificador "
"<literal>@Asynchronous</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Alternatively, we can specify the qualifier dynamically. First, we add the "
"<literal>@Any</literal> qualifier to the injection point, to suppress the "
"default qualifier. (All beans have the qualifier <literal>@Any</literal>.)"
msgstr ""
"Alternativamente, podemos especificar o qualificador dinamicamente. "
"Primeiro, adicionamos o qualificador <literal>@Any</literal> no ponto de "
"injeção, para suprimir o qualificador padrão. (Todos os beans possuem o "
"qualificador <literal>@Any</literal>.)"

#. Tag: programlisting
#, no-c-format
msgid "@Inject @Any Instance&lt;PaymentProcessor&gt; paymentProcessorSource;"
msgstr "@Inject @Any Instance&lt;PaymentProcessor&gt; paymentProcessorSource;"

#. Tag: para
#, no-c-format
msgid ""
"Next, we need to obtain an instance of our qualifier type. Since annotations"
" are interfaces, we can't just write <literal>new Asynchronous()</literal>. "
"It's also quite tedious to create a concrete implementation of an annotation"
" type from scratch. Instead, CDI lets us obtain a qualifier instance by "
"subclassing the helper class <literal>AnnotationLiteral</literal>."
msgstr ""
"Em seguida, precisamos obter uma instância de nosso tipo de qualificador. "
"Uma vez que anotações são interfaces, não podemos apenas escrever "
"<literal>new Asynchronous()</literal>. Também é bastante tedioso criar uma "
"implementação concreta de um tipo de anotação a partir do zero. Em vez "
"disso, o CDI nos permite obter uma instância do qualificador criando uma "
"subclasse da classe auxiliar <literal>AnnotationLiteral</literal>."

#. Tag: programlisting
#, no-c-format
msgid ""
"abstract class AsynchronousQualifier\n"
"extends AnnotationLiteral&lt;Asynchronous&gt; implements Asynchronous {}"
msgstr ""
"abstract class AsynchronousQualifier\n"
"extends AnnotationLiteral&lt;Asynchronous&gt; implements Asynchronous {}"

#. Tag: para
#, no-c-format
msgid "In some cases, we can use an anonymous class:"
msgstr "E alguns casos, podemos utilizar uma classe anônima:"

#. Tag: programlisting
#, no-c-format
msgid ""
"PaymentProcessor p = paymentProcessorSource\n"
"   .select(new AnnotationLiteral&lt;Asynchronous&gt;() {});"
msgstr ""
"PaymentProcessor p = paymentProcessorSource\n"
"   .select(new AnnotationLiteral&lt;Asynchronous&gt;() {});"

#. Tag: para
#, no-c-format
msgid ""
"However, we can't use an anonymous class to implement a qualifier type with "
"members."
msgstr ""
"No entanto, não podemos utilizar uma classe anônima para implementar um tipo"
" de qualificador com membros."

#. Tag: para
#, no-c-format
msgid ""
"Now, finally, we can pass the qualifier to the <literal>select()</literal> "
"method of <literal>Instance</literal>."
msgstr ""
"Agora, finalmente, podemos passar o qualificador para o método "
"<literal>select()</literal> de <literal>Instance</literal>."

#. Tag: programlisting
#, no-c-format
msgid ""
"Annotation qualifier = synchronously ?\n"
"      new SynchronousQualifier() : new AsynchronousQualifier();\n"
"PaymentProcessor p = anyPaymentProcessor.select(qualifier).get().process(payment);"
msgstr ""
"Annotation qualifier = synchronously ?\n"
"      new SynchronousQualifier() : new AsynchronousQualifier();\n"
"PaymentProcessor p = anyPaymentProcessor.select(qualifier).get().process(payment);"

#. Tag: title
#, no-c-format
msgid "The <literal>InjectionPoint</literal> object"
msgstr "O objeto <literal>InjectionPoint</literal>"

#. Tag: para
#, no-c-format
msgid ""
"There are certain kinds of dependent objects (beans with scope "
"<literal>@Dependent</literal>) that need to know something about the object "
"or injection point into which they are injected in order to be able to do "
"what they do. For example:"
msgstr ""
"Existem certos tipos de objetos dependentes (beans com escopo "
"<literal>@Dependent</literal>) que precisam saber alguma coisa sobre o "
"objeto ou ponto de injeção no qual eles são injetados para serem capazes de "
"fazer o que fazem. Por exemplo:"

#. Tag: para
#, no-c-format
msgid ""
"The log category for a <literal>Logger</literal> depends upon the class of "
"the object that owns it."
msgstr ""
"A categoria de log para um <literal>Logger</literal> depende da classe do "
"objeto que a possui."

#. Tag: para
#, no-c-format
msgid ""
"Injection of a HTTP parameter or header value depends upon what parameter or"
" header name was specified at the injection point."
msgstr ""
"A injeção do valor de um parâmetro ou cabeçalho HTTP depende de qual nome de"
" parâmetro ou cabeçalho foi especificado no ponto de injeção."

#. Tag: para
#, no-c-format
msgid ""
"Injection of the result of an EL expression evaluation depends upon the "
"expression that was specified at the injection point."
msgstr ""
"Injeção do resultado da avaliação de uma expressão EL depende da expressão "
"que foi especificada no ponto de injeção."

#. Tag: para
#, no-c-format
msgid ""
"A bean with scope <literal>@Dependent</literal> may inject an instance of "
"<literal>InjectionPoint</literal> and access metadata relating to the "
"injection point to which it belongs."
msgstr ""
"Um bean com escopo <literal>@Dependent</literal> pode injetar uma instância "
"de <literal>InjectionPoint</literal> e acessar metadados relacionados com o "
"ponto de injeção ao qual ele pertence."

#. Tag: para
#, no-c-format
msgid ""
"Let's look at an example. The following code is verbose, and vulnerable to "
"refactoring problems:"
msgstr ""
"Vejamos um exemplo. O seguinte código é prolixo e vulnerável a problemas de "
"refatoração:"

#. Tag: programlisting
#, no-c-format
msgid "Logger log = Logger.getLogger(MyClass.class.getName());"
msgstr "Logger log = Logger.getLogger(MyClass.class.getName());"

#. Tag: para
#, no-c-format
msgid ""
"This clever little producer method lets you inject a JDK "
"<literal>Logger</literal> without explicitly specifying the log category:"
msgstr ""
"Este método produtor pouco inteligente lhe permite injetar um "
"<literal>Logger</literal> da JDK sem especificar explicitamente a categoria "
"de log:"

#. Tag: programlisting
#, no-c-format
msgid ""
"class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}"
msgstr ""
"class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}"

#. Tag: para
#, no-c-format
msgid "We can now write:"
msgstr "Podemos agora escrever:"

#. Tag: programlisting
#, no-c-format
msgid "@Inject Logger log;"
msgstr "@Inject Logger log;"

#. Tag: para
#, no-c-format
msgid ""
"Not convinced? Then here's a second example. To inject HTTP parameters, we "
"need to define a qualifier type:"
msgstr ""
"Não está convencido? Então aqui está um segundo exemplo. Para injetar "
"parâmetros HTTP, precisamos definir um tipo de qualificador:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @Nonbinding public String value();\n"
"}"
msgstr ""
"@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @Nonbinding public String value();\n"
"}"

#. Tag: para
#, no-c-format
msgid "We would use this qualifier type at injection points as follows:"
msgstr ""
"Gostaríamos de usar este tipo de qualificador em pontos de injeção do "
"seguinte modo:"

#. Tag: programlisting
#, no-c-format
msgid ""
"@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;"
msgstr ""
"@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;"

#. Tag: para
#, no-c-format
msgid "The following producer method does the work:"
msgstr "O seguinte método produtor faz o trabalho:"

#. Tag: programlisting
#, no-c-format
msgid ""
"class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(InjectionPoint ip) {\n"
"      ServletRequest request = (ServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest();\n"
"      return request.getParameter(ip.getAnnotated().getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}"
msgstr ""
"class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(InjectionPoint ip) {\n"
"      ServletRequest request = (ServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest();\n"
"      return request.getParameter(ip.getAnnotated().getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}"

#. Tag: para
#, no-c-format
msgid ""
"Note that acquiring of the request in this example is JSF-centric. For a "
"more generic solution you could write your own producer for the request and "
"have it injected as a method parameter."
msgstr ""
"Observe que a aquisição da solicitação neste exemplo é centrada em JSF. Para"
" uma solução mais genérica você pode escrever seu próprio produtor para a "
"solicitação e a injetar como um parâmetro do método."

#. Tag: para
#, no-c-format
msgid ""
"Note also that the <literal>value()</literal> member of the "
"<literal>HttpParam</literal> annotation is ignored by the container since it"
" is annotated <literal>@Nonbinding.</literal>"
msgstr ""
"Observe que o membro <literal>value()</literal> da anotação "
"<literal>HttpParam</literal> é ignorado pelo contêiner uma vez que ele está "
"anotado com <literal>@Nonbinding.</literal>"

#. Tag: para
#, no-c-format
msgid ""
"The container provides a built-in bean that implements the "
"<literal>InjectionPoint</literal> interface:"
msgstr ""
"O contêiner fornece um bean embutido que implementa a interface "
"<literal>InjectionPoint</literal>:"

#. Tag: programlisting
#, no-c-format
msgid ""
"public interface InjectionPoint { \n"
"   public Type getType();\n"
"   public Set&lt;Annotation&gt; getQualifiers();\n"
"   public Bean&lt;?&gt; getBean();\n"
"   public Member getMember();\n"
"   public Annotated getAnnotated();\n"
"   public boolean isDelegate();\n"
"   public boolean isTransient();\n"
"}"
msgstr ""
"public interface InjectionPoint { \n"
"   public Type getType();\n"
"   public Set&lt;Annotation&gt; getQualifiers();\n"
"   public Bean&lt;?&gt; getBean();\n"
"   public Member getMember();\n"
"   public Annotated getAnnotated();\n"
"   public boolean isDelegate();\n"
"   public boolean isTransient();\n"
"}"
