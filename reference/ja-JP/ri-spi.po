# Language ja-JP translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-01-06 12:17+0000\n"
"PO-Revision-Date: 2009-05-18 01:40+0900\n"
"Last-Translator: wadahiro <wadahiro@gmail.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: ri-spi.xml:4
#, fuzzy, no-c-format
msgid "Integrating Weld into other environments"
msgstr "他の環境へのWeb Beansの統合"

#. Tag: para
#: ri-spi.xml:6
#, no-c-format
msgid ""
"If you want to use Weld in another environment, you will need to provide "
"certain information to Weld via the integration SPI. In this Appendix we "
"will briefly discuss the steps needed."
msgstr ""

#. Tag: title
#: ri-spi.xml:12
#, fuzzy, no-c-format
msgid "Enterprise Services"
msgstr "リソースサービス"

#. Tag: para
#: ri-spi.xml:13
#, no-c-format
msgid ""
"If you just want to use managed beans, and not take advantage of enterprise "
"services (EE resource injection, CDI injection into EE component classes, "
"transactional events, support for CDI services in EJBs) and non-flat "
"deployments, then the generic servlet support provided by the \"Weld: "
"Servlets\" extension will be sufficient, and will work in any container "
"supporting the Servlet API."
msgstr ""

#. Tag: para
#: ri-spi.xml:21
#, no-c-format
msgid ""
"All SPIs and APIs described have extensive JavaDoc, which spell out the "
"detailed contract between the container and Weld."
msgstr ""

#. Tag: title
#: ri-spi.xml:27
#, fuzzy, no-c-format
msgid "The Weld SPI"
msgstr "Web Beans SPI"

#. Tag: para
#: ri-spi.xml:29
#, fuzzy, no-c-format
msgid ""
"The Weld SPI is located in the <literal>weld-spi</literal> module, and "
"packaged as <literal>weld-spi.jar</literal>. Some SPIs are optional, and "
"should only be implemented if you need to override the default behavior; "
"others are required."
msgstr ""
"Web Beans SPIは<literal>webbeans-spi</literal>モジュールにあり、"
"<literal>webbeans-spi.jar</literal>としてパッケージされています。いくつかの"
"SPIはオプションで、デフォルトの振る舞いを上書きする必要がある場合は、他のもの"
"が必要です。"

#. Tag: para
#: ri-spi.xml:35
#, no-c-format
msgid ""
"All interfaces in the SPI support the decorator pattern and provide a "
"<literal>Forwarding</literal> class located in the <literal>helpers</"
"literal> sub package. Additional, commonly used, utility classes, and "
"standard implementations are also located in the <literal>helpers</literal> "
"sub package."
msgstr ""
"SPIのすべてのインタフェースがデコレータパターンをサポートし、"
"<literal>helpers</literal> サブパッケージの中にある<literal>Forwarding</"
"literal>クラスを提供します。加えて、共通で使用されるユーティリティクラスや標"
"準実装は<literal>helpers</literal>サブパッケージの中にあります、"

#. Tag: para
#: ri-spi.xml:41
#, fuzzy, no-c-format
msgid ""
"Weld supports multiple environments. An environment is defined by an "
"implementation of the <literal>Environment</literal> interface. A number of "
"standard environments are built in, and described by the "
"<literal>Environments</literal> enumeration. Different environments require "
"different services to be present (for example a Servlet container doesn't "
"require transaction, EJB or JPA services). By default an EE environment is "
"assumed, but you can adjust the environment by calling <literal>bootstrap."
"setEnvironment()</literal>."
msgstr ""
"ブートストラップは複数の環境をサポートします。環境は<literal>Environment</"
"literal>インタフェースの実装によって定義されます。多くの標準環境が"
"<literal>Environments</literal>列挙で組み込まれています。環境によっては異なる"
"サービスを要求します(たとえば、サーブレットはトランザクション、EJBまたはJPA"
"サービスを必須としません)。デフォルトではEE環境が想定されますが、"
"<literal>bootstrap.setEnvironment()</literal>を呼ぶことで環境を設定できます。"

#. Tag: para
#: ri-spi.xml:50
#, fuzzy, no-c-format
msgid ""
"Weld uses a generic-typed service registry to allow services to be "
"registered. All services implement the <literal>Service</literal> interface. "
"The service registry allows services to be added and retrieved."
msgstr ""
"Web Beansは、サービスの登録のために総称型のサービスレジストリを使用します。す"
"べてのサービスが<literal>Service</literal>インタフェースを実装します。サービ"
"スレジストリは、サービスが追加されて、検索されることを可能とします。"

#. Tag: title
#: ri-spi.xml:56
#, no-c-format
msgid "Deployment structure"
msgstr ""

#. Tag: para
#: ri-spi.xml:58
#, no-c-format
msgid ""
"An application is often comprised of a number of modules. For example, a "
"Java EE deployment may contain a number of EJB modules (containing business "
"logic) and WAR modules (containing the user interface). A container may "
"enforce certain <emphasis>accessibility</emphasis> rules which limit the "
"visibility of classes between modules. CDI allows these same rules to apply "
"to bean and observer method resolution. As the accessibility rules vary "
"between containers, Weld requires the container to <emphasis>describe</"
"emphasis> the deployment structure, via the <literal>Deployment</literal> "
"SPI."
msgstr ""

#. Tag: para
#: ri-spi.xml:67
#, no-c-format
msgid ""
"The CDI specification discusses <emphasis>Bean Deployment Archives</"
"emphasis> (BDAs)&#8212;archives which are marked as containing beans which "
"should be deployed to the CDI container, and made available for injection "
"and resolution. Weld reuses this description of <emphasis>Bean Deployment "
"Archives</emphasis> in its deployment structure SPI. Each deployment exposes "
"the BDAs which it contains; each BDA may also reference other which it can "
"access. Together, the transitive closure of this graph forms the beans which "
"are deployed in the application."
msgstr ""

#. Tag: para
#: ri-spi.xml:76
#, no-c-format
msgid ""
"To describe the deployment structure to Weld, the container should provide "
"an implementation of <literal>Deployment</literal>. <literal>Deployment."
"getBeanDeploymentArchives()</literal> allows Weld to discover the modules "
"which make up the application. The CDI specification also allows beans to be "
"specified programmatically as part of the bean deployment. These beans may, "
"or may not, be in an existing BDA. For this reason, Weld will call "
"<literal>Deployment.loadBeanDeploymentArchive(Class clazz)</literal> for "
"each programmatically described bean."
msgstr ""

#. Tag: para
#: ri-spi.xml:85
#, no-c-format
msgid ""
"As programmatically described beans may result in additional BDAs being "
"added to the graph, Weld will discover the BDA structure every time an "
"unknown BDA is returned by <literal>Deployment.loadBeanDeploymentArchive</"
"literal>."
msgstr ""

#. Tag: title
#: ri-spi.xml:92
#, no-c-format
msgid "Virtual BDAs"
msgstr ""

#. Tag: para
#: ri-spi.xml:93
#, no-c-format
msgid ""
"In a strict container, each BDA might have to explicitly specify which other "
"BDAs it can access. However many containers will allow an easy mechanism to "
"make BDAs bi-directionally accessible (such as a library directory). In this "
"case, it is allowable (and reasonable) to describe all such archives as a "
"single, 'virtual' <literal>BeanDeploymentArchive</literal>."
msgstr ""

#. Tag: para
#: ri-spi.xml:100
#, no-c-format
msgid ""
"A container, might, for example, use a flat accessibility structure for the "
"application. In this case, a single <literal>BeanDeploymentArchive</literal> "
"would be attached to the <literal>Deployment</literal>."
msgstr ""

#. Tag: para
#: ri-spi.xml:106
#, no-c-format
msgid ""
"<literal>BeanDeploymentArchive</literal> provides three methods which allow "
"it's contents to be discovered by Weld&#8212;<literal>BeanDeploymentArchive."
"getBeanClasses()</literal> must return all the classes in the BDA, "
"<literal>BeanDeploymentArchive.getBeansXml()</literal> must return all the "
"deployment descriptors in the archive, and <literal>BeanDeploymentArchive."
"getEjbs()</literal> must provide an EJB descriptor for every EJB in the BDA, "
"or an empty list if it is not an EJB archive."
msgstr ""

#. Tag: para
#: ri-spi.xml:114
#, no-c-format
msgid ""
"BDA X may also reference another BDA Y whose beans can be resolved by, and "
"injected into, any bean in BDA X. These are the accessible BDAs, and every "
"BDA that is directly accessible by BDA X should be returned. A BDA will also "
"have BDAs which are accessible transitively, and the transitive closure of "
"the sub-graph of BDA X describes all the beans resolvable by BDA X."
msgstr ""

#. Tag: title
#: ri-spi.xml:122
#, no-c-format
msgid "Matching the classloader structure for the deployment"
msgstr ""

#. Tag: para
#: ri-spi.xml:124
#, no-c-format
msgid ""
"In practice, you can regard the deployment structure represented by "
"<literal>Deployment</literal>, and the virtual BDA graph as a mirror of the "
"classloader structure for a deployment. If a class can from BDA X can be "
"loaded by another in BDA Y, it is accessible, and therefore BDA Y's "
"accessible BDAs should include BDA X."
msgstr ""

#. Tag: para
#: ri-spi.xml:132
#, no-c-format
msgid ""
"To specify the directly accessible BDAs, the container should provide an "
"implementation of <literal>BeanDeploymentArchive.getBeanDeploymentArchives()"
"</literal>."
msgstr ""

#. Tag: para
#: ri-spi.xml:138
#, no-c-format
msgid ""
"Weld allows the container to describe a circular graph, and will convert a "
"graph to a tree as part of the deployment process."
msgstr ""

#. Tag: para
#: ri-spi.xml:144
#, no-c-format
msgid ""
"Certain services are provided for the whole deployment, whilst some are "
"provided per-BDA. BDA services are provided using "
"<literal>BeanDeploymentArchive.getServices()</literal> and only apply to the "
"BDA on which they are provided."
msgstr ""

#. Tag: title
#: ri-spi.xml:153
#, no-c-format
msgid "EJB descriptors"
msgstr ""

#. Tag: para
#: ri-spi.xml:155
#, no-c-format
msgid ""
"Weld delegates EJB 3 bean discovery to the container so that it doesn't "
"duplicate the work done by the EJB container, and respects any vendor-"
"extensions to the EJB definition."
msgstr ""

#. Tag: para
#: ri-spi.xml:160
#, fuzzy, no-c-format
msgid ""
"The <literal>EjbDescriptor</literal> should return the relevant metadata as "
"defined in the EJB specification. Each business interface of a session bean "
"should be described using a <literal>BusinessInterfaceDescriptor</literal>."
msgstr ""
"<literal>EjbDescriptor</literal>は、ほとんど読んで字の通りですが、EJBの仕様で"
"定義されている関連メタデータを返します。これらの二つのインタフェースに加え"
"て、ローカルのビジネスインタフェース(インタフェースクラスとEJBのインスタンス"
"をルックアップするために使用されるJNDI名をカプセル化したもの)を表す"
"<literal>BusinessInterfaceDescriptor</literal>があります。"

#. Tag: title
#: ri-spi.xml:169
#, no-c-format
msgid "EE resource injection and resolution services"
msgstr ""

#. Tag: para
#: ri-spi.xml:171
#, no-c-format
msgid ""
"All the EE resource services are per-BDA services, and may be provided using "
"one of two methods. Which method to use is at the discretion of the "
"integrator."
msgstr ""

#. Tag: para
#: ri-spi.xml:176
#, no-c-format
msgid ""
"The integrator may choose to provide all EE resource injection services "
"themselves, using another library or framework. In this case the integrator "
"should use the <literal>EE</literal> environment, and implement the <xref "
"linkend=\"injection.services\"/> SPI."
msgstr ""

#. Tag: para
#: ri-spi.xml:182
#, no-c-format
msgid ""
"Alternatively, the integrator may choose to use CDI to provide EE resource "
"injection. In this case, the <literal>EE_INJECT</literal> environment should "
"be used, and the integrator should implement the <xref linkend=\"ejb."
"services.resolution\"/>, <xref linkend=\"resource.services\"/> and <xref "
"linkend=\"jpa.services\"/>."
msgstr ""

#. Tag: para
#: ri-spi.xml:189
#, no-c-format
msgid ""
"CDI only provides annotation-based EE resource injection; if you wish to "
"provide deployment descriptor (e.g. <literal>ejb-jar.xml</literal>) "
"injection, you must use <xref linkend=\"injection.services\"/>."
msgstr ""

#. Tag: para
#: ri-spi.xml:195
#, no-c-format
msgid ""
"If the container performs EE resource injection, the injected resources must "
"be serializable. If EE resource injection is provided by Weld, the resolved "
"resource must be serializable."
msgstr ""

#. Tag: para
#: ri-spi.xml:201
#, no-c-format
msgid ""
"If you use a non-EE environment then you may implement any of the EE service "
"SPIs, and Weld will provide the associated functionality. There is no need "
"to implement those services you don't need!"
msgstr ""

#. Tag: title
#: ri-spi.xml:210
#, no-c-format
msgid "EJB services"
msgstr "EJBサービス"

#. Tag: para
#: ri-spi.xml:212
#, no-c-format
msgid "EJB services are split between two interfaces which are both per-BDA."
msgstr ""

#. Tag: para
#: ri-spi.xml:216
#, fuzzy, no-c-format
msgid ""
"<literal>EJBServices</literal> is used to resolve local EJBs used to back "
"session beans, and must always be provided in an EE environment. "
"<literal>EJBServices.resolveEjb(EjbDescriptor ejbDescriptor)</literal> "
"returns a wrapper&#8212;<literal>SessionObjectReference</literal>&#8212;"
"around the EJB reference. This wrapper allows Weld to request a reference "
"that implements the given business interface, and, in the case of SFSBs, "
"both request the removal of the EJB from the container and query whether the "
"EJB has been previously removed."
msgstr ""
"(よくセッションBeanを背後とする)ローカルEJBを解決するとき、EJB参照を囲んだ"
"ラッパー(<literal>SessionObjectReference</literal>)を返します。このラッパーの"
"おかげで、Web Beansは特定のビジネスインタフェースを実装する参照を要求すること"
"ができます。SFSBの場合は、コンテナからEJBの削除を要求することができます。"

#. Tag: para
#: ri-spi.xml:225
#, no-c-format
msgid ""
"<literal>EJBResolutionServices.resolveEjb(InjectionPoint ij)</literal> "
"allows the resolution of <literal>@EJB</literal> (for injection into managed "
"beans). This service is not required if the implementation of <xref linkend="
"\"injection.services\"/> takes care of <literal>@EJB</literal> injection."
msgstr ""

#. Tag: title
#: ri-spi.xml:234
#, no-c-format
msgid "JPA services"
msgstr "JPAサービス"

#. Tag: para
#: ri-spi.xml:236
#, fuzzy, no-c-format
msgid ""
"Just as EJB resolution is delegated to the container, resolution of "
"<literal>@PersistenceContext</literal> for injection into managed beans "
"(with the <literal>InjectionPoint</literal> provided), is delegated to the "
"container."
msgstr ""
"ちょうどEJBの解決がコンテナに委譲されるように、(<literal>InjectionPoint</"
"literal>が与えられた)シンプルBeansへのインジェクションのための"
"<literal>@PersistenceContext</literal>の解決、およびJava EEリソースとしてのイ"
"ンジェクションのための、永続コンテキストと(<literal>unitName</literal>が与え"
"られた)永続ユニットの解決はコンテナに委譲されます。"

#. Tag: para
#: ri-spi.xml:242
#, no-c-format
msgid ""
"To allow JPA integration, the <literal>JpaServices</literal> interface "
"should be implemented. This service is not required if the implementation of "
"<xref linkend=\"injection.services\"/> takes care of "
"<literal>@PersistenceContext</literal> injection."
msgstr ""

#. Tag: title
#: ri-spi.xml:251
#, no-c-format
msgid "Transaction Services"
msgstr "トランザクションサービス"

#. Tag: para
#: ri-spi.xml:253
#, fuzzy, no-c-format
msgid ""
"Weld delegates JTA activities to the container. The SPI provides a couple "
"hooks to easily achieve this with the <literal>TransactionServices</literal> "
"interface."
msgstr ""
"Web BeansはJTAの活動をコンテナへ委譲する必要があります。SPIはこれを容易に実現"
"するために、<literal>TransactionServices</literal>インタフェースで数カ所の"
"フックを提供します。"

#. Tag: para
#: ri-spi.xml:258
#, no-c-format
msgid ""
"Any <literal>javax.transaction.Synchronization</literal> implementation may "
"be passed to the <literal>registerSynchronization()</literal> method and the "
"SPI implementation should immediately register the synchronization with the "
"JTA transaction manager used for the EJBs."
msgstr ""
"どのような<literal>javax.transaction.Synchronization</literal>の実装も、"
"<literal>registerSynchronization()</literal>メソッドに渡されるかもしれませ"
"ん。そしてSPIの実装は、EJBに使用されるJTAトランザクションマネージャとの同期を"
"すぐに登録すべきです。"

#. Tag: para
#: ri-spi.xml:264
#, no-c-format
msgid ""
"To make it easier to determine whether or not a transaction is currently "
"active for the requesting thread, the <literal>isTransactionActive()</"
"literal> method can be used. The SPI implementation should query the same "
"JTA transaction manager used for the EJBs."
msgstr ""
"要求スレッドでトランザクションが現在アクティブであるかどうか確認しやすくする"
"ために、<literal>isTransactionActive()</literal>メソッドが使用されます。SPIの"
"実装は、EJBで使用される同じJTAトランザクションマネージャに問い合わせを行うべ"
"きです。"

#. Tag: title
#: ri-spi.xml:272
#, no-c-format
msgid "Resource Services"
msgstr "リソースサービス"

#. Tag: para
#: ri-spi.xml:274
#, fuzzy, no-c-format
msgid ""
"The resolution of <literal>@Resource</literal> (for injection into managed "
"beans) is delegated to the container. You must provide an implementation of "
"<literal>ResourceServices</literal> which provides these operations. This "
"service is not required if the implementation of <xref linkend=\"injection."
"services\"/> takes care of <literal>@Resource</literal> injection."
msgstr ""
"(Java EEリソースとしてのインジェクションの)Webサービスの参照の解決は、コンテ"
"ナに委譲されます。あなたはこの操作を提供する<literal>WebServices</literal>の"
"実装を提供する必要があります。Java EEリソースの解決のために、"
"<literal>jndiName</literal>または<literal>mappedName</literal>が提供されるで"
"しょう。"

#. Tag: title
#: ri-spi.xml:283
#, fuzzy, no-c-format
msgid "Injection Services"
msgstr "トランザクションサービス"

#. Tag: para
#: ri-spi.xml:285
#, no-c-format
msgid ""
"An integrator may wish to use <literal>InjectionServices</literal> to "
"provide additional field or method injection over-and-above that provided by "
"Weld. An integration into a Java EE environment may use "
"<literal>InjectionServices</literal> to provide EE resource injection for "
"managed beans."
msgstr ""

#. Tag: para
#: ri-spi.xml:291
#, no-c-format
msgid ""
"<literal>InjectionServices</literal> provides a very simple contract, the "
"<literal>InjectionServices.aroundInject(InjectionContext ic);</literal> "
"intercepter will be called for every instance that CDI injects, whether it "
"is a contextual instance, or a non-contextual instance injected by "
"<literal>InjectionTarget.inject()</literal>."
msgstr ""

#. Tag: para
#: ri-spi.xml:298
#, no-c-format
msgid ""
"The <literal>InjectionContext</literal> can be used to discover additional "
"information about the injection being performed, including the "
"<literal>target</literal> being injected. <literal>ic.proceed()</literal> "
"should be called to perform CDI-style injection, and call initializer "
"methods."
msgstr ""

#. Tag: title
#: ri-spi.xml:307
#, fuzzy, no-c-format
msgid "Security Services"
msgstr "リソースサービス"

#. Tag: para
#: ri-spi.xml:309
#, no-c-format
msgid ""
"In order to obtain the <literal>Principal</literal> representing the current "
"caller identity, the container should provide an implementation of "
"<literal>SecurityServices</literal>."
msgstr ""

#. Tag: title
#: ri-spi.xml:317
#, fuzzy, no-c-format
msgid "Bean Validation Services"
msgstr "トランザクションサービス"

#. Tag: para
#: ri-spi.xml:319
#, no-c-format
msgid ""
"In order to obtain the default <literal>ValidatorFactory</literal> for the "
"application deployment, the container should provide an implementation of "
"<literal>ValidationServices</literal>."
msgstr ""

#. Tag: title
#: ri-spi.xml:327
#, no-c-format
msgid "Identifying the BDA being addressed"
msgstr ""

#. Tag: para
#: ri-spi.xml:329
#, no-c-format
msgid ""
"When a client makes a request to an application which uses Weld, the request "
"may be addressed at any of the BDAs in the application deployment. To allow "
"Weld to correctly service the request, it needs to know which BDA the "
"request is addressed at. Where possible, Weld will provide some context, but "
"use of these by the integrator is optional."
msgstr ""

#. Tag: para
#: ri-spi.xml:337
#, no-c-format
msgid ""
"Most Servlet contains use a classloader-per-WAR, this may provide a good way "
"to identify the BDA in use for web requests."
msgstr ""

#. Tag: para
#: ri-spi.xml:343
#, no-c-format
msgid ""
"When Weld needs to identify the BDA, it will use one of these services, "
"depending on what is servicing the request:"
msgstr ""

#. Tag: literal
#: ri-spi.xml:350
#, no-c-format
msgid "ServletServices.getBeanDeploymentArchive(ServletContext ctx)"
msgstr ""

#. Tag: para
#: ri-spi.xml:352
#, no-c-format
msgid ""
"Identify the WAR in use. The <literal>ServletContext</literal> is provided "
"for additional context."
msgstr ""

#. Tag: title
#: ri-spi.xml:362
#, no-c-format
msgid "The bean store"
msgstr "Beanストア"

#. Tag: para
#: ri-spi.xml:364
#, fuzzy, no-c-format
msgid ""
"Weld uses a map like structure to store bean instances - <literal>org.jboss."
"weld.context.api.BeanStore</literal>. You may find <literal>org.jboss.weld."
"context.api.helpers.ConcurrentHashMapBeanStore</literal> useful."
msgstr ""
"Web Beansは、Beanインスタンスを保存するために構成されたものとしてあるMap - "
"<literal>org.jboss.webbeans.context.api.BeanStore</literal>を使用します。"
"<literal>org.jboss.webbeans.context.api.helpers.ConcurrentHashMapBeanStore</"
"literal>が役に立つことがわかるでしょう。"

#. Tag: title
#: ri-spi.xml:372
#, no-c-format
msgid "The application context"
msgstr "アプリケーションコンテキスト"

#. Tag: para
#: ri-spi.xml:374
#, fuzzy, no-c-format
msgid ""
"Weld expects the Application Server or other container to provide the "
"storage for each application's context. The <literal>org.jboss.weld.context."
"api.BeanStore</literal> should be implemented to provide an application "
"scoped storage."
msgstr ""
"Web Beansは、アプリケーションサーバーかその他のコンテナが、アプリケーションコ"
"ンテキストのための保存領域を提供することを想定しています。<literal>org.jboss."
"webbeans.context.api.BeanStore</literal>は、アプリケーションスコープの保存領"
"域を提供するように実装される必要があります。"

#. Tag: title
#: ri-spi.xml:383
#, fuzzy, no-c-format
msgid "Initialization and shutdown"
msgstr "ブートストラップとシャットダウン"

#. Tag: para
#: ri-spi.xml:384
#, fuzzy, no-c-format
msgid ""
"The <literal>org.jboss.weld.bootstrap.api.Bootstrap</literal> interface "
"defines the initialization for Weld, bean deployment and bean validation. To "
"boot Weld, you must create an instance of <literal>org.jboss.weld.bootstrap."
"WeldBeansBootstrap</literal> (which implements <literal>Boostrap</literal>), "
"tell it about the services in use, and then request the container start."
msgstr ""
"<literal>org.jboss.webbeans.bootstrap.api.Bootstrap</literal>インタフェースは"
"Web Beansのブートストラップを定義します。Web Beansを起動するために、"
"(<literal>Boostrap</literal>を実装した)<literal>org.jboss.webbeans.bootstrap."
"api.Bootstrap</literal>インスタンスを取得し、使用中のSPIに伝え、コンテナに起"
"動を要求する必要があります。"

#. Tag: para
#: ri-spi.xml:391
#, fuzzy, no-c-format
msgid ""
"The bootstrap is split into phases, container initialization, bean "
"deployment, bean validation and shutdown. Initialization will create a "
"manager, and add the built-in contexts, and examine the deployment "
"structure. Bean deployment will deploy any beans (defined using annotations, "
"programtically, or built in). Bean validation will validate all beans."
msgstr ""
"ブートストラップは、初期化と起動とシャットダウンのフェーズに分かれます。初期"
"化はマネージャを生成し、標準の(仕様で定義された)コンテキストを追加するでしょ"
"う。ブートストラップはEJB、クラスおよびXMLを探索します。アノテーションにより"
"定義されたBeansを追加します。また、XMLで定義されたBeansを追加します。そして、"
"すべてのBeansの妥当性確認を行います。"

#. Tag: para
#: ri-spi.xml:398
#, fuzzy, no-c-format
msgid ""
"To initialize the container, you call <literal>Bootstrap.startInitialization"
"()</literal>. Before calling <literal>startInitialization()</literal>, you "
"must register any services required by the environment. You can do this by "
"calling, for example, <literal>bootstrap.getServices().add(JpaServices."
"class, new MyJpaServices())</literal>. You must also provide the application "
"context bean store."
msgstr ""
"ブートストラップの初期化のためには<literal>Bootstrap.initialize()</literal>を"
"呼びます。<literal>initialize()</literal>を呼び出す前に、その環境で必要となる"
"サービスを登録する必要があります。これは、<literal>bootstrap.getServices()."
"add(JpaServices.class, new MyJpaServices())</literal>を呼び出すことで可能で"
"す。また、アプリケーションコンテキストのBeanストアを提供する必要があります。"

#. Tag: para
#: ri-spi.xml:405
#, fuzzy, no-c-format
msgid ""
"Having called <literal>startInitialization()</literal>, the "
"<literal>Manager</literal> for each BDA can be obtained by calling "
"<literal>Bootstrap.getManager(BeanDeploymentArchive bda)</literal>."
msgstr ""
"<literal>initialize()</literal>が呼び出されると、<literal>Manager</literal>は"
"<literal>Bootstrap.getManager()</literal>を呼ぶことで得ることができます。"

#. Tag: para
#: ri-spi.xml:410
#, fuzzy, no-c-format
msgid ""
"To deploy the discovered beans, call <literal>Bootstrap.deployBeans()</"
"literal>."
msgstr ""
"コンテナをブートするためには<literal>Bootstrap.boot()</literal>を呼びます。"

#. Tag: para
#: ri-spi.xml:414
#, fuzzy, no-c-format
msgid ""
"To validate the deployed beans, call <literal>Bootstrap.validateBeans()</"
"literal>."
msgstr ""
"コンテナをブートするためには<literal>Bootstrap.boot()</literal>を呼びます。"

#. Tag: para
#: ri-spi.xml:418
#, fuzzy, no-c-format
msgid ""
"To place the container into a state where it can service requests, call "
"<literal>Bootstrap.endInitialization()</literal>"
msgstr ""
"コンテナをブートするためには<literal>Bootstrap.boot()</literal>を呼びます。"

#. Tag: para
#: ri-spi.xml:423
#, fuzzy, no-c-format
msgid ""
"To shutdown the container you call <literal>Bootstrap.shutdown()</literal>. "
"This allows the container to perform any cleanup operations needed."
msgstr ""
"コンテナをシャットダウンするためには<literal>Bootstrap.shutdown()</literal>、"
"または<literal>webBeansManager.shutdown()</literal>を呼びます。これで、コンテ"
"ナは必要なクリーンアップ操作を実行できます。"

#. Tag: title
#: ri-spi.xml:431
#, no-c-format
msgid "Resource loading"
msgstr "リソースのロード"

#. Tag: para
#: ri-spi.xml:433
#, fuzzy, no-c-format
msgid ""
"Weld needs to load classes and resources from the classpath at various "
"times. By default, they are loaded from the Thread Context ClassLoader if "
"available, if not the same classloader that was used to load Weld, however "
"this may not be correct for some environments. If this is case, you can "
"implement <literal>org.jboss.weld.spi.ResourceLoader</literal>."
msgstr ""
"Web Beansは様々なタイミングでクラスパスからクラスとリソースをロードする必要が"
"あります。デフォルトでは、可能であればスレッドコンテキストクラスローダから"
"ロードします。しかしながら、もしWeb Beansのロードに使用されたクラスローダと異"
"なる場合は、ある環境ではこれは正しくないかもしれません。もしそうであれば、"
"<literal>org.jboss.webbeans.spi.ResourceLoader</literal>を実装することができ"
"ます。"

#. Tag: title
#: ri-spi.xml:445
#, no-c-format
msgid "The contract with the container"
msgstr "コンテナとの契約"

#. Tag: para
#: ri-spi.xml:447
#, fuzzy, no-c-format
msgid ""
"There are a number of requirements that Weld places on the container for "
"correct functioning that fall outside implementation of APIs."
msgstr ""
"Web Beans RIは、APIの実装からは外れますが正しく機能するために、コンテナ上に配"
"置するにあたって多くの要件があります。"

#. Tag: term
#: ri-spi.xml:454
#, no-c-format
msgid "Classloader isolation"
msgstr "クラスローダの分離"

#. Tag: para
#: ri-spi.xml:458
#, fuzzy, no-c-format
msgid ""
"If you are integrating Weld into an environment that supports deployment of "
"multiple applications, you must enable, automatically, or through user "
"configuation, classloader isolation for each CDI application."
msgstr ""
"Web Beans RIを複数のアプリケーションのデプロイをサポートする環境に統合してい"
"るなら、それぞれのWeb Beansアプリケーションのクラスローダの分離を、自動的また"
"はユーザによる設定によって有効とする必要があります。"

#. Tag: term
#: ri-spi.xml:466
#, no-c-format
msgid "Servlet"
msgstr "サーブレット"

#. Tag: para
#: ri-spi.xml:470
#, fuzzy, no-c-format
msgid ""
"If you are integrating Weld into a Servlet environment you must register "
"<literal>org.jboss.weld.servlet.WeldListener</literal> as a Servlet "
"listener, either automatically, or through user configuration, for each CDI "
"application which uses Servlet."
msgstr ""
"Web Beansをサーブレット環境と統合しているなら、自動的またはユーザ設定によっ"
"て、<literal>org.jboss.webbeans.servlet.WebBeansListener</literal>をサーブ"
"レットリスナーとして登録する必要があります。この登録は、サーブレットを使用す"
"る各Web Beansアプリケーションで必要です。"

#. Tag: para
#: ri-spi.xml:475
#, no-c-format
msgid ""
"You must ensure that that <literal>WeldListener.contextInitialized()</"
"literal> is called after beans are deployed is complete (<literal>Bootstrap."
"deployBeans()</literal> has been called)."
msgstr ""

#. Tag: term
#: ri-spi.xml:482
#, no-c-format
msgid "<term>JSF</term>"
msgstr "<term>JSF</term>"

#. Tag: para
#: ri-spi.xml:487
#, fuzzy, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must register "
"<literal>org.jboss.weld.jsf.WeldPhaseListener</literal> as a phase listener."
msgstr ""
"Web Beansをサーブレット環境と統合しているなら、自動的またはユーザ設定によっ"
"て、<literal>org.jboss.webbeans.servlet.WebBeansListener</literal>をサーブ"
"レットリスナーとして登録する必要があります。この登録は、サーブレットを使用す"
"る各Web Beansアプリケーションで必要です。"

#. Tag: para
#: ri-spi.xml:492
#, fuzzy, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must register "
"<literal>org.jboss.weld.el.WeldELContextListener</literal> as an EL Context "
"listener."
msgstr ""
"Web Beansをサーブレット環境と統合しているなら、自動的またはユーザ設定によっ"
"て、<literal>org.jboss.webbeans.servlet.WebBeansListener</literal>をサーブ"
"レットリスナーとして登録する必要があります。この登録は、サーブレットを使用す"
"る各Web Beansアプリケーションで必要です。"

#. Tag: para
#: ri-spi.xml:497
#, fuzzy, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must register "
"<literal>org.jboss.weld.jsf.ConversationAwareViewHandler</literal> as a "
"delegating view handler."
msgstr ""
"Web Beansをサーブレット環境と統合しているなら、自動的またはユーザ設定によっ"
"て、<literal>org.jboss.webbeans.servlet.WebBeansListener</literal>をサーブ"
"レットリスナーとして登録する必要があります。この登録は、サーブレットを使用す"
"る各Web Beansアプリケーションで必要です。"

#. Tag: para
#: ri-spi.xml:502
#, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must obtain the bean "
"manager for the module and then call <literal>BeanManager."
"wrapExpressionFactory()</literal>, passing <literal>Application."
"getExpressionFactory()</literal> as the argument. The wrapped expression "
"factory must be used in all EL expression evaluations performed by JSF in "
"this web application."
msgstr ""

#. Tag: para
#: ri-spi.xml:509
#, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must obtain the bean "
"manager for the module and then call <literal>BeanManager.getELResolver()</"
"literal>, The returned EL resolver should be registered with JSF for this "
"web application."
msgstr ""

#. Tag: para
#: ri-spi.xml:516 ri-spi.xml:562
#, no-c-format
msgid ""
"There are a number of ways you can obtain the bean manager for the module. "
"You could call <literal>Bootstrap.getManager()</literal>, passing in the BDA "
"for this module. Alternatively, you could use the injection into Java EE "
"component classes, or look up the bean manager in JNDI."
msgstr ""

#. Tag: para
#: ri-spi.xml:523
#, fuzzy, no-c-format
msgid ""
"If you are integrating Weld into a JSF environment you must register "
"<literal>org.jboss.weld.servlet.ConversationPropagationFilter</literal> as a "
"Servlet listener, either automatically, or through user configuration, for "
"each CDI application which uses JSF. This filter can be registered for all "
"Servlet deployment safely."
msgstr ""
"Web BeansをJSF環境と統合しているなら、自動的またはユーザ設定によって、"
"<literal>org.jboss.webbeans.servlet.ConversationPropagationFilter</literal>を"
"サーブレットフィルタとして登録する必要があります。この登録は、JSFを使用する各"
"Web Beansアプリケーションで必要です。すべてのサーブレットのデプロイのために、"
"このフィルタは安全に登録できます。"

#. Tag: para
#: ri-spi.xml:531
#, fuzzy, no-c-format
msgid "Weld only supports JSF 1.2 and above."
msgstr "Web BeansはJSF 1.2以上をサポートしています。"

#. Tag: term
#: ri-spi.xml:538
#, fuzzy, no-c-format
msgid "<term>JSP</term>"
msgstr "<term>JSF</term>"

#. Tag: para
#: ri-spi.xml:543
#, fuzzy, no-c-format
msgid ""
"If you are integrating Weld into a JSP environment you must register "
"<literal>org.jboss.weld.el.WeldELContextListener</literal> as an EL Context "
"listener."
msgstr ""
"Web Beansをサーブレット環境と統合しているなら、自動的またはユーザ設定によっ"
"て、<literal>org.jboss.webbeans.servlet.WebBeansListener</literal>をサーブ"
"レットリスナーとして登録する必要があります。この登録は、サーブレットを使用す"
"る各Web Beansアプリケーションで必要です。"

#. Tag: para
#: ri-spi.xml:548
#, no-c-format
msgid ""
"If you are integrating Weld into a JSP environment you must obtain the bean "
"manager for the module and then call <literal>BeanManager."
"wrapExpressionFactory()</literal>, passing <literal>Application."
"getExpressionFactory()</literal> as the argument. The wrapped expression "
"factory must be used in all EL expression evaluations performed by JSP."
msgstr ""

#. Tag: para
#: ri-spi.xml:555
#, no-c-format
msgid ""
"If you are integrating Weld into a JSP environment you must obtain the bean "
"manager for the module and then call <literal>BeanManager.getELResolver()</"
"literal>, The returned EL resolver should be registered with JSP for this "
"web application."
msgstr ""

#. Tag: term
#: ri-spi.xml:572
#, no-c-format
msgid "Session Bean Interceptor"
msgstr "セッションBeanインタセプタ"

#. Tag: para
#: ri-spi.xml:576
#, fuzzy, no-c-format
msgid ""
"If you are integrating Weld into an EJB environment you must register "
"<literal>org.jboss.weld.ejb.SessionBeanInterceptor</literal> as a EJB "
"interceptor for all EJBs in the application, either automatically, or "
"through user configuration, for each CDI application which uses enterprise "
"beans."
msgstr ""
"Web BeansをEJB環境と統合しているなら、自動的またはユーザ設定によって、アプリ"
"ケーション中のすべてのEJBに対して<literal>org.jboss.webbeans.ejb."
"SessionBeanInterceptor</literal>をEJBインタセプタとして登録する必要がありま"
"す。この登録は、エンタープライズBeanを使用する各Web Beansアプリケーションで必"
"要です。"

#. Tag: para
#: ri-spi.xml:583
#, no-c-format
msgid ""
"You must register the <literal>SessionBeanInterceptor</literal> as the inner "
"most interceptor in the stack for all EJBs."
msgstr ""
"すべてのEJBで、<literal>SessionBeanInterceptor</literal>をインタセプタスタッ"
"クの中で最も内側に登録する必要があります。"

#. Tag: term
#: ri-spi.xml:591
#, fuzzy, no-c-format
msgid "The <literal>weld-core.jar</literal>"
msgstr "<literal>webbeans-core.jar</literal>"

#. Tag: para
#: ri-spi.xml:595
#, no-c-format
msgid ""
"Weld can reside on an isolated classloader, or on a shared classloader. If "
"you choose to use an isolated classloader, the default "
"<literal>SingletonProvider</literal>, "
"<literal>IsolatedStaticSingletonProvider</literal>, can be used. If you "
"choose to use a shared classloader, then you will need to choose another "
"strategy."
msgstr ""

#. Tag: para
#: ri-spi.xml:601
#, no-c-format
msgid ""
"You can provide your own implementation of <literal>Singleton</literal> and "
"<literal>SingletonProvider</literal> and register it for use using "
"<literal>SingletonProvider.initialize(SingletonProvider provider)</literal>."
msgstr ""

#. Tag: para
#: ri-spi.xml:606
#, no-c-format
msgid ""
"Weld also provides an implementation of Thread Context Classloader per "
"application strategy, via the <literal>TCCLSingletonProvider</literal>."
msgstr ""

#. Tag: term
#: ri-spi.xml:613
#, no-c-format
msgid "Binding the manager in JNDI"
msgstr "JNDIにマネージャをバインドする"

#. Tag: para
#: ri-spi.xml:617
#, fuzzy, no-c-format
msgid ""
"You should bind the bean manager for the bean deployment archive into JNDI "
"at <literal>java:comp/Manager</literal>. The type should be <literal>javax."
"enterprise.inject.spi.BeanManager</literal>. To obtain the correct bean "
"manager for the bean deployment archive, you may call <literal>bootstrap."
"getBeanManager(beanDeploymentArchive)</literal>"
msgstr ""
"あなたはマネージャの<literal>ObjectFactory</literal> への<literal>参照</"
"literal>をJNDIの <literal>java:app/Manager</literal>にバインドしなければなり"
"ません。その型は<literal>javax.inject.manager.Manager</literal>と"
"<literal>org.jboss.webbeans.resources.ManagerObjectFactory</literal>でなけれ"
"ばなりません。"

#. Tag: term
#: ri-spi.xml:627
#, no-c-format
msgid "Performing CDI injection on Java EE component classes"
msgstr ""

#. Tag: para
#: ri-spi.xml:631
#, no-c-format
msgid ""
"The CDI specification requires the container to provide injection into non-"
"contextual resources for all Java EE component classes. Weld delegates this "
"responsibility to the container. This can be achieved using the CDI defined "
"<literal>InjectionTarget</literal> SPI. Furthermore, you must perform this "
"operation on the correct bean manager for the bean deployment archive "
"containing the EE component class."
msgstr ""

#. Tag: para
#: ri-spi.xml:639
#, no-c-format
msgid ""
"The CDI specification also requires that a <literal>ProcessInjectionTarget</"
"literal> event is fired for every Java EE component class. Furthermore, if "
"an observer calls <literal>ProcessInjectionTarget.setInjectionTarget()</"
"literal> the container must use <emphasis>the specified</emphasis> injection "
"target to perform injection."
msgstr ""

#. Tag: para
#: ri-spi.xml:646
#, no-c-format
msgid ""
"To help the integrator, Weld provides <literal>WeldManager."
"fireProcessInjectionTarget()</literal> which returns the "
"<literal>InjectionTarget</literal> to use."
msgstr ""

#. Tag: programlisting
#: ri-spi.xml:651
#, no-c-format
msgid ""
"<![CDATA[// Fire ProcessInjectionTarget, returning the InjectionTarget\n"
"// to use\n"
"InjectionTarget it = weldBeanManager.fireProcessInjectionTarget(clazz);\n"
"\n"
"// Per instance required, create the creational context\n"
"CreationalContext<?> cc = beanManager.createCreationalContext(null);\n"
"\n"
"// Produce the instance, performing any constructor injection required\n"
"Object instance = it.produce();\n"
"\n"
"// Perform injection and call initializers\n"
"it.inject(instance, cc);\n"
"\n"
"// Call the post-construct callback\n"
"it.postConstruct(instance);\n"
"\n"
"// Call the pre-destroy callback\n"
"it.preDestroy(instance);\n"
"\n"
"// Clean up the instance\n"
"it.dispose();\n"
"cc.release();]]>"
msgstr ""

#. Tag: para
#: ri-spi.xml:652
#, no-c-format
msgid ""
"The container may intersperse other operations between these calls. Further, "
"the integrator may choose to implement any of these calls in another manner, "
"assuming the contract is fulfilled."
msgstr ""

#. Tag: para
#: ri-spi.xml:656
#, no-c-format
msgid ""
"When performing injections on EJBs you must use the Weld-defined SPI, "
"<literal>WeldManager</literal>. Furthermore, you must perform this operation "
"on the correct bean manager for the bean deployment archive containing the "
"EJB."
msgstr ""

#. Tag: programlisting
#: ri-spi.xml:661
#, no-c-format
msgid ""
"<![CDATA[// Obtain the EjbDescriptor for the EJB\n"
"// You may choose to use this utility method to get the descriptor\n"
"EjbDescriptor<?> ejbDescriptor = beanManager.getEjbDescriptor(ejbName);\n"
"\n"
"// Get an the Bean object\n"
"Bean<?> bean = beanManager.getBean(ejbDescriptor);\n"
"\n"
"// Create the injection target\n"
"InjectionTarget it = deploymentBeanManager.createInjectionTarget"
"(ejbDescriptor);\n"
"\n"
"// Per instance required, create the creational context\n"
"CreationalContext<?> cc = deploymentBeanManager.createCreationalContext"
"(bean);\n"
"\n"
"// Perform injection and call initializers\n"
"it.inject(instance, cc);\n"
"\n"
"// You may choose to have CDI call the post construct and pre destroy\n"
"// lifecycle callbacks\n"
"\n"
"// Call the post-construct callback\n"
"it.postConstruct(instance);\n"
"\n"
"// Call the pre-destroy callback\n"
"it.preDestroy(instance);\n"
"\n"
"// Clean up the instance\n"
"it.dispose();\n"
"cc.release();]]>"
msgstr ""

#~ msgid ""
#~ "Currently Web Beans only runs in JBoss AS 5; integrating the RI into "
#~ "other EE environments (for example another application server like "
#~ "Glassfish), into a servlet container (like Tomcat), or with an Embedded "
#~ "EJB3.1 implementation is fairly easy. In this Appendix we will briefly "
#~ "discuss the steps needed."
#~ msgstr ""
#~ "現在のWeb BeansはJBoss AS 5でのみ動作します。他のEE環境(たとえば、"
#~ "Glassfishのような別のアプリケーションサーバー)に、または(Tomcatoのような)"
#~ "サーブレットコンテナに、または組み込みEJB3.1の実装と統合することは、実に簡"
#~ "単です。この付録では、統合のために必要なステップについて簡単に記述していま"
#~ "す。"

#~ msgid "Web Bean Discovery"
#~ msgstr "Web Bean ディスカバリ"

#~ msgid ""
#~ "<![CDATA[/**\n"
#~ "    * Gets list of all classes in classpath archives with META-INF/beans."
#~ "xml (or\n"
#~ "    * for WARs WEB-INF/beans.xml) files\n"
#~ "    * \n"
#~ "    * @return An iterable over the classes \n"
#~ "    */\n"
#~ "   public Iterable<Class<?>> discoverWebBeanClasses();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a list of all deployment descriptors in the app classpath\n"
#~ "    * \n"
#~ "    * @return An iterable over the beans.xml files \n"
#~ "    */\n"
#~ "   public Iterable<URL> discoverWebBeansXml();]]>"
#~ msgstr ""
#~ "<![CDATA[/**\n"
#~ "    * Gets list of all classes in classpath archives with META-INF/beans."
#~ "xml (or\n"
#~ "    * for WARs WEB-INF/beans.xml) files\n"
#~ "    * \n"
#~ "    * @return An iterable over the classes \n"
#~ "    */\n"
#~ "   public Iterable<Class<?>> discoverWebBeanClasses();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a list of all deployment descriptors in the app classpath\n"
#~ "    * \n"
#~ "    * @return An iterable over the beans.xml files \n"
#~ "    */\n"
#~ "   public Iterable<URL> discoverWebBeansXml();]]>"

#~ msgid ""
#~ "The discovery of Web Bean classes and <literal>beans.xml</literal> files "
#~ "is self-explanatory (the algorithm is described in Section 11.1 of the "
#~ "JSR-299 specification, and isn't repeated here)."
#~ msgstr ""
#~ "Web Beanのクラスと<literal>bean.xml</literal>ファイルの探索についてはここ"
#~ "では説明しません(アルゴリズムは、JSR-299スペックのセクション11.1で説明され"
#~ "ており、ここで繰り返し説明しません)。"

#~ msgid ""
#~ "Web Beans will run without an EJB container; in this case you don't need "
#~ "to implement the EJB SPI."
#~ msgstr ""
#~ "Web BeansはEJBコンテナなしで動作するでしょう。この場合、あなたは、EJB SPI"
#~ "を実装する必要はありません。"

#~ msgid ""
#~ "Web Beans also delegates EJB3 bean discovery to the container so that it "
#~ "doesn't have to scan for EJB3 annotations or parse <literal>ejb-jar.xml</"
#~ "literal>. For each EJB in the application an EJBDescriptor should be "
#~ "discovered:"
#~ msgstr ""
#~ "Web Beansはまた、EJB3のBeanの探索についてはコンテナへ委譲します。そのた"
#~ "め、EJB3のアノテーションをスキャンする必要はありませんし、また"
#~ "<literal>ejb-jar.xml</literal>を解析する必要はありません。アプリケーション"
#~ "における各EJBに対して一つずつEJBDescriptorが発見される必要があります。"

#~ msgid ""
#~ "<![CDATA[public interface EjbDescriptor<T>\n"
#~ "{\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets the EJB type\n"
#~ "    * \n"
#~ "    * @return The EJB Bean class\n"
#~ "    */\n"
#~ "   public Class<T> getType();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Gets the local business interfaces of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the local business interfaces\n"
#~ "    */\n"
#~ "   public Iterable<BusinessInterfaceDescriptor<?>> "
#~ "getLocalBusinessInterfaces();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets the remote business interfaces of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the remote business interfaces\n"
#~ "    */\n"
#~ "   public Iterable<BusinessInterfaceDescriptor<?>> "
#~ "getRemoteBusinessInterfaces();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Get the remove methods of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the remove methods\n"
#~ "    */\n"
#~ "   public Iterable<Method> getRemoveMethods();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the bean is stateless\n"
#~ "    * \n"
#~ "    * @return True if stateless, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isStateless();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the bean is a EJB 3.1 Singleton\n"
#~ "    * \n"
#~ "    * @return True if the bean is a singleton, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isSingleton();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the EJB is stateful\n"
#~ "    * \n"
#~ "    * @return True if the bean is stateful, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isStateful();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the EJB is and MDB\n"
#~ "    * \n"
#~ "    * @return True if the bean is an MDB, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isMessageDriven();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Gets the EJB name\n"
#~ "    * \n"
#~ "    * @return The name\n"
#~ "    */\n"
#~ "   public String getEjbName();]]>"
#~ msgstr ""
#~ "<![CDATA[public interface EjbDescriptor<T>\n"
#~ "{\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets the EJB type\n"
#~ "    * \n"
#~ "    * @return The EJB Bean class\n"
#~ "    */\n"
#~ "   public Class<T> getType();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Gets the local business interfaces of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the local business interfaces\n"
#~ "    */\n"
#~ "   public Iterable<BusinessInterfaceDescriptor<?>> "
#~ "getLocalBusinessInterfaces();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets the remote business interfaces of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the remote business interfaces\n"
#~ "    */\n"
#~ "   public Iterable<BusinessInterfaceDescriptor<?>> "
#~ "getRemoteBusinessInterfaces();\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Get the remove methods of the EJB\n"
#~ "    * \n"
#~ "    * @return An iterator over the remove methods\n"
#~ "    */\n"
#~ "   public Iterable<Method> getRemoveMethods();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the bean is stateless\n"
#~ "    * \n"
#~ "    * @return True if stateless, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isStateless();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the bean is a EJB 3.1 Singleton\n"
#~ "    * \n"
#~ "    * @return True if the bean is a singleton, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isSingleton();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the EJB is stateful\n"
#~ "    * \n"
#~ "    * @return True if the bean is stateful, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isStateful();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Indicates if the EJB is and MDB\n"
#~ "    * \n"
#~ "    * @return True if the bean is an MDB, false otherwise\n"
#~ "    */\n"
#~ "   public boolean isMessageDriven();\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Gets the EJB name\n"
#~ "    * \n"
#~ "    * @return The name\n"
#~ "    */\n"
#~ "   public String getEjbName();]]>"

#~ msgid ""
#~ "The resolution of <literal>@EJB</literal> (for injection into simple "
#~ "beans), the resolution of local EJBs (for backing session beans) and "
#~ "remote EJBs (for injection as a Java EE resource) is delegated to the "
#~ "container. You must provide an implementation of <literal>org.jboss."
#~ "webbeans.ejb.spi.EjbServices</literal> which provides these operations. "
#~ "For resolving the <literal>@EJB</literal> injection point, Web Beans will "
#~ "provide the <literal>InjectionPoint</literal>; for resolving local EJBs, "
#~ "the <literal>EjbDescriptor</literal> will be provided, and for remote "
#~ "EJBs the <literal>jndiName</literal>, <literal>mappedName</literal>, or "
#~ "<literal>ejbLink</literal> will be provided."
#~ msgstr ""
#~ "(シンプルBeansへのインジェションのための)<literal>@EJB</literal>、(背後の"
#~ "セッションBeanのための)ローカルEJB、そして(JavaEEリソースとしてのインジェ"
#~ "クションのための)リモートEJBの解決はコンテナに委譲されます。あなたはこれら"
#~ "の操作を提供する<literal>org.jboss.webbeans.ejb.spi.EjbServices</literal>"
#~ "の実装を提供する必要があります。<literal>@EJB</literal>インジェクションポ"
#~ "イントを解決するために、Web Beansは<literal>InjectionPoint</literal>を提供"
#~ "するでしょう。ローカルEJBの解決のために、<literal>EjbDescriptor</literal>"
#~ "が提供されるでしょう。そしてリモートEJBのために<literal>jndiName</"
#~ "literal>、<literal>jndiName</literal>、 <literal>ejbLink</literal>が提供さ"
#~ "れるでしょう。"

#~ msgid ""
#~ "To allow JPA integration, the <literal>JpaServices</literal> interface "
#~ "should be implemented."
#~ msgstr ""
#~ "JPAとの統合を可能にするためには、<literal>JpaServices</literal>インタ"
#~ "フェースが実装される必要があります。"

#~ msgid ""
#~ "Web Beans also needs to know what entities are in a deployment (so that "
#~ "they aren't managed by Web Beans). An implementation that detects "
#~ "entities through <literal>@Entity</literal> and <literal>orm.xml</"
#~ "literal> is provided by default. If you want to provide support for a "
#~ "entities defined by a JPA provider (such as Hibernate's <literal>.hbm."
#~ "xml</literal> you can wrap or replace the default implementation."
#~ msgstr ""
#~ "またWeb Beansは、どんなエンティティがデプロイされているか知る必要がありま"
#~ "す(それらがWeb Beansによって管理されないようにです)。デフォルトでは、"
#~ "<literal>@Entity</literal>と<literal>orm.xml</literal>を通してエンティティ"
#~ "を検出する実装が提供されます。もし、(Hibernateの<literal>.hbm.xml</"
#~ "literal>のような)JPAプロバイダによって定義されるEntityをサポートしたい場合"
#~ "は、デフォルトの実装をラップ、または置き換えることができます。"

#~ msgid ""
#~ "<![CDATA[EntityDiscovery delegate = bootstrap.getServices().get"
#~ "(EntityDiscovery.class);]]>"
#~ msgstr ""
#~ "<![CDATA[EntityDiscovery delegate = bootstrap.getServices().get"
#~ "(EntityDiscovery.class);]]>"

#~ msgid ""
#~ "<![CDATA[public interface TransactionServices\n"
#~ "{\n"
#~ "   /**\n"
#~ "    * Possible status conditions for a transaction. This can be used by "
#~ "SPI\n"
#~ "    * providers to keep track for which status an observer is used.\n"
#~ "    */\n"
#~ "   public static enum Status\n"
#~ "   {\n"
#~ "      ALL, SUCCESS, FAILURE\n"
#~ "   }\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Registers a synchronization object with the currently executing\n"
#~ "    * transaction.\n"
#~ "    * \n"
#~ "    * @see javax.transaction.Synchronization\n"
#~ "    * @param synchronizedObserver\n"
#~ "    */\n"
#~ "   public void registerSynchronization(Synchronization "
#~ "synchronizedObserver);\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Queries the status of the current execution to see if a transaction "
#~ "is\n"
#~ "    * currently active.\n"
#~ "    * \n"
#~ "    * @return true if a transaction is active\n"
#~ "    */\n"
#~ "   public boolean isTransactionActive();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public interface TransactionServices\n"
#~ "{\n"
#~ "   /**\n"
#~ "    * Possible status conditions for a transaction. This can be used by "
#~ "SPI\n"
#~ "    * providers to keep track for which status an observer is used.\n"
#~ "    */\n"
#~ "   public static enum Status\n"
#~ "   {\n"
#~ "      ALL, SUCCESS, FAILURE\n"
#~ "   }\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Registers a synchronization object with the currently executing\n"
#~ "    * transaction.\n"
#~ "    * \n"
#~ "    * @see javax.transaction.Synchronization\n"
#~ "    * @param synchronizedObserver\n"
#~ "    */\n"
#~ "   public void registerSynchronization(Synchronization "
#~ "synchronizedObserver);\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Queries the status of the current execution to see if a transaction "
#~ "is\n"
#~ "    * currently active.\n"
#~ "    * \n"
#~ "    * @return true if a transaction is active\n"
#~ "    */\n"
#~ "   public boolean isTransactionActive();\n"
#~ "}]]>"

#~ msgid ""
#~ "The enumeration <literal>Status</literal> is a convenience for "
#~ "implementors to be able to keep track of whether a synchronization is "
#~ "supposed to notify an observer only when the transaction is successful, "
#~ "or after a failure, or regardless of the status of the transaction."
#~ msgstr ""
#~ "列挙型の<literal>Status</literal>は、トランザクションが成功した、失敗し"
#~ "た、またはトランザクションの状態にかかわらず、同期がオブザーバに通知すべき"
#~ "かどうかを追跡することが可能な実装にとって便利です。"

#~ msgid "JMS services"
#~ msgstr "JMSサービス"

#~ msgid ""
#~ "A number of JMS operations are not container specific, and so should be "
#~ "provided via the SPI <literal>JmsServices</literal>. JMS does not specify "
#~ "how to obtain a <literal>ConnectionFactory</literal> so the SPI provides "
#~ "a method which should be used to look up a factory. Web Beans also "
#~ "delegates <literal>Destination</literal> lookup to the container via the "
#~ "SPI."
#~ msgstr ""
#~ "多くのJMS操作はコンテナ特有ではないため、SPI <literal>JmsServices</"
#~ "literal>を通して提供されるべきです。JMSは<literal>ConnectionFactory</"
#~ "literal>を取得する方法を指定しないため、SPIはファクトリをルックアップため"
#~ "に使用されるメソッドを提供します。また、Web BeansはSPIを通して"
#~ "<literal>Destination</literal>のルックアップをコンテナへ委譲します。"

#~ msgid ""
#~ "The resolution of <literal>@Resource</literal> (for injection into simple "
#~ "beans) and the resolution of resources (for injection as a Java EE "
#~ "resource) is delegated to the container. You must provide an "
#~ "implementation of <literal>ResourceServices</literal> which provides "
#~ "these operations. For resolving the <literal>@Resource</literal> "
#~ "injection, Web Beans will provide the <literal>InjectionPoint</literal>; "
#~ "and for Java EE resources, the <literal>jndiName</literal> or "
#~ "<literal>mappedName</literal> will be provided."
#~ msgstr ""
#~ "(シンプルBeansへのインジェクションのための)<literal>@Resource</literal>の"
#~ "解決と、(Java EEリソースとしてのインジェションのための)リソースの解決はコ"
#~ "ンテナに委譲されます。あなたはこれらの操作を提供する"
#~ "<literal>ResourceServices</literal>の実装を提供する必要があります。"
#~ "<literal>@Resource</literal>によるインジェクションを解決するために、Web "
#~ "Beansは<literal>InjectionPoint</literal>を提供するでしょう。そしてJavaEEリ"
#~ "ソースのために、<literal>jndiName</literal>または<literal>mappedName</"
#~ "literal>が提供されるでしょう。"

#~ msgid "Web Services"
#~ msgstr "Webサービス"

#~ msgid "JNDI"
#~ msgstr "JNDI"

#~ msgid ""
#~ "Web Beans delegates all JNDI operations to the container through the SPI."
#~ msgstr "Web Beansは全てのJNDI操作をSPIを通じてコンテナに委譲します。"

#~ msgid ""
#~ "A number of the SPI interface require JNDI lookup, and the class "
#~ "<literal>AbstractResourceServices</literal> provides JNDI/Java EE spec "
#~ "compliant lookup methods."
#~ msgstr ""
#~ "多くのSPIインタフェースがJNDIルックアップを必要とします。そして"
#~ "<literal>AbstractResourceServices</literal>クラスは、JNDI/Java EE仕様に準"
#~ "拠したルックアップメソッドを提供します。"

#~ msgid ""
#~ "<![CDATA[\n"
#~ "         public interface ResourceLoader {\n"
#~ "    \n"
#~ "   /**\n"
#~ "    * Creates a class from a given FQCN\n"
#~ "    * \n"
#~ "    * @param name The name of the clsas\n"
#~ "    * @return The class\n"
#~ "    */\n"
#~ "   public Class<?> classForName(String name);\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a resource as a URL by name\n"
#~ "    * \n"
#~ "    * @param name The name of the resource\n"
#~ "    * @return An URL to the resource\n"
#~ "    */\n"
#~ "   public URL getResource(String name);\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets resources as URLs by name\n"
#~ "    * \n"
#~ "    * @param name The name of the resource\n"
#~ "    * @return An iterable reference to the URLS\n"
#~ "    */\n"
#~ "   public Iterable<URL> getResources(String name);\n"
#~ "   \n"
#~ "}\n"
#~ "         ]]>"
#~ msgstr ""
#~ "<![CDATA[\n"
#~ "         public interface ResourceLoader {\n"
#~ "    \n"
#~ "   /**\n"
#~ "    * Creates a class from a given FQCN\n"
#~ "    * \n"
#~ "    * @param name The name of the clsas\n"
#~ "    * @return The class\n"
#~ "    */\n"
#~ "   public Class<?> classForName(String name);\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a resource as a URL by name\n"
#~ "    * \n"
#~ "    * @param name The name of the resource\n"
#~ "    * @return An URL to the resource\n"
#~ "    */\n"
#~ "   public URL getResource(String name);\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets resources as URLs by name\n"
#~ "    * \n"
#~ "    * @param name The name of the resource\n"
#~ "    * @return An iterable reference to the URLS\n"
#~ "    */\n"
#~ "   public Iterable<URL> getResources(String name);\n"
#~ "   \n"
#~ "}\n"
#~ "         ]]>"

#~ msgid "Servlet injection"
#~ msgstr "サーブレットインジェクション"

#~ msgid ""
#~ "Java EE / Servlet does not provide any hooks which can be used to provide "
#~ "injection into Servlets, so Web Beans provides an API to allow the "
#~ "container to request JSR-299 injection for a Servlet."
#~ msgstr ""
#~ "Java EE/サーブレットはインジェクションをサーブレットに提供するためのフック"
#~ "を提供していません。そのためWeb Beansは、コンテナがサーブレットでJSR-299の"
#~ "インジェクションを要求できるように、APIを提供します。"

#~ msgid ""
#~ "To be compliant with JSR-299, the container should request servlet "
#~ "injection for each newly instantiated servlet after the constructor "
#~ "returns and before the servlet is placed into service."
#~ msgstr ""
#~ "JSR-299に準拠するために、コンストラクタが呼び出されサーブレットがサービス"
#~ "を開始する前に、コンテナは、新たにインスタンス化されたサーブレットのために"
#~ "インジェクションを要求するべきです。"

#~ msgid ""
#~ "To perform injection on a servlet call <literal>WebBeansManager."
#~ "injectServlet()</literal>. The manager can be obtained from "
#~ "<literal>Bootstrap.getManager()</literal>."
#~ msgstr ""
#~ "サーブレットにインジェクションを実行するには、<literal>WebBeansManager."
#~ "injectServlet()</literal>を呼び出します。マネージャは<literal>Bootstrap."
#~ "getManager()</literal>から取得することができます。"

#~ msgid ""
#~ "If you are integrating the Web Beans into a JSF environment you must "
#~ "register <literal>org.jboss.webbeans.jsf.WebBeansPhaseListener</literal> "
#~ "as a phase listener, and <literal>org.jboss.webbeans.el."
#~ "WebBeansELREsolver</literal> as an EL resolver, either automatically, or "
#~ "through user configuration, for each Web Beans application which uses JSF."
#~ msgstr ""
#~ "Web BeansをJSF環境と統合しているなら、自動的またはユーザ設定によって、"
#~ "<literal>org.jboss.webbeans.jsf.WebBeansPhaseListener</literal>をフェーズ"
#~ "リスナーとして、<literal>org.jboss.webbeans.el.WebBeansELREsolver</"
#~ "literal>をELリゾルバーとして登録する必要があります。この登録は、JSFを使用"
#~ "する各Web Beansアプリケーションで必要です。"

#~ msgid ""
#~ "If you are integrating the Web Beans into an environment that supports "
#~ "deployment of applications, you must insert the <literal>webbeans-core."
#~ "jar</literal> into the applications isolated classloader. It cannot be "
#~ "loaded from a shared classloader."
#~ msgstr ""
#~ "Web Beansを複数のアプリケーションのデプロイをサポートする環境と統合してい"
#~ "るなら、<literal>webbeans-core.jar</literal>を、クラスローダが分離されてい"
#~ "るアプリケーションに加える必要があります。このJARファイルは共有クラスロー"
#~ "ダではロードすることはできません。"

#~ msgid ""
#~ "It should be possible to run Web Beans in an SE environment, but you'll "
#~ "to do more work, adding your own contexts and lifecycle. The Web Beans RI "
#~ "currently doesn't expose lifecycle extension points, so you would have to "
#~ "code directly against Web Beans RI classes."
#~ msgstr ""
#~ "SE環境においてWeb Beansを実行することは可能であるべきです。しかし、独自の"
#~ "コンテキストとライフサイクルを追加するためには、より多くの作業が必要です。"
#~ "Web Beans RIは、現在はライフサイクルの拡張ポイントを公開していません。その"
#~ "ため、Web Beans RIのクラスに対するコードを直接記述する必要があります。"

#~ msgid ""
#~ "All interfaces in the SPI support the decorator pattern and provide a "
#~ "<literal>Forwarding</literal> class."
#~ msgstr ""
#~ "SPIのすべてのインタフェースがデコレータパターンをサポートしており、"
#~ "<literal>Forwarding</literal>クラスを供給します。"

#~ msgid ""
#~ "<![CDATA[public interface EjbServices\n"
#~ "{\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a descriptor for each EJB in the application\n"
#~ "    * \n"
#~ "    * @return The bean class to descriptor map \n"
#~ "    */\n"
#~ "   public Iterable<EjbDescriptor<?>> discoverEjbs();]]>"
#~ msgstr ""
#~ "<![CDATA[public interface EjbServices\n"
#~ "{\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Gets a descriptor for each EJB in the application\n"
#~ "    * \n"
#~ "    * @return The bean class to descriptor map \n"
#~ "    */\n"
#~ "   public Iterable<EjbDescriptor<?>> discoverEjbs();]]>"

#~ msgid ""
#~ "Just as resolution of <literal>@EJB</literal> is delegated to the "
#~ "container, so is resolution of <literal>@PersistenceContext</literal>."
#~ msgstr ""
#~ "<literal>@EJB</literal>の解決がコンテナに委譲されると同様に、"
#~ "<literal>@PersistenceContext</literal>の解決もコンテナに委譲されます。"

#~ msgid ""
#~ "OPEN ISSUE: Web Beans also requires the container to provide a list of "
#~ "entities in the deployment, so that they aren't discovered as simple "
#~ "beans."
#~ msgstr ""
#~ "OPEN ISSUE: Web Beansはまた、シンプルなBeansとして発見されないように、デプ"
#~ "ロイ中にエンティティのリストを提供するコンテナを必要とします。"

#~ msgid ""
#~ "The Web Beans RI implements JNDI binding and lookup according to "
#~ "standards, however you may want to alter the binding and lookup (for "
#~ "example in an environment where JNDI isn't available). To do this, "
#~ "implement <literal>org.jboss.webbeans.resources.spi.NamingContext</"
#~ "literal>:"
#~ msgstr ""
#~ "Web Beans RIはJNDIバインディングとルックアップを標準に準じて実装していま"
#~ "す。しかしながら、バインディングとルックアップを(たとえば、JNDIが利用でき"
#~ "ない環境において)変更したいかもしれません。変更を行うには、<literal>org."
#~ "jboss.webbeans.resources.spi.NamingContext</literal>を実装してください。"

#~ msgid ""
#~ "<![CDATA[public interface NamingContext extends Serializable {\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Typed JNDI lookup\n"
#~ "    * \n"
#~ "    * @param <T> The type\n"
#~ "    * @param name The JNDI name\n"
#~ "    * @param expectedType The expected type\n"
#~ "    * @return The object\n"
#~ "    */\n"
#~ "   public <T> T lookup(String name, Class<? extends T> expectedType);\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Binds an item to JNDI\n"
#~ "    * \n"
#~ "    * @param name The key to bind under\n"
#~ "    * @param value The item to bind\n"
#~ "    */\n"
#~ "   public void bind(String name, Object value);\n"
#~ "   \n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public interface NamingContext extends Serializable {\n"
#~ "   \n"
#~ "   /**\n"
#~ "    * Typed JNDI lookup\n"
#~ "    * \n"
#~ "    * @param <T> The type\n"
#~ "    * @param name The JNDI name\n"
#~ "    * @param expectedType The expected type\n"
#~ "    * @return The object\n"
#~ "    */\n"
#~ "   public <T> T lookup(String name, Class<? extends T> expectedType);\n"
#~ "\n"
#~ "   /**\n"
#~ "    * Binds an item to JNDI\n"
#~ "    * \n"
#~ "    * @param name The key to bind under\n"
#~ "    * @param value The item to bind\n"
#~ "    */\n"
#~ "   public void bind(String name, Object value);\n"
#~ "   \n"
#~ "}]]>"

#~ msgid "Servlet listener and filters"
#~ msgstr "サーブレットリスナーとフィルタ"
