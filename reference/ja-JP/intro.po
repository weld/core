# Language ja-JP translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-03-02T13:07:18\n"
"PO-Revision-Date: 2009-06-09 03:50+0900\n"
"Last-Translator: Shinobu NOGAMI <s-nogami@sourceforge.jp>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Introduction"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"So you're keen to get started writing your first bean? Or perhaps you're "
"skeptical, wondering what kinds of hoops the CDI specification will make you "
"jump through! The good news is that you've probably already written and used "
"hundreds, perhaps thousands of beans. CDI just makes it easier to actually "
"use them to build an application!"
msgstr ""
"あなたは、すでに最初の Web Bean を書き始めることに夢中ですか。あるいは、たぶ"
"ん Web Beans 仕様によって、どのような種類のフープを跳ぶことができるのかを不思"
"議に思って疑い深くなっているのかもしれません。朗報なことは、すでにあなたはお"
"そらく数百、もしかすると数千の Web Beans を書いて使用しているかもしれないとい"
"うことです。あなたは最初の書いた Web Bean を思い出すことさえできないかもしれ"
"ません。"

#. Tag: title
#, fuzzy, no-c-format
msgid "What is a bean?"
msgstr "Web Bean とは何か?"

#. Tag: para
#, no-c-format
msgid ""
"A bean is exactly what you think it is. Only now, it has a true identity in "
"the container environment."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Prior to Java EE 6, there was no clear definition of the term \"bean\" in "
"the Java EE platform. Of course, we've been calling Java classes used in web "
"and enterprise applications \"beans\" for years. There were even a couple of "
"different kinds of things called \"beans\" in EE specifications, including "
"EJB beans and JSF managed beans. Meanwhile, other third-party frameworks "
"such as Spring and Seam introduced their own ideas of what it meant to be a "
"\"bean\". What we've been missing is a common definition."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Java EE 6 finally lays down that common definition in the Managed Beans "
"specification. Managed Beans are defined as container-managed objects with "
"minimal programming restrictions, otherwise known by the acronym POJO (Plain "
"Old Java Object). They support a small set of basic services, such as "
"resource injection, lifecycle callbacks and interceptors. Companion "
"specifications, such as EJB and CDI, build on this basic model. But, "
"<emphasis>at last</emphasis>, there's a uniform concept of a bean and a "
"lightweight component model that's aligned across the Java EE platform."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"With very few exceptions, almost every concrete Java class that has a "
"constructor with no parameters (or a constructor designated with the "
"annotation <literal>@Inject</literal>) is a bean. This includes every "
"JavaBean and every EJB session bean. If you've already got some JavaBeans or "
"session beans lying around, they're already beans—you won't need any "
"additional special metadata. There's just little one thing you need to do "
"before you can start injecting them into stuff: you need to put them in an "
"archive (a jar, or a Java EE module such as a war or EJB jar) that contains "
"a special marker file: <literal>META-INF/beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The JavaBeans and EJBs you've been writing every day, up until now, have not "
"been able to take advantage of the new services defined by the CDI "
"specification. But you'll be able to use every one of them with CDI—allowing "
"the container to create and destroy instances of your beans and associate "
"them with a designated context, injecting them into other beans, using them "
"in EL expressions, specializing them with qualifier annotations, even adding "
"interceptors and decorators to them—without modifying your existing code. At "
"most, you'll need to add some annotations."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now let's see how to create your first bean that actually uses CDI."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Getting our feet wet"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Suppose that we have two existing Java classes that we've been using for "
"years in various applications. The first class parses a string into a list "
"of sentences:"
msgstr ""
"様々なアプリケーションで何年間も使っている２つの既存の Java クラスがあると仮"
"定します。１つ目のクラスは、文のリストへ文字列に構文解析します:"

#. Tag: para
#, no-c-format
msgid ""
"The second existing class is a stateless session bean front-end for an "
"external system that is able to translate sentences from one language to "
"another:"
msgstr ""
"２つ目の現存するクラスは、１つの言語からもう１つの言語への文を翻訳することが"
"できる外部システムのフロントエンドとなるステートレスセッション Bean です:"

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>Translator</literal> is the EJB local interface:"
msgstr "ここで <literal>Translator</literal> はローカルインターフェースです:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Unfortunately, we don't have a class that translates whole text documents. "
"So let's write a bean for this job:"
msgstr ""
"運悪く、すべてのテキストドキュメントを翻訳する既存のクラスはありません。そこ"
"でこの仕事をする Web Bean を書きましょう:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"But wait! <literal>TextTranslator</literal> does not have a constructor with "
"no parameters! Is it still a bean? If you remember, a class that does not "
"have a constructor with no parameters can still be a bean if it has a "
"constructor annotated <literal>@Inject</literal>."
msgstr ""
"しかし待ってください: <literal>TextTranslator</literal> はパラメータなしのコ"
"ンストラクタがありません。それはまだ Web Bean ですか。まあ、"
"<literal>@Initializer</literal> アノテーションを付けたコンストラクタがあれ"
"ば、パラメータなしのコンストラクタを持たないクラスもまだ Web Bean であること"
"ができます。"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"As you've guessed, the <literal>@Inject</literal> annotation has something "
"to do with dependency injection! <literal>@Inject</literal> may be applied "
"to a constructor or method of a bean, and tells the container to call that "
"constructor or method when instantiating the bean. The container will inject "
"other beans into the parameters of the constructor or method."
msgstr ""
"あなたが推測しているように、 <literal>@Initializer</literal> ノテーションは依"
"存性注入と関係があります。<literal>@Initializer</literal> は、Web Bean のコン"
"ストラクタあるいはメソッドに適用することができ、Web Bean をインスタンス化する"
"ときに Web Bean マネージャにそのコンストラクタあるいはメソッドを呼ぶ出すよう"
"に伝えます。Web Beanマネージャは、コンストラクタあるいはメソッドのパラメータ"
"に他の Web Beans を注入します。"

#. Tag: para
#, no-c-format
msgid ""
"We may obtain an instance of <literal>TextTranslator</literal> by injecting "
"it into a constructor, method or field of a bean, or a field or method of a "
"Java EE component class such as a servlet. The container chooses the object "
"to be injected based on the type of the injection point, not the name of the "
"field, method or parameter."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Let's create a UI controller bean that uses field injection to obtain an "
"instance of the <literal>TextTranslator</literal>, translating the text "
"entered by a user:"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Field injection of <literal>TextTranslator</literal> instance"
msgstr "ここで <literal>Translator</literal> はローカルインターフェースです:"

#. Tag: para
#, no-c-format
msgid ""
"Notice the controller bean is request-scoped and named. Since this "
"combination is so common in web applications, there's a built-in annotation "
"for it in CDI that we could have used as a shorthand. When the (stereotype) "
"annotation <literal>@Model</literal> is declared on a class, it creates a "
"request-scoped and named bean."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Alternatively, we may obtain an instance of <literal>TextTranslator</"
"literal> programmatically from an injected instance of <literal>Instance</"
"literal>, parameterized with the bean type:"
msgstr ""
"Web Bean、サーブレットあるいは EJB へ注入することによって "
"<literal>TextTranslator</literal> のインスタンスを取得することができます:"

#. Tag: para
#, no-c-format
msgid ""
"Notice that it isn't necessary to create a getter or setter method to inject "
"one bean into another. CDI can access an injected field directly (even if "
"it's private!), which sometimes helps eliminate some wasteful code. The name "
"of the field is arbitrary. It's the field's type that determines what is "
"injected."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"At system initialization time, the container must validate that exactly one "
"bean exists which satisfies each injection point. In our example, if no "
"implementation of <literal>Translator</literal> is available—if the "
"<literal>SentenceTranslator</literal> EJB was not deployed—the container "
"would inform us of an <emphasis>unsatisfied dependency</emphasis>. If more "
"than one implementation of <literal>Translator</literal> were available, the "
"container would inform us of the <emphasis>ambiguous dependency</emphasis>."
msgstr ""
"システムの初期化時に、Web Bean マネージャはそれぞれのインジェクションポイント"
"の条件を満たすまさに１つの Web Bean が存在することを検証しなければなりませ"
"ん。サンプルで、もし利用可能な <literal>Translator</literal> の実装がなければ"
"&#151;、あるいは <literal>SentenceTranslator</literal> EJB がデプロイされてい"
"なければ&#151;、Web Bean マネージャーは、"
"<literal>UnsatisfiedDependencyException</literal> をスローします。もし１つ以"
"上の <literal>Translator</literal> の実装が利用可能であれば、Web Beanマネー"
"ジャは、<literal>AmbiguousDependencyException</literal> をスローします。"

#. Tag: para
#, no-c-format
msgid ""
"Before we get too deep in the details, let's pause and examine a bean's "
"anatomy. What aspects of the bean are significant, and what gives it its "
"identity? Instead of just giving examples of beans, we're going to define "
"what <emphasis>makes</emphasis> something a bean."
msgstr ""

#, fuzzy
#~ msgid ""
#~ "<![CDATA[public class SentenceParser {\n"
#~ "   public List<String> parse(String text) { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public class SentenceParser {\n"
#~ "    public List<String> parse(String text) { ... }\n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Stateless\n"
#~ "public class SentenceTranslator implements Translator {\n"
#~ "   public String translate(String sentence) { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Stateless\n"
#~ "public class SentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) { ... }\n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Local\n"
#~ "public interface Translator {\n"
#~ "   public String translate(String sentence);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Local\n"
#~ "public interface Translator {\n"
#~ "    public String translate(String sentence);\n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[public class TextTranslator {\n"
#~ "   private SentenceParser sentenceParser;\n"
#~ "   private Translator sentenceTranslator;\n"
#~ "    \n"
#~ "   @Inject\n"
#~ "   TextTranslator(SentenceParser sentenceParser, Translator "
#~ "sentenceTranslator) {\n"
#~ "      this.sentenceParser = sentenceParser;\n"
#~ "      this.sentenceTranslator = sentenceTranslator;\n"
#~ "   }\n"
#~ "    \n"
#~ "   public String translate(String text) {\n"
#~ "      StringBuilder sb = new StringBuilder();\n"
#~ "      for (String sentence: sentenceParser.parse(text)) {\n"
#~ "          sb.append(sentenceTranslator.translate(sentence));\n"
#~ "      }\n"
#~ "      return sb.toString();\n"
#~ "   }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public class TextTranslator {\n"
#~ "    \n"
#~ "    private SentenceParser sentenceParser;\n"
#~ "    private Translator sentenceTranslator;\n"
#~ "    \n"
#~ "    @Initializer\n"
#~ "    TextTranslator(SentenceParser sentenceParser, Translator "
#~ "sentenceTranslator) {\n"
#~ "        this.sentenceParser = sentenceParser;\n"
#~ "        this.sentenceTranslator = sentenceTranslator;\n"
#~ "    }\n"
#~ "    \n"
#~ "    public String translate(String text) {\n"
#~ "        StringBuilder sb = new StringBuilder();\n"
#~ "        for (String sentence: sentenceParser.parse(text)) {\n"
#~ "            sb.append(sentenceTranslator.translate(sentence));\n"
#~ "        }\n"
#~ "        return sb.toString();\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Inject Instance<TextTranslator> textTranslatorInstance;\n"
#~ "...\n"
#~ "public void translate() {\n"
#~ "   textTranslatorInstance.get().translate(inputText);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Initializer\n"
#~ "public setTextTranslator(TextTranslator textTranslator) {\n"
#~ "    this.textTranslator = textTranslator;\n"
#~ "}]]>"

#~ msgid "Getting started with Web Beans"
#~ msgstr "Web Beans を始めよう"

#~ msgid "Your first Web Bean"
#~ msgstr "初めての Web Bean"

#~ msgid ""
#~ "With certain, very special exceptions, every Java class with a "
#~ "constructor that accepts no parameters is a Web Bean. That includes every "
#~ "JavaBean. Furthermore, every EJB 3-style session bean is a Web Bean. "
#~ "Sure, the JavaBeans and EJBs you've been writing every day have not been "
#~ "able to take advantage of the new services defined by the Web Beans "
#~ "specification, but you'll be able to use every one of them as Web Beans "
#~ "&#151; injecting them into other Web Beans, configuring them via the Web "
#~ "Beans XML configuration facility, even adding interceptors and decorators "
#~ "to them &#151; without touching your existing code."
#~ msgstr ""
#~ "ある特定のとても特別な例外を除いて、パラメータなしのコンストラクタを持つす"
#~ "べての Java クラスは、Web Bean です。それはすべての JavaBean を含みます。"
#~ "さらに、すべての EJB 3 仕様のセッション Bean も、Web Bean です。確かに、毎"
#~ "日書いている JavaBean と EJB は、Web Beans 仕様によって定義された新しい"
#~ "サービスを利用することができていません。しかし、それらすべての各々は、"
#~ "&#151; Web Beans の XML 構成機能によって構成し、そしてそれらにインタセプタ"
#~ "とデコレータを加えることによって &#151;、現存するコードに触れることなく、"
#~ "Web Beans として使用することができるでしょう。"

#~ msgid ""
#~ "Alternatively, we may obtain an instance by directly calling a method of "
#~ "the Web Bean manager:"
#~ msgstr ""
#~ "もう１つの方法として、Web Bean マネージャのメソッドを直接に呼ぶことによっ"
#~ "てインスタンスを取得することもできます:"

#~ msgid ""
#~ "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator."
#~ "class);]]>"
#~ msgstr ""
#~ "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator."
#~ "class);]]>"

#~ msgid "So what, <emphasis>exactly</emphasis>, is a Web Bean?"
#~ msgstr "それでは、Web Bean とは、<emphasis> 一体</emphasis> 何か。"

#~ msgid ""
#~ "A Web Bean is an application class that contains business logic. A Web "
#~ "Bean may be called directly from Java code, or it may be invoked via "
#~ "Unified EL. A Web Bean may access transactional resources. Dependencies "
#~ "between Web Beans are managed automatically by the Web Bean manager. Most "
#~ "Web Beans are <emphasis>stateful</emphasis> and <emphasis>contextual</"
#~ "emphasis>. The lifecycle of a Web Bean is always managed by the Web Bean "
#~ "manager."
#~ msgstr ""
#~ "Web Bean は、ビジネスロジックを含むアプリケーションクラスです。Web Bean "
#~ "は、直接 Java コードから呼び出すこともでき、あるいはユニファイド EL から呼"
#~ "び出すこともできます。Web Bean は、トランザクションのリソースにアクセスす"
#~ "ることもできます。Web Beans 間での依存関係は、Web Bean マネージャによって"
#~ "自動的に管理されます。 ほとんどのWeb Beansは <emphasis>ステートフル</"
#~ "emphasis> で <emphasis>コンテキスト依存</emphasis> です。Web Bean のライフ"
#~ "サイクルは Web Bean マネージャによっていつも管理されます。"

#~ msgid ""
#~ "Let's back up a second. What does it really mean to be \"contextual\"? "
#~ "Since Web Beans may be stateful, it matters <emphasis>which</emphasis> "
#~ "bean instance I have. Unlike a stateless component model (for example, "
#~ "stateless session beans) or a singleton component model (such as "
#~ "servlets, or singleton beans), different clients of a Web Bean see the "
#~ "Web Bean in different states. The client-visible state depends upon which "
#~ "instance of the Web Bean the client has a reference to."
#~ msgstr ""
#~ "少しの間ゆっくり考えてみましょう。「コンテキスト依存である」ということは、"
#~ "本当に何を意味するのでしょうか。Web Beans はステートフルですので、 "
#~ "<emphasis>どの</emphasis> Bean インスタンスを持っているかが重要です。ス"
#~ "テートレスなコンポーネントモデル(例えば、ステートレスセッション bean)ある"
#~ "いはシングルトンコンポーネントモデル(例えばサーブレット、あるいはシングル"
#~ "トン bean)と違って、Web Bean の異なるクライアントは、異なる状態で Web "
#~ "Bean を参照します。クライアントに見える状態は、Web Bean のどちらのインスタ"
#~ "ンスへのリファレンスをクライアントが持っているかによります。"

#~ msgid ""
#~ "However, like a stateless or singleton model, but <emphasis>unlike</"
#~ "emphasis> stateful session beans, the client does not control the "
#~ "lifecycle of the instance by explicitly creating and destroying it. "
#~ "Instead, the <emphasis>scope</emphasis> of the Web Bean determines:"
#~ msgstr ""
#~ "しかし、しかしステートフルなセッション bean とは <emphasis>違って</"
#~ "emphasis>、クライアントは、ステートレスあるいはシングルトンモデルと同じよ"
#~ "うに、明示的にインスタンスの生成と破棄を行ってインスタンスのライフサイクル"
#~ "を制御はしません。その代わりに、Web Bean の <emphasis>スコープ</emphasis> "
#~ "は以下で決定されます:"

#~ msgid "the lifecycle of each instance of the Web Bean and"
#~ msgstr "Web Bean のそれぞれのインスタンスのライフサイクル"

#~ msgid ""
#~ "which clients share a reference to a particular instance of the Web Bean."
#~ msgstr "Web Bean のある特定のリファレンスをどのクライアントが共用しているか"

#~ msgid ""
#~ "For a given thread in a Web Beans application, there may be an "
#~ "<emphasis>active context</emphasis> associated with the scope of the Web "
#~ "Bean. This context may be unique to the thread (for example, if the Web "
#~ "Bean is request scoped), or it may be shared with certain other threads "
#~ "(for example, if the Web Bean is session scoped) or even all other "
#~ "threads (if it is application scoped)."
#~ msgstr ""
#~ "Web Beans アプリケーションに与えられたスレッドには、Web Bean のスコープに"
#~ "関連付けられた <emphasis>アクティブコンテキスト</emphasis> があります。こ"
#~ "のコンテキストは、そのスレッドに固有かもしれません(例えば、Web Bean がリク"
#~ "エストスコープの場合)。あるいは、それはその他のスレッド間で共用されるかも"
#~ "しれません(例えば、Web Bean がセッションスコープの場合)。あるいは、それは"
#~ "すべてのスレッドで共用されるかもしれません(アプリケーションスコープの場"
#~ "合)。"

#~ msgid ""
#~ "Clients (for example, other Web Beans) executing in the same context will "
#~ "see the same instance of the Web Bean. But clients in a different context "
#~ "will see a different instance."
#~ msgstr ""
#~ "同じコンテキストで実行しているクライアント(例えば、他の Web Beans)は、同じ"
#~ "インスタンスの Web Bean を参照するでしょう。しかし、異なるコンテキストのク"
#~ "ライアントは、異なるインスタンスを参照します。"

#~ msgid ""
#~ "One great advantage of the contextual model is that it allows stateful "
#~ "Web Beans to be treated like services! The client need not concern itself "
#~ "with managing the lifecycle of the Web Bean it is using, <emphasis>nor "
#~ "does it even need to know what that lifecyle is.</emphasis> Web Beans "
#~ "interact by passing messages, and the Web Bean implementations define the "
#~ "lifecycle of their own state. The Web Beans are loosely coupled because:"
#~ msgstr ""
#~ "コンテキスト依存モデルのすばらしい利点の１つには、ステートフルな Web "
#~ "Beans をサービスのように取り扱うことを可能にすることがあります。クライアン"
#~ "トは、使用している Web Bean のライフサイクルの管理に関与する必要はありませ"
#~ "ん。 <emphasis>またさらにライフサイクルが何であるかも知っている必要はあり"
#~ "ません。</emphasis> Web Beansは、メッセージを送信することによって相互に作"
#~ "用し、 Web Bean の実装が自分自身の状態のライフサイクルを定義します。Web "
#~ "Beans が疎結合なのは以下の理由からです:"

#~ msgid "they interact via well-defined public APIs"
#~ msgstr "明確に定義されたパブリックなAPI経由で相互に作用する"

#~ msgid "their lifecycles are completely decoupled"
#~ msgstr "ライフサイクルは完全に切り離されている"

#~ msgid ""
#~ "We can replace one Web Bean with a different Web Bean that implements the "
#~ "same API and has a different lifecycle (a different scope) without "
#~ "affecting the other Web Bean implementation. In fact, Web Beans defines a "
#~ "sophisticated facility for overriding Web Bean implementations at "
#~ "deployment time, as we will see in <xref linkend=\"deploymenttypes\"/>."
#~ msgstr ""
#~ "１つの Web Bean は、その他の Web Bean の実装には影響せずに、同じAPIを実装"
#~ "した異なるライフサイクル(異なるスコープ)を持つ別の Web Bean に置き換えるこ"
#~ "とができます。<xref linkend=\"deploymenttypes\"/> で説明するように、実際 "
#~ "Web Beansは、デプロイメント時に Web Bean の実装をオーバーライドするための"
#~ "洗練された機構を定義します。"

#~ msgid ""
#~ "Note that not all clients of a Web Bean are Web Beans. Other objects such "
#~ "as Servlets or Message-Driven Beans &#151; which are by nature not "
#~ "injectable, contextual objects &#151; may also obtain references to Web "
#~ "Beans by injection."
#~ msgstr ""
#~ "すべての Web Bean のクライアントが必ずしも Web Beans ではないことに注意し"
#~ "てください。サーブレットまたはメッセージ駆動 Bean といった他のオブジェクト"
#~ "&#151;生まれつき注入可能でなく、コンテキスト依存ではいオブジェクト&#151; "
#~ "が注入によって Web Beans へのリファレンスを取得することもあります。"

#~ msgid "Enough hand-waving. More formally, according to the spec:"
#~ msgstr "より正式には、仕様は次の通りです:"

#~ msgid "A Web Bean comprises:"
#~ msgstr "Web Bean は以下の要素から構成されます:"

#~ msgid "A (nonempty) set of API types"
#~ msgstr "(空ではない) API タイプのセット"

#~ msgid "A (nonempty) set of binding annotation types"
#~ msgstr "(空ではない) バインディングアノテーションタイプのセット"

#~ msgid "A scope"
#~ msgstr "スコープ"

#~ msgid "A deployment type"
#~ msgstr "デプロイメントタイプ"

#~ msgid "Optionally, a Web Bean name"
#~ msgstr "(オプションの) Web Bean 名"

#~ msgid "A set of interceptor binding types"
#~ msgstr "インタセプタのバインディングタイプのセット"

#~ msgid "A Web Bean implementation"
#~ msgstr "Web Bean インプリメンテーション"

#~ msgid "Let's see what some of these terms mean, to the Web Bean developer."
#~ msgstr ""
#~ "Web Bean 開発者にとって、これらの用語が何を意味するのか確認しましょう。"

#~ msgid "API types, binding types and dependency injection"
#~ msgstr "API タイプとバインディングタイプと依存性注入"

#~ msgid ""
#~ "Web Beans usually acquire references to other Web Beans via dependency "
#~ "injection. Any injected attribute specifies a \"contract\" that must be "
#~ "satisfied by the Web Bean to be injected. The contract is:"
#~ msgstr ""
#~ "Web Beans は、通常は依存性注入によって他の Web Beans への参照を獲得しま"
#~ "す。注入されるどの属性も、注入される Web Bean が条件を満たさなければならな"
#~ "い「契約」を指定します。契約は以下の通りです:"

#~ msgid "an API type, together with"
#~ msgstr "API タイプ"

#~ msgid "a set of binding types."
#~ msgstr "バインディングタイプのセット"

#~ msgid ""
#~ "An API is a user-defined class or interface. (If the Web Bean is an EJB "
#~ "session bean, the API type is the <literal>@Local</literal> interface or "
#~ "bean-class local view). A binding type represents some client-visible "
#~ "semantic that is satisfied by some implementations of the API and not by "
#~ "others."
#~ msgstr ""
#~ "API は、ユーザ定義のクラスあるいはインタフェースです。(もし Web Bean が "
#~ "EJB セッション Bean ならば、API タイプは <literal>@Local</literal>  イン"
#~ "ターフェースか bean クラスのローカルビューです)。バインディングタイプは、"
#~ "API のある実装によっては満たされ他のものでは満足されない、クライアントに見"
#~ "えるセマンティックを表します。"

#~ msgid ""
#~ "Binding types are represented by user-defined annotations that are "
#~ "themselves annotated <literal>@BindingType</literal>. For example, the "
#~ "following injection point has API type <literal>PaymentProcessor</"
#~ "literal> and binding type <literal>@CreditCard</literal>:"
#~ msgstr ""
#~ "バインディングタイプは、それ自身が <literal>@BindingType</literal> アノ"
#~ "テーションを付与されたユーザ定義のアノテーションによって表されます。例え"
#~ "ば、以下のインジェクションポイントは、API タイプ "
#~ "<literal>PaymentProcessor</literal> とバインディングタイプ "
#~ "<literal>@CreditCard</literal> を持っています:"

#~ msgid "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"
#~ msgstr "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"

#~ msgid ""
#~ "If no binding type is explicitly specified at an injection point, the "
#~ "default binding type <literal>@Current</literal> is assumed."
#~ msgstr ""
#~ "もしどのバインディングタイプもインジェクションポイントで明示的に指定されな"
#~ "ければ、デフォルトのバインディングタイプ <literal>@Current</literal> が想"
#~ "定されます。"

#~ msgid ""
#~ "For each injection point, the Web Bean manager searches for a Web Bean "
#~ "which satisfies the contract (implements the API, and has all the binding "
#~ "types), and injects that Web Bean."
#~ msgstr ""
#~ "各々のインジェクションポイントに対して、Web Bean マネージャは、契約(API の"
#~ "実装、すべてのバインディングタイプの所持)の条件を満たす Web Bean を探し、"
#~ "その Web Bean を注入します。"

#~ msgid ""
#~ "The following Web Bean has the binding type <literal>@CreditCard</"
#~ "literal> and implements the API type <literal>PaymentProcessor</literal>. "
#~ "It could therefore be injected to the example injection point:"
#~ msgstr ""
#~ "以下の Web Bean は、バインディングタイプ <literal>@CreditCard</literal> を"
#~ "持ち、API タイプ <literal>PaymentProcessor</literal> を実装しています。そ"
#~ "れゆえ、サンプルのインジェクションポイントに注入することができます:"

#~ msgid ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"

#~ msgid ""
#~ "If a Web Bean does not explicitly specify a set of binding types, it has "
#~ "exactly one binding type: the default binding type <literal>@Current</"
#~ "literal>."
#~ msgstr ""
#~ "もし Web Bean が明示的にバインディングタイプのセットを指定しなければ、それ"
#~ "は１つのバインディングタイプ : デフォルトのバインディングタイプ"
#~ "<literal>@Current</literal> を持つことになります。"

#~ msgid ""
#~ "Web Beans defines a sophisticated but intuitive <emphasis>resolution "
#~ "algorithm</emphasis> that helps the container decide what to do if there "
#~ "is more than one Web Bean that satisfies a particular contract. We'll get "
#~ "into the details in <xref linkend=\"injection\"/>."
#~ msgstr ""
#~ "Web Beans は、もし特定の契約と満たす１つ以上の Web Bean があったときに、コ"
#~ "ンテナが何をすべきかを決定するのを助ける洗練されたしかも直観的な "
#~ "<emphasis>解決アルゴリズム</emphasis> を定義します。その詳細は <xref "
#~ "linkend=\"injection\"/> で説明します。"

#~ msgid "Deployment types"
#~ msgstr "デプロイメントタイプ"

#~ msgid ""
#~ "<emphasis>Deployment types</emphasis> let us classify our Web Beans by "
#~ "deployment scenario. A deployment type is an annotation that represents a "
#~ "particular deployment scenario, for example <literal>@Mock</literal>, "
#~ "<literal>@Staging</literal> or <literal>@AustralianTaxLaw</literal>. We "
#~ "apply the annotation to Web Beans which should be deployed in that "
#~ "scenario. A deployment type allows a whole set of Web Beans to be "
#~ "conditionally deployed, with a just single line of configuration."
#~ msgstr ""
#~ "<emphasis>デプロイメントタイプ</emphasis> は、デプロイメントシナリオによっ"
#~ "て Web Beans を分類させます。デプロイメントタイプは、特定のデプロイメント"
#~ "シナリオを表すアノテーション、例えば <literal>@Mock</literal> や "
#~ "<literal>@Staging</literal>、<literal>@AustralianTaxLaw</literal> です。そ"
#~ "のシナリオでデプロイされるべき Web Beans にアノテーションを適用します。デ"
#~ "プロイメントタイプは、単一の構成で１セットの Web Beans すべてを条件つきで"
#~ "デプロイすることを可能にします。"

#~ msgid ""
#~ "Many Web Beans just use the default deployment type <literal>@Production</"
#~ "literal>, in which case no deployment type need be explicitly specified. "
#~ "All three Web Bean in our example have the deployment type "
#~ "<literal>@Production</literal>."
#~ msgstr ""
#~ "多くの Web Beans は、どのデプロイメントタイプも明示的に指定されていない場"
#~ "合、単にデフォルトのデプロイメントタイプ <literal>@Production</literal> を"
#~ "使用します。サンプルで使用する３つの Web Bean すべては、デプロイメントタイ"
#~ "プ <literal>@Production</literal> を持っています。"

#~ msgid ""
#~ "In a testing environment, we might want to replace the "
#~ "<literal>SentenceTranslator</literal> Web Bean with a \"mock object\":"
#~ msgstr ""
#~ "テスト環境では、<literal>SentenceTranslator</literal> Web Bean を「モック"
#~ "オブジェクト」で置き換えたいでしょう:"

#~ msgid ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"

#~ msgid ""
#~ "We would enable the deployment type <literal>@Mock</literal> in our "
#~ "testing environment, to indicate that <literal>MockSentenceTranslator</"
#~ "literal> and any other Web Bean annotated <literal>@Mock</literal> should "
#~ "be used."
#~ msgstr ""
#~ "<literal>MockSentenceTranslator</literal> と <literal>@Mock</literal> アノ"
#~ "テーションが付与されたその他の Web Bean を使用することを指定するために、テ"
#~ "スト環境ではデプロイメントタイプ <literal>@Mock</literal> を有効にします。"

#~ msgid ""
#~ "We'll talk more about this unique and powerful feature in <xref linkend="
#~ "\"deploymenttypes\"/>."
#~ msgstr ""
#~ "この独特で強力な機能については <xref linkend=\"deploymenttypes\"/> で説明"
#~ "します。"

#~ msgid "Scope"
#~ msgstr "スコープ"

#~ msgid ""
#~ "The <emphasis>scope</emphasis> defines the lifecycle and visibility of "
#~ "instances of the Web Bean. The Web Beans context model is extensible, "
#~ "accommodating arbitrary scopes. However, certain important scopes are "
#~ "built-in to the specification, and provided by the Web Bean manager. A "
#~ "scope is represented by an annotation type."
#~ msgstr ""
#~ "<emphasis>スコープ</emphasis> は Web Bean のインスタンスのライフサイクルと"
#~ "可視性を定義します。Web Beans のコンテキストモデルは拡張可能で、任意のス"
#~ "コープを収容できます。しかし、非常に重要なスコープは仕様に組み込まれ、Web "
#~ "Bean マネージャー によって提供されています。スコープはアノテーションタイプ"
#~ "によって表されます。"

#~ msgid ""
#~ "For example, any web application may have <emphasis>session scoped</"
#~ "emphasis> Web Beans:"
#~ msgstr ""
#~ "例えば、どんな Web アプリケーションも <emphasis>セッションスコープ</"
#~ "emphasis> の Web Beansを持っています:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid ""
#~ "An instance of a session scoped Web Bean is bound to a user session and "
#~ "is shared by all requests that execute in the context of that session."
#~ msgstr ""
#~ "セッションスコープの Web Bean のインスタンスはユーザセッションにバインドさ"
#~ "れて、そのセッションのコンテキストで実行されるすべてのリクエストによって共"
#~ "有されます。"

#~ msgid ""
#~ "By default, Web Beans belong to a special scope called the "
#~ "<emphasis>dependent pseudo-scope</emphasis>. Web Beans with this scope "
#~ "are pure dependent objects of the object into which they are injected, "
#~ "and their lifecycle is bound to the lifecycle of that object."
#~ msgstr ""
#~ "デフォルトでは、Web Beans は <emphasis>依存擬似スコープ</emphasis> と呼ば"
#~ "れる特別なスコープに属します。このスコープをもつ Web Beans は、注入したオ"
#~ "ブジェクトに純粋に依存するオブジェクトで、ライフサイクルは注入したオブジェ"
#~ "クトのライフサイクルに括り付けられます。"

#~ msgid "We'll talk more about scopes in <xref linkend=\"scopescontexts\"/>."
#~ msgstr ""
#~ "スコープの詳細については <xref linkend=\"scopescontexts\"/>で説明します。"

#~ msgid "Web Bean names and Unified EL"
#~ msgstr "Web Bean 名とユニファイド EL"

#~ msgid ""
#~ "A Web Bean may have a <emphasis>name</emphasis>, allowing it to be used "
#~ "in Unified EL expressions. It's easy to specify the name of a Web Bean:"
#~ msgstr ""
#~ "Web Bean は <emphasis>名前</emphasis> を持ちます。これによりユニファイド "
#~ "EL 式で使用することが可能になります。Web Bean の名前を指定するのは簡単で"
#~ "す:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "Now we can easily use the Web Bean in any JSF or JSP page:"
#~ msgstr ""
#~ "これで JSF あるいは JSP ページで Web Bean を簡単に使用することができます:"

#~ msgid ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"
#~ msgstr ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"

#~ msgid ""
#~ "It's even easier to just let the name be defaulted by the Web Bean "
#~ "manager:"
#~ msgstr ""
#~ "Web Bean マネージャによって名前は単純にデフォルトを使用させることは一層簡"
#~ "単です:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid ""
#~ "In this case, the name defaults to <literal>shoppingCart</literal> &#151; "
#~ "the unqualified class name, with the first character changed to lowercase."
#~ msgstr ""
#~ "この場合、デフォルトで名前は <literal>shoppingCart</literal> になります"
#~ "&#151; 最初の文字を小文字に変換した無資格のクラス名になります。"

#~ msgid "Interceptor binding types"
#~ msgstr "インタセプタバインディングタイプ"

#~ msgid ""
#~ "Web Beans supports the interceptor functionality defined by EJB 3, not "
#~ "only for EJB beans, but also for plain Java classes. In addition, Web "
#~ "Beans provides a new approach to binding interceptors to EJB beans and "
#~ "other Web Beans."
#~ msgstr ""
#~ "Web Beans は、 EJB beans のためにだけではなく、単純な Java クラスのために"
#~ "も、EJB 3 で定義されたインタセプタ機能を提供します。さらに、Web Beans は、"
#~ "EJB beans と他の Web Beans へのバインディングインタセプタに新しいアプロー"
#~ "チを提供します。"

#~ msgid ""
#~ "It remains possible to directly specify the interceptor class via use of "
#~ "the <literal>@Interceptors</literal> annotation:"
#~ msgstr ""
#~ "それは、<literal>@Interceptors</literal> アノテーションを使用することによ"
#~ "りインタセプタクラスを直接指定することを可能にします:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid ""
#~ "However, it is more elegant, and better practice, to indirect the "
#~ "interceptor binding through an <emphasis>interceptor binding type</"
#~ "emphasis>:"
#~ msgstr ""
#~ "しかし、<emphasis>インタセプタバインディングタイプ</emphasis> によりインタ"
#~ "セプタバインディングを間接化することは、よりエレガントでより良い手法です:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid ""
#~ "We'll discuss Web Beans interceptors and decorators in <xref linkend="
#~ "\"interceptors\"/> and <xref linkend=\"decorators\"/>."
#~ msgstr ""
#~ "Web Beans インタセプタとデコレータは <xref linkend=\"interceptors\"/> と "
#~ "<xref linkend=\"decorators\"/> で説明します。"

#~ msgid "What kinds of objects can be Web Beans?"
#~ msgstr "どの種類のオブジェクトが Web Beans になることができるのか"

#~ msgid ""
#~ "We've already seen that JavaBeans, EJBs and some other Java classes can "
#~ "be Web Beans. But exactly what kinds of objects are Web Beans?"
#~ msgstr ""
#~ "すでに JavaBean や EJB、その他のいくつかの Javaクラス が Web Beans になる"
#~ "ことを見てきました。しかし、まさにどの種類のオブジェクトが Web Beans にな"
#~ "ることができるのでしょうか。"

#~ msgid "Simple Web Beans"
#~ msgstr "単純な Web Beans"

#~ msgid ""
#~ "The Web Beans specification says that a concrete Java class is a "
#~ "<emphasis>simple</emphasis> Web Bean if:"
#~ msgstr ""
#~ "Web Beans 仕様では、以下の条件を満たすときに、コンクリートな Javaクラスが "
#~ "<emphasis>単純な</emphasis>  Web Bean になります:"

#~ msgid ""
#~ "it is not an EE container-managed component, like an EJB, a Servlet or a "
#~ "JPA entity,"
#~ msgstr ""
#~ "EJB やサーブレット、JPA エンティティのように EE コンテナで管理されたコン"
#~ "ポーネントではないもの"

#~ msgid "it is not a non-static static inner class,"
#~ msgstr "静的でないインナークラスではないもの"

#~ msgid "it is not a parameterized type, and"
#~ msgstr "パラメータ化されたタイプではないもの"

#~ msgid ""
#~ "it has a constructor with no parameters, or a constructor annotated "
#~ "<literal>@Initializer</literal>."
#~ msgstr ""
#~ "パラメータなしのコンストラクタを持つか、あるいは <literal>@Initializer</"
#~ "literal> アノテーションが付与されたコンストラクタを持つもの"

#~ msgid "Thus, almost every JavaBean is a simple Web Bean."
#~ msgstr "これにより、ほとんどすべての JavaBean は単純な Web Bean です。"

#~ msgid ""
#~ "Every interface implemented directly or indirectly by a simple Web Bean "
#~ "is an API type of the simple Web Bean. The class and its superclasses are "
#~ "also API types."
#~ msgstr ""
#~ "単純な Web Bean によって直接的にまたは間接的にに実装されるすべてのインタ"
#~ "フェースは、単純な Web Bean の API タイプです。クラスとそのクラスのスー"
#~ "パークラスもまた API タイプです。"

#~ msgid "Enterprise Web Beans"
#~ msgstr "エンタープライズ Web Beans"

#~ msgid ""
#~ "The specification says that all EJB 3-style session and singleton beans "
#~ "are <emphasis>enterprise</emphasis> Web Beans. Message driven beans are "
#~ "not Web Beans &#151; since they are not intended to be injected into "
#~ "other objects &#151; but they can take advantage of most of the "
#~ "functionality of Web Beans, including dependency injection and "
#~ "interceptors."
#~ msgstr ""
#~ "仕様によれば、すべての EJB 3 スタイルのセッション Bean とシングルトン "
#~ "Bean は <emphasis>エンタープライズ</emphasis> Web Beans です。メッセージ駆"
#~ "動 Bean は Web Beans ではないのでしょうか。&#151;それらは他のオブジェクト"
#~ "へ注入されることを意図していないのですが&#151; 依存性注入とインタセプタを"
#~ "含む Web Beans のほとんどの機能を利用することができます。"

#~ msgid ""
#~ "Every local interface of an enterprise Web Bean that does not have a "
#~ "wildcard type parameter or type variable, and every one of its "
#~ "superinterfaces, is an API type of the enterprise Web Bean. If the EJB "
#~ "bean has a bean class local view, the bean class, and every one of its "
#~ "superclasses, is also an API type."
#~ msgstr ""
#~ "ワイルドカードタイプのパラメータまたはタイプ変数を持たないエンタープライ"
#~ "ズ Web Bean の ローカルインタフェースと、そのスーパーインタフェースのすべ"
#~ "てが、エンタープライズ Web Bean のAPI タイプです。もし EJB Bean が ローカ"
#~ "ルビューの Bean クラスを持っていれば、Beanクラスとそのすべてのスーパークラ"
#~ "スも APIタイプです。"

#~ msgid ""
#~ "Stateful session beans should declare a remove method with no parameters "
#~ "or a remove method annotated <literal>@Destructor</literal>. The Web Bean "
#~ "manager calls this method to destroy the stateful session bean instance "
#~ "at the end of its lifecycle. This method is called the "
#~ "<emphasis>destructor</emphasis> method of the enterprise Web Bean."
#~ msgstr ""
#~ "ステートフルなセッション beans は、パラメータのない remove メソッドまたは "
#~ "<literal>@Destructor</literal> アノテーションを付与された remove メソッド"
#~ "を宣言すべきです。Web Bean マネージャは、そのライフサイクルの終わりでス"
#~ "テートフルセッション Bean のインスタンスを破棄するために、このメソッドを呼"
#~ "び出します。このメソッドは、エンタープライズ Web Bean の "
#~ "<emphasis>destructor</emphasis> メソッドと呼ばれます。"

#~ msgid ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"

#~ msgid ""
#~ "So when should we use an enterprise Web Bean instead of a simple Web "
#~ "Bean? Well, whenever we need the advanced enterprise services offered by "
#~ "EJB, such as:"
#~ msgstr ""
#~ "それでは、いつ単純な Web Bean でなくエンタープライズ Web Bean を使用すべき"
#~ "でしょうか。EJB によって提供される高度なエンタープライズサービスを必要とす"
#~ "る場合に使用します。例えば:"

#~ msgid "method-level transaction management and security,"
#~ msgstr "メソッドレベルのトランザクション管理とセキュリティ"

#~ msgid "concurrency management,"
#~ msgstr "並行性管理"

#~ msgid ""
#~ "instance-level passivation for stateful session beans and instance-"
#~ "pooling for stateless session beans,"
#~ msgstr ""
#~ "ステートフルセッション Bean のためのインスタンスレベルの非活性化とステート"
#~ "レスセッション Bean のためのインスタンスプーリング"

#~ msgid "remote and web service invocation, and"
#~ msgstr "リモートサービスと Web サービスの呼び出し"

#~ msgid "timers and asynchronous methods,"
#~ msgstr "タイマーと非同期メソッド"

#~ msgid ""
#~ "we should use an enterprise Web Bean. When we don't need any of these "
#~ "things, a simple Web Bean will serve just fine."
#~ msgstr ""
#~ "エンタープライズ Web Bean を使用すべきです。これらのエンタープライズサービ"
#~ "スのいずれもが必要ではないときには、単純な Web Bean がちょうど見事に役立つ"
#~ "でしょう。"

#~ msgid ""
#~ "Many Web Beans (including any session or application scoped Web Bean) are "
#~ "available for concurrent access. Therefore, the concurrency management "
#~ "provided by EJB 3.1 is especially useful. Most session and application "
#~ "scoped Web Beans should be EJBs."
#~ msgstr ""
#~ "多くの Web Beans(どんなセッションスコープあるいはアプリケーションスコープ"
#~ "のWeb Beanも含む)は、並行アクセスが可能です。それゆえに、EJB 3.1 によって"
#~ "提供された並行性管理は特に役に立ちます。ほとんどのセッションスコープとアプ"
#~ "リケーションスコープの Web Beans は EJB であるべきです。"

#~ msgid ""
#~ "Web Beans which hold references to heavy-weight resources, or hold a lot "
#~ "of internal state benefit from the advanced container-managed lifecycle "
#~ "defined by the EJB <literal>@Stateless</literal>/<literal>@Stateful</"
#~ "literal>/<literal>@Singleton</literal> model, with its support for "
#~ "passivation and instance pooling."
#~ msgstr ""
#~ "ヘビー級のリソースへの参照を保持あるいは多くの内部状態を保持する Web "
#~ "Beans は、EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/"
#~ "<literal>@Singleton</literal> モデル によって定義された高度なコンテナで管"
#~ "理されたライフサイクルから恩恵を受け、非活性化とインスタンスプーリングに対"
#~ "するサポートも利用できます。"

#~ msgid ""
#~ "Finally, it's usually obvious when method-level transaction management, "
#~ "method-level security, timers, remote methods or asynchronous methods are "
#~ "needed."
#~ msgstr ""
#~ "最後に、メソッドレベルのトランザクション管理、メソッドレベルのセキュリ"
#~ "ティ、タイマー、リモートメソッドあるいは非同期メソッドが必要とされる場合は"
#~ "たいてい明らかです。"

#~ msgid ""
#~ "It's usually easy to start with simple Web Bean, and then turn it into an "
#~ "EJB, just by adding an annotation: <literal>@Stateless</literal>, "
#~ "<literal>@Stateful</literal> or <literal>@Singleton</literal>."
#~ msgstr ""
#~ "通常は単純な Web Bean で始めるのが簡単です。それから、単に "
#~ "<literal>@Stateless</literal> や <literal>@Stateful</literal>、"
#~ "<literal>@Singleton</literal> アノテーションを付け加えることによって、それ"
#~ "らをEJBに変えてください。"

#~ msgid "Producer methods"
#~ msgstr "プロデューサ (producer) メソッド"

#~ msgid ""
#~ "A <emphasis>producer method</emphasis> is a method that is called by the "
#~ "Web Bean manager to obtain an instance of the Web Bean when no instance "
#~ "exists in the current context. A producer method lets the application "
#~ "take full control of the instantiation process, instead of leaving "
#~ "instantiation to the Web Bean manager. For example:"
#~ msgstr ""
#~ "<emphasis>プロデューサメソッド</emphasis> は、現在のコンテキストにインスタ"
#~ "ンスが存在しないときに、Web Bean のインスタンスを得るために Web Bean マ"
#~ "ネージャ によって呼ばれるメソッドです。プロデューサメソッドは、インスタン"
#~ "ス化を Web Bean マネージャに委ねるのではなく、アプリケーションにインスタン"
#~ "ス化プロセスの完全な管理をさせます。例えば:"

#~ msgid ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid ""
#~ "The result of a producer method is injected just like any other Web Bean."
#~ msgstr ""
#~ "プロデューサメソッドの結果は、ちょうど他のWeb Beanのように注入されます。"

#~ msgid "<![CDATA[@Random int randomNumber]]>"
#~ msgstr "<![CDATA[@Random int randomNumber]]>"

#~ msgid ""
#~ "The method return type and all interfaces it extends/implements directly "
#~ "or indirectly are API types of the producer method. If the return type is "
#~ "a class, all superclasses are also API types."
#~ msgstr ""
#~ "メソッドの戻りタイプとそれが直接的にあるいは間接的に拡張する/実装するすべ"
#~ "てのインタフェースはプロデューサメソッドの API タイプです。もし戻りのタイ"
#~ "プがクラスならは、すべてのスーパークラスもAPI タイプです。"

#~ msgid ""
#~ "Some producer methods return objects that require explicit destruction:"
#~ msgstr ""
#~ "プロデューサメソッドは、明示的な破棄を必要とするオブジェクトを返すものもあ"
#~ "ります:"

#~ msgid ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"

#~ msgid ""
#~ "These producer methods may define matching <emphasis>disposal methods</"
#~ "emphasis>:"
#~ msgstr ""
#~ "これらのプロデューサメソッドは、適合する <emphasis> ディスポーザルメソッド"
#~ "</emphasis> を定義するかもしれません: "

#~ msgid ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"

#~ msgid ""
#~ "This disposal method is called automatically by the Web Bean manager at "
#~ "the end of the request."
#~ msgstr ""
#~ "このディスポーザルメソッドは、リクエストの終わりに Web Bean マネージャ に"
#~ "よって自動的に呼び出されます。"

#~ msgid ""
#~ "We'll talk much more about producer methods in <xref linkend="
#~ "\"producermethods\"/>."
#~ msgstr ""
#~ "プロデューサメソッドについての詳細は <xref linkend=\"producermethods\"/> "
#~ "で説明します。"

#~ msgid "JMS endpoints"
#~ msgstr "JMS エンドポイント"

#~ msgid ""
#~ "Finally, a JMS queue or topic can be a Web Bean. Web Beans relieves the "
#~ "developer from the tedium of managing the lifecycles of all the various "
#~ "JMS objects required to send messages to queues and topics. We'll discuss "
#~ "JMS endpoints in <xref linkend=\"jms\"/>."
#~ msgstr ""
#~ "最後に、JMS キューまたはトピックは、Web Bean になることができます。Web "
#~ "Beans は、キューとトピックにメッセージを送るために必要となる、すべての様々"
#~ "な JMS オブジェクトのライフサイクルを管理する退屈から開発者を開放します。"
#~ "JMS エンドポイントは <xref linkend=\"jms\"/> で説明します。"
