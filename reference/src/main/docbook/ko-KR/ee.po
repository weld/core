# translation of ee.po to Korean
# Language ko-KR translations for Introduction_to_Web_Beans package.
#
# Automatically generated, 2009.
# Eunju Kim <eukim@redhat.com>, 2009.
msgid ""
msgstr ""
"Project-Id-Version: ee\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-05-01T13:53:42\n"
"PO-Revision-Date: 2009-01-15 02:17+1000\n"
"Last-Translator: Eunju Kim <eukim@redhat.com>\n"
"Language-Team: Korean <ko@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"
"Plural-Forms:  nplurals=2; plural=(n!=1);\n"
"\n"
"\n"
"\n"
"\n"

#. Tag: title
#, no-c-format
msgid "Java EE integration"
msgstr "Java EE 통합 "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"CDI is fully integrated into the Java EE environment. Beans have access to "
"Java EE resources and JPA persistence contexts. They may be used in Unified "
"EL expressions in JSF and JSP pages. They may even be injected into other "
"platform components, such as servlets and message-driven Beans, which are "
"not beans themselves."
msgstr ""
"Web Beans는 Java EE 환경으로 완전 통합됩니다. Web Beans는 Java EE 리소스 및 "
"JPA 지속성 컨텍스트로 액세스합니다. 이는 JSF 및 JSP 페이지에서 Unified EL 표"
"현식으로 사용될 수 있습니다. 이는 Web Beans가 아닌 Servlets 및  Message-"
"Driven Beans와 같은 일부 객체로 삽입될 수 도 있습니다. "

#. Tag: title
#, no-c-format
msgid "Built-in beans"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"In the Java EE environment, the container provides the following built-in "
"beans, all with the qualifier <literal>@Default</literal>:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "the current JTA <literal>UserTransaction</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"a <literal>Principal</literal> representing the current caller identity,"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"the default <ulink url=\"http://jcp.org/en/jsr/detail?id=303\">Bean "
"Validation</ulink> <literal>ValidationFactory</literal>, and"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"a <literal>Validator</literal> for the default <literal>ValidationFactory</"
"literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The CDI specification does not require the servlet context objects, "
"<literal>HttpServletRequest</literal>, <literal>HttpSession</literal> and "
"<literal>ServletContext</literal> to be exposed as injectable beans. If you "
"really want to be able to inject these objects, it&#39;s easy to create a "
"portable extension to expose them as beans. However, we recommend that "
"direct access to these objects be limited to servlets, servlet filters and "
"servlet event listeners, where they may be obtained in the usual way as "
"defined by the Java Servlets spec. The <literal>FacesContext</literal> is "
"also not injectable. You can get at it by calling <literal>FacesContext."
"getCurrentInstance()</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Oh, you <emphasis>really</emphasis> want to inject the "
"<literal>FacesContext</literal>? Alright then, try this producer method:"
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Injecting Java EE resources into a bean"
msgstr "Java EE 리소스를 Web Bean으로 삽입 "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"All managed beans may take advantage of Java EE component environment "
"injection using <literal>@Resource</literal>, <literal>@EJB</literal>, "
"<literal>@PersistenceContext</literal>, <literal>@PeristenceUnit</literal> "
"and <literal>@WebServiceRef</literal>. We&#39;ve already seen a couple of "
"examples of this, though we didn&#39;t pay much attention at the time:"
msgstr ""
"모든 엔터프라이즈 Web Beans는 <literal>@Resource</literal>, <literal>@EJB</"
"literal>, <literal>@PersistenceContext</literal>를 사용하여 Java EE 의존성 삽"
"입의 장점을 취할 수 있습니다. 이미 이에 대한 몇몇 예를 살펴보았습니다: "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The Java EE <literal>@PostConstruct</literal> and <literal>@PreDestroy</"
"literal> callbacks are also supported for all managed beans. The "
"<literal>@PostConstruct</literal> method is called after <emphasis>all</"
"emphasis> injection has been performed."
msgstr ""
"Java EE <literal>@PostConstruct</literal> 및 <literal>@PreDestroy</literal> "
"콜백은 모든 엔터프라이즈 Web Beans에 대해 지원됩니다. <emphasis>모든</"
"emphasis> 삽입이 실행된 후 <literal>@PostConstruct</literal> 방식이 호출됩니"
"다. "

#. Tag: para
#, no-c-format
msgid ""
"Of course, we advise that component environment injection be used to define "
"CDI resources, and that typesafe injection be used in application code."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Calling a bean from a servlet"
msgstr "Servlet에서 Web Bean 호출 "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"It&#39;s easy to use a bean from a servlet in Java EE 6. Simply inject the "
"bean using field or initializer method injection."
msgstr ""
"Java EE 6에 있는 Servlet에서 Web Bean을 사용하기가 쉽습니다. Web Beans 영역 "
"또는 초기화 방식 삽입을 사용하여 Web Bean을 삽입합니다. "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Since instances of servlets are shared across all incoming threads, the bean "
"client proxy takes care of routing method invocations from the servlet to "
"the correct instances of <literal>Credentials</literal> and <literal>Login</"
"literal> for the current request and HTTP session."
msgstr ""
"Web Beans 클라이언트 프록시는 Servlet에서 현재 요청 및 메소드 HTTP 세션의 올"
"바른 <literal>Credentials</literal> 및 <literal>Login</literal> 인스턴스로 호"
"출을 라우팅을 처리합니다.  "

#. Tag: title
#, fuzzy, no-c-format
msgid "Calling a bean from a message-driven bean"
msgstr "Message-Driven Bean에서 Web Bean 호출 "

#. Tag: para
#, no-c-format
msgid ""
"CDI injection applies to all EJBs, even when they aren&#39;t managed beans. "
"In particular, you can use CDI injection in message-driven beans, which are "
"by nature not contextual objects."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "You can even use CDI interceptor bindings for message-driven Beans."
msgstr ""
"Message-Driven Beans에 대한 Web Beans 인터셉터 바인딩을 사용할 수 있습니다.  "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Please note that there is no session or conversation context available when "
"a message is delivered to a message-driven bean. Only "
"<literal>@RequestScoped</literal> and <literal>@ApplicationScoped</literal> "
"beans are available."
msgstr ""
"따라서, Web Beans 환경에서 메세지를 받는 것은 초간편합니다. 하지만 메세지가 "
"Message-Driven Bean으로 전달될 때 사용할 수 있는 세션 또는 대화 컨텍스트가 없"
"음에 유의하시기 바랍니다. <literal>@RequestScoped</literal> 및 "
"<literal>@ApplicationScoped</literal> Web Beans 만을 사용할 수 있습니다. "

#. Tag: para
#, no-c-format
msgid "But how about beans which <emphasis>send</emphasis> JMS messages?"
msgstr ""

#. Tag: title
#, no-c-format
msgid "JMS endpoints"
msgstr "JMS 엔드포인트  "

#. Tag: para
#, no-c-format
msgid ""
"Sending messages using JMS can be quite complex, because of the number of "
"different objects you need to deal with. For queues we have <literal>Queue</"
"literal>, <literal>QueueConnectionFactory</literal>, "
"<literal>QueueConnection</literal>, <literal>QueueSession</literal> and "
"<literal>QueueSender</literal>. For topics we have <literal>Topic</literal>, "
"<literal>TopicConnectionFactory</literal>, <literal>TopicConnection</"
"literal>, <literal>TopicSession</literal> and <literal>TopicPublisher</"
"literal>. Each of these objects has its own lifecycle and threading model "
"that we need to worry about."
msgstr ""
"JMS를 사용하여 메세지를 전송하는 것은 다소 복잡할 수 있습니다. 이는 다수의 다"
"른 개체를 처리해야 하기 때문입니다. 큐의 경우 <literal>Queue</literal>, "
"<literal>QueueConnectionFactory</literal>, <literal>QueueConnection</"
"literal>, <literal>QueueSession</literal> <literal>QueueSender</literal>를 갖"
"습니다. 토픽의 경우 <literal>Topic</literal>, "
"<literal>TopicConnectionFactory</literal>, <literal>TopicConnection</"
"literal>, <literal>TopicSession</literal>, <literal>TopicPublisher</literal>"
"를 갖습니다. 이러한 각각의 객체는 자체적으로 수명 주기 및 스레딩 모델을 갖고 "
"있습니다.   "

#. Tag: para
#, no-c-format
msgid ""
"You can use producer fields and methods to prepare all of these resources "
"for injection into a bean:"
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"In this example, we can just inject the prepared <literal>MessageProducer</"
"literal>, <literal>Connection</literal> or <literal>QueueSession</literal>:"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"The lifecycle of the injected JMS objects is completely controlled by the "
"container."
msgstr ""
"삽입된 JMS 객체의 수명주기는 Web Bean 관리자에 의해 전적으로 관리됩니다. "

#. Tag: title
#, no-c-format
msgid "Packaging and deployment"
msgstr "패키징 및 배포 "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"CDI doesn&#39;t define any special deployment archive. You can package beans "
"in jars, ejb jars or wars—any deployment location in the application "
"classpath. However, the archive must be a &#34;bean archive&#34;. That means "
"each archive that contains beans <emphasis>must</emphasis> include a file "
"named <literal>beans.xml</literal> in the <literal>META-INF</literal> "
"directory of the classpath or <literal>WEB-INF</literal> directory of the "
"web root (for war archives). The file may be empty. Beans deployed in "
"archives that do not have a <literal>beans.xml</literal> file will not be "
"available for use in the application."
msgstr ""
"Web Beans는 특정 배포 아카이브를 지정하지 않습니다. JAR, EJB-JAR 또는 WAR에 "
"있는 Web Beans  &#151;  애플리케이션 classpath에 있는 배포 위치를 패키지화할 "
"수 있습니다. 하지만 Web Beans이 있는 각각의 아카이브에는  <literal>META-INF</"
"literal> 또는 <literal>WEB-INF</literal> 디렉토리에 있는 <literal>web-beans."
"xml</literal>라는 파일이 들어 있어야 합니다. 파일은 비어 있을 수 도 있습니"
"다. <literal>web-beans.xml</literal> 파일이 없는 아카이브에 배포된 Web Beans"
"는 애플리케이션에서 사용할 수 없습니다. "

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"In an embeddable EJB container, beans may be deployed in any location in "
"which EJBs may be deployed. Again, each location must contain a "
"<literal>beans.xml</literal> file."
msgstr ""
"Java SE 실행의 경우, 임베드 가능한 EJB Lite 컨테이너에 의해 실행용 EJB를 배포"
"할 수 있는 위치에 Web Beans를 배포할 수 있습니다. 각 위치에서는 <literal>web-"
"beans.xml</literal> 파일이 들어 있어야 합니다.     "

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Transactional @Interceptor\n"
#~ "public class TransactionInterceptor {\n"
#~ "   @Resource UserTransaction transaction;\n"
#~ "\n"
#~ "   @AroundInvoke public Object manageTransaction(InvocationContext ctx) "
#~ "throws Exception { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Transactional @Interceptor\n"
#~ "public class TransactionInterceptor {\n"
#~ "\n"
#~ "    @Resource Transaction transaction;\n"
#~ "\n"
#~ "    @AroundInvoke public Object manageTransaction(InvocationContext ctx) "
#~ "{ ... }\n"
#~ "    \n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class Login implements Serializable {\n"
#~ "   @Inject Credentials credentials;\n"
#~ "   @PersistenceContext EntityManager userDatabase;\n"
#~ "    ...\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class Login {\n"
#~ "\n"
#~ "    @Current Credentials credentials;\n"
#~ "    @PersistenceContext EntityManager userDatabase;\n"
#~ "    \n"
#~ "    ...\n"
#~ "\n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[public class Login extends HttpServlet {\n"
#~ "   @Inject Credentials credentials;\n"
#~ "   @Inject Login login;\n"
#~ "\n"
#~ "   @Override\n"
#~ "   public void service(HttpServletRequest request, HttpServletResponse "
#~ "response)\n"
#~ "      throws ServletException, IOException {\n"
#~ "      credentials.setUsername(request.getParameter(\"username\")):\n"
#~ "      credentials.setPassword(request.getParameter(\"password\")):\n"
#~ "      login.login();\n"
#~ "      if ( login.isLoggedIn() ) {\n"
#~ "         response.sendRedirect(\"/home.jsp\");\n"
#~ "      }\n"
#~ "      else {\n"
#~ "         response.sendRedirect(\"/loginError.jsp\");\n"
#~ "      }\n"
#~ "   }\n"
#~ "            \n"
#~ "}]]>"
#~ msgstr ""
#~ "public class Login extends HttpServlet {\n"
#~ "\n"
#~ "    @Current Credentials credentials;\n"
#~ "    @Current Login login;\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void service(HttpServletRequest request, HttpServletResponse "
#~ "response)\n"
#~ "        throws ServletException, IOException {\n"
#~ "        credentials.setUsername( request.getAttribute(\"username\") ):\n"
#~ "        credentials.setPassword( request.getAttribute(\"password\") ):\n"
#~ "        login.login();\n"
#~ "        if ( login.isLoggedIn() ) {\n"
#~ "            response.sendRedirect(\"/home.jsp\");\n"
#~ "        }\n"
#~ "        else {\n"
#~ "            response.sendRedirect(\"/loginError.jsp\");\n"
#~ "        }\n"
#~ "    }\n"
#~ "            \n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Transactional @MessageDriven\n"
#~ "public class ProcessOrder implements MessageListener {\n"
#~ "   @Inject Inventory inventory;\n"
#~ "   @PersistenceContext EntityManager em;\n"
#~ "\n"
#~ "   public void onMessage(Message message) {\n"
#~ "      ...\n"
#~ "   }\n"
#~ "}]]>"
#~ msgstr ""
#~ "@Transactional @MessageDriven\n"
#~ "public class ProcessOrder implements MessageListener {\n"
#~ "\n"
#~ "    @Current Inventory inventory;\n"
#~ "    @PersistenceContext EntityManager em;\n"
#~ "\n"
#~ "    public void onMessage(Message message) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "            \n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Inject Order order;\n"
#~ "@Inject @OrderMessageProducer MessageProducer producer;\n"
#~ "@Inject @OrderSession QueueSession orderSession;\n"
#~ "\n"
#~ "public void sendMessage() {\n"
#~ "   MapMessage msg = orderSession.createMapMessage();\n"
#~ "   msg.setLong(\"orderId\", order.getId());\n"
#~ "   ...\n"
#~ "   producer.send(msg);\n"
#~ "}]]>"
#~ msgstr ""
#~ "@OrderProcessor QueueSender orderSender;\n"
#~ "@OrderProcessor QueueSession orderSession;\n"
#~ "\n"
#~ "public void sendMessage() {\n"
#~ "    MapMessage msg = orderSession.createMapMessage();\n"
#~ "    ...\n"
#~ "    orderSender.send(msg);\n"
#~ "}"

#~ msgid ""
#~ "There is one restriction to be aware of here: <literal>@PersistenceContext"
#~ "(type=EXTENDED)</literal> is not supported for simple Web Beans."
#~ msgstr ""
#~ "여기서 유의해야 할 한 가지 제한 사항이 있습니다: "
#~ "<literal>@PersistenceContext(type=EXTENDED)</literal>는 단순한 Web Beans"
#~ "에 대해 지원되지 않습니다. "

#~ msgid ""
#~ "Web Beans injection applies to all EJBs, even when they aren't under the "
#~ "control of the Web Bean manager (if they were obtained by direct JNDI "
#~ "lookup, or injection using <literal>@EJB</literal>, for example. In "
#~ "particular, you can use Web Beans injection in Message-Driven Beans, "
#~ "which are not considered Web Beans because you can't inject them."
#~ msgstr ""
#~ "Web Beans 삽입은 모든 EJB에 적용되며, Web Bean 관리자 제어 하에 있지 않을 "
#~ "경우에도 (예들 들어, JNDI lookup에 의해 획득되었거나 <literal>@EJB</"
#~ "literal>를 사용하여 삽입되었을 경우) 적용됩니다. 특히, Message-Driven "
#~ "Beans에서 Web Beans 삽입을 사용할 수 있으며, 이를 삽입할 수 없기 때문에 이"
#~ "는 Web Beans를 고려하지 않습니다. "

#~ msgid "It's also easy to send messages using Web Beans."
#~ msgstr "또한 Web Beans를 사용하여 메세지를 전송하기 쉽습니다.  "

#~ msgid ""
#~ "Web Beans takes care of all this for us. All we need to do is declare the "
#~ "queue or topic in <literal>web-beans.xml</literal>, specifying an "
#~ "associated binding type and connection factory."
#~ msgstr ""
#~ "Web Beans는 이러한 모든 것을 처리합니다. 여기서 처리해야 할 사항은 "
#~ "<literal>web-beans.xml</literal>에 있는 큐 또는 토픽을 명명하고 관련된 바"
#~ "인딩 유형 및 연결 팩토리를 지정하는 것입니다.  "

#~ msgid ""
#~ "<![CDATA[<Queue>\n"
#~ "    <destination>java:comp/env/jms/OrderQueue</destination>\n"
#~ "    <connectionFactory>java:comp/env/jms/QueueConnectionFactory</"
#~ "connectionFactory>\n"
#~ "    <myapp:OrderProcessor/>    \n"
#~ "</Queue>]]>"
#~ msgstr ""
#~ "<![CDATA[<Queue>\n"
#~ "    <destination>java:comp/env/jms/OrderQueue</destination>\n"
#~ "    <connectionFactory>java:comp/env/jms/QueueConnectionFactory</"
#~ "connectionFactory>\n"
#~ "    <myapp:OrderProcessor/>    \n"
#~ "</Queue>]]>"

#~ msgid ""
#~ "<![CDATA[<Topic>\n"
#~ "    <destination>java:comp/env/jms/StockPrices</destination>\n"
#~ "    <connectionFactory>java:comp/env/jms/TopicConnectionFactory</"
#~ "connectionFactory>\n"
#~ "    <myapp:StockPrices/>    \n"
#~ "</Topic>]]>"
#~ msgstr ""
#~ "<![CDATA[<Topic>\n"
#~ "    <destination>java:comp/env/jms/StockPrices</destination>\n"
#~ "    <connectionFactory>java:comp/env/jms/TopicConnectionFactory</"
#~ "connectionFactory>\n"
#~ "    <myapp:StockPrices/>    \n"
#~ "</Topic>]]>"

#~ msgid ""
#~ "Now we can just inject the <literal>Queue</literal>, "
#~ "<literal>QueueConnection</literal>, <literal>QueueSession</literal> or "
#~ "<literal>QueueSender</literal> for a queue, or the <literal>Topic</"
#~ "literal>, <literal>TopicConnection</literal>, <literal>TopicSession</"
#~ "literal> or <literal>TopicPublisher</literal> for a topic."
#~ msgstr ""
#~ "이제 큐의 경우  <literal>Queue</literal>, <literal>QueueConnection</"
#~ "literal>, <literal>QueueSession</literal>, <literal>QueueSender</literal>"
#~ "를 삽입할 수 있고, 토픽의 경우 <literal>Topic</literal>, "
#~ "<literal>TopicConnection</literal>, <literal>TopicSession</literal> "
#~ "<literal>TopicPublisher</literal>를 삽입할 수 있습니다. "

#~ msgid ""
#~ "@StockPrices TopicPublisher pricePublisher;\n"
#~ "@StockPrices TopicSession priceSession;\n"
#~ "\n"
#~ "public void sendMessage(String price) {\n"
#~ "    pricePublisher.send( priceSession.createTextMessage(price) );\n"
#~ "}"
#~ msgstr ""
#~ "@StockPrices TopicPublisher pricePublisher;\n"
#~ "@StockPrices TopicSession priceSession;\n"
#~ "\n"
#~ "public void sendMessage(String price) {\n"
#~ "    pricePublisher.send( priceSession.createTextMessage(price) );\n"
#~ "}"
