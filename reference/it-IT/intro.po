# Language it-IT translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-03-02T13:07:18\n"
"PO-Revision-Date: 2008-12-25 12:11+0100\n"
"Last-Translator: Nicola Benaglia <nico.benaz@gmail.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Introduction"
msgstr ""

# Rendere la frase "wondering what kinds of hoops the Web Beans specification will make you jump through!" più italiana.
#. Tag: para
#, fuzzy, no-c-format
msgid ""
"So you're keen to get started writing your first bean? Or perhaps you're "
"skeptical, wondering what kinds of hoops the CDI specification will make you "
"jump through! The good news is that you've probably already written and used "
"hundreds, perhaps thousands of beans. CDI just makes it easier to actually "
"use them to build an application!"
msgstr ""
"Non vedi l'ora di iniziare a scrivere il primo Web Beans? O forse sei un pò "
"scettico e ti domandi quali virtuosismi ti farà fare la specifica Web Beans! "
"La buona notizia è che probabilmente hai già scritto e usato centinaia, "
"forse migliaia di Web Beans. Potresti addirittura non ricordare il primo Web "
"Bean scritto."

#. Tag: title
#, fuzzy, no-c-format
msgid "What is a bean?"
msgstr "Cosa è un Web Bean?"

#. Tag: para
#, no-c-format
msgid ""
"A bean is exactly what you think it is. Only now, it has a true identity in "
"the container environment."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Prior to Java EE 6, there was no clear definition of the term \"bean\" in "
"the Java EE platform. Of course, we've been calling Java classes used in web "
"and enterprise applications \"beans\" for years. There were even a couple of "
"different kinds of things called \"beans\" in EE specifications, including "
"EJB beans and JSF managed beans. Meanwhile, other third-party frameworks "
"such as Spring and Seam introduced their own ideas of what it meant to be a "
"\"bean\". What we've been missing is a common definition."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Java EE 6 finally lays down that common definition in the Managed Beans "
"specification. Managed Beans are defined as container-managed objects with "
"minimal programming restrictions, otherwise known by the acronym POJO (Plain "
"Old Java Object). They support a small set of basic services, such as "
"resource injection, lifecycle callbacks and interceptors. Companion "
"specifications, such as EJB and CDI, build on this basic model. But, "
"<emphasis>at last</emphasis>, there's a uniform concept of a bean and a "
"lightweight component model that's aligned across the Java EE platform."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"With very few exceptions, almost every concrete Java class that has a "
"constructor with no parameters (or a constructor designated with the "
"annotation <literal>@Inject</literal>) is a bean. This includes every "
"JavaBean and every EJB session bean. If you've already got some JavaBeans or "
"session beans lying around, they're already beans—you won't need any "
"additional special metadata. There's just little one thing you need to do "
"before you can start injecting them into stuff: you need to put them in an "
"archive (a jar, or a Java EE module such as a war or EJB jar) that contains "
"a special marker file: <literal>META-INF/beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"The JavaBeans and EJBs you've been writing every day, up until now, have not "
"been able to take advantage of the new services defined by the CDI "
"specification. But you'll be able to use every one of them with CDI—allowing "
"the container to create and destroy instances of your beans and associate "
"them with a designated context, injecting them into other beans, using them "
"in EL expressions, specializing them with qualifier annotations, even adding "
"interceptors and decorators to them—without modifying your existing code. At "
"most, you'll need to add some annotations."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now let's see how to create your first bean that actually uses CDI."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Getting our feet wet"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Suppose that we have two existing Java classes that we've been using for "
"years in various applications. The first class parses a string into a list "
"of sentences:"
msgstr ""
"Si supponga di avere due classi Java esistenti, usate da anni in varie "
"applicazioni. La prima classe esegue il parsing di una stringa in una lista "
"di frasi:"

#. Tag: para
#, no-c-format
msgid ""
"The second existing class is a stateless session bean front-end for an "
"external system that is able to translate sentences from one language to "
"another:"
msgstr ""
"La seconda classe è un session bean stateless front-end per un sistema "
"esterno capace di tradurre le frasi da una lingua ad un altra:"

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>Translator</literal> is the EJB local interface:"
msgstr "Dove <literal>Translator</literal> è l'interfaccia locale:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Unfortunately, we don't have a class that translates whole text documents. "
"So let's write a bean for this job:"
msgstr ""
"Sfortunatamente non ci sono classi preesistenti che traducano l'intero testo "
"dei documenti. Quindi occorre scrivere un Web Bean che faccia questo lavoro:"

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"But wait! <literal>TextTranslator</literal> does not have a constructor with "
"no parameters! Is it still a bean? If you remember, a class that does not "
"have a constructor with no parameters can still be a bean if it has a "
"constructor annotated <literal>@Inject</literal>."
msgstr ""
"Ma <literal>TextTranslator</literal> non ha un costruttore con nessun "
"parametro! E' ancora un Web Bean? Una classe che non ha un costruttore senza "
"parametri può essere un Web Bean se il suo costruttore è annotato con "
"<literal>@Initializer</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"As you've guessed, the <literal>@Inject</literal> annotation has something "
"to do with dependency injection! <literal>@Inject</literal> may be applied "
"to a constructor or method of a bean, and tells the container to call that "
"constructor or method when instantiating the bean. The container will inject "
"other beans into the parameters of the constructor or method."
msgstr ""
"Come hai indovinato, l'annotazione <literal>@Initializer</literal> ha "
"qualcosa che fare con la dependency injection! <literal>@Initializer</"
"literal> può essere applicato ad un costruttore od un metodo di un Web Bean, "
"e dice al manager Web Bean di chiamare quel costruttore o metodo quando si "
"istanzia il Web Bean. Il manager Web Bean inietterà altri Web Bean nei "
"parametri del costruttore o del metodo."

#. Tag: para
#, no-c-format
msgid ""
"We may obtain an instance of <literal>TextTranslator</literal> by injecting "
"it into a constructor, method or field of a bean, or a field or method of a "
"Java EE component class such as a servlet. The container chooses the object "
"to be injected based on the type of the injection point, not the name of the "
"field, method or parameter."
msgstr ""

#. Tag: para
#, no-c-format
msgid ""
"Let's create a UI controller bean that uses field injection to obtain an "
"instance of the <literal>TextTranslator</literal>, translating the text "
"entered by a user:"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Field injection of <literal>TextTranslator</literal> instance"
msgstr "Dove <literal>Translator</literal> è l'interfaccia locale:"

#. Tag: para
#, no-c-format
msgid ""
"Notice the controller bean is request-scoped and named. Since this "
"combination is so common in web applications, there's a built-in annotation "
"for it in CDI that we could have used as a shorthand. When the (stereotype) "
"annotation <literal>@Model</literal> is declared on a class, it creates a "
"request-scoped and named bean."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"Alternatively, we may obtain an instance of <literal>TextTranslator</"
"literal> programmatically from an injected instance of <literal>Instance</"
"literal>, parameterized with the bean type:"
msgstr ""
"Si può ottenere un'istanza di <literal>TextTranslator</literal> iniettandolo "
"in un Web Bean, Servlet o EJB:"

#. Tag: para
#, no-c-format
msgid ""
"Notice that it isn't necessary to create a getter or setter method to inject "
"one bean into another. CDI can access an injected field directly (even if "
"it's private!), which sometimes helps eliminate some wasteful code. The name "
"of the field is arbitrary. It's the field's type that determines what is "
"injected."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid ""
"At system initialization time, the container must validate that exactly one "
"bean exists which satisfies each injection point. In our example, if no "
"implementation of <literal>Translator</literal> is available—if the "
"<literal>SentenceTranslator</literal> EJB was not deployed—the container "
"would inform us of an <emphasis>unsatisfied dependency</emphasis>. If more "
"than one implementation of <literal>Translator</literal> were available, the "
"container would inform us of the <emphasis>ambiguous dependency</emphasis>."
msgstr ""
"In fase di inizializzazione del sistema, il manager Web Bean deve "
"convalidare che esattamente un solo Web Bean esista e soddisfi ciascun punto "
"di iniezione. Nell'esempio, se nessuna implementazione di "
"<literal>Translator</literal> fosse disponibile &#151; se l'EJB "
"<literal>SentenceTranslator</literal> non venisse deployato &#151; il "
"manager Web Bean lancerebbe una <literal>UnsatisfiedDependencyException</"
"literal>. Se più di un'implementazione di <literal>Translator</literal> "
"fosse disponibile, il manager Web Bean lancerebbe una "
"<literal>AmbiguousDependencyException</literal>."

#. Tag: para
#, no-c-format
msgid ""
"Before we get too deep in the details, let's pause and examine a bean's "
"anatomy. What aspects of the bean are significant, and what gives it its "
"identity? Instead of just giving examples of beans, we're going to define "
"what <emphasis>makes</emphasis> something a bean."
msgstr ""

#, fuzzy
#~ msgid ""
#~ "<![CDATA[public class SentenceParser {\n"
#~ "   public List<String> parse(String text) { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public class SentenceParser {\n"
#~ "    public List<String> parse(String text) { ... }\n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Stateless\n"
#~ "public class SentenceTranslator implements Translator {\n"
#~ "   public String translate(String sentence) { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Stateless\n"
#~ "public class SentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) { ... }\n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Local\n"
#~ "public interface Translator {\n"
#~ "   public String translate(String sentence);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Local\n"
#~ "public interface Translator {\n"
#~ "    public String translate(String sentence);\n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[public class TextTranslator {\n"
#~ "   private SentenceParser sentenceParser;\n"
#~ "   private Translator sentenceTranslator;\n"
#~ "    \n"
#~ "   @Inject\n"
#~ "   TextTranslator(SentenceParser sentenceParser, Translator "
#~ "sentenceTranslator) {\n"
#~ "      this.sentenceParser = sentenceParser;\n"
#~ "      this.sentenceTranslator = sentenceTranslator;\n"
#~ "   }\n"
#~ "    \n"
#~ "   public String translate(String text) {\n"
#~ "      StringBuilder sb = new StringBuilder();\n"
#~ "      for (String sentence: sentenceParser.parse(text)) {\n"
#~ "          sb.append(sentenceTranslator.translate(sentence));\n"
#~ "      }\n"
#~ "      return sb.toString();\n"
#~ "   }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public class TextTranslator {\n"
#~ "    \n"
#~ "    private SentenceParser sentenceParser;\n"
#~ "    private Translator sentenceTranslator;\n"
#~ "    \n"
#~ "    @Initializer\n"
#~ "    TextTranslator(SentenceParser sentenceParser, Translator "
#~ "sentenceTranslator) {\n"
#~ "        this.sentenceParser = sentenceParser;\n"
#~ "        this.sentenceTranslator = sentenceTranslator;\n"
#~ "    }\n"
#~ "    \n"
#~ "    public String translate(String text) {\n"
#~ "        StringBuilder sb = new StringBuilder();\n"
#~ "        for (String sentence: sentenceParser.parse(text)) {\n"
#~ "            sb.append(sentenceTranslator.translate(sentence));\n"
#~ "        }\n"
#~ "        return sb.toString();\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Inject Instance<TextTranslator> textTranslatorInstance;\n"
#~ "...\n"
#~ "public void translate() {\n"
#~ "   textTranslatorInstance.get().translate(inputText);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Initializer\n"
#~ "public setTextTranslator(TextTranslator textTranslator) {\n"
#~ "    this.textTranslator = textTranslator;\n"
#~ "}]]>"

#~ msgid "Getting started with Web Beans"
#~ msgstr "Iniziare con Web Beans"

#~ msgid "Your first Web Bean"
#~ msgstr "Il primo Web Bean"

#~ msgid ""
#~ "With certain, very special exceptions, every Java class with a "
#~ "constructor that accepts no parameters is a Web Bean. That includes every "
#~ "JavaBean. Furthermore, every EJB 3-style session bean is a Web Bean. "
#~ "Sure, the JavaBeans and EJBs you've been writing every day have not been "
#~ "able to take advantage of the new services defined by the Web Beans "
#~ "specification, but you'll be able to use every one of them as Web Beans "
#~ "&#151; injecting them into other Web Beans, configuring them via the Web "
#~ "Beans XML configuration facility, even adding interceptors and decorators "
#~ "to them &#151; without touching your existing code."
#~ msgstr ""
#~ "Con alcune eccezioni molto particolari, ogni classe Java con un "
#~ "costruttore che non accetta parametri è un Web Bean. Questo include ogni "
#~ "JavaBean. Inoltre, ogni session bean di stile EJB3 è un Web Bean. "
#~ "Sicuramente i JavaBean e gli EJB3 che si sono sempre scritti non erano in "
#~ "grado di sfruttare i nuovi servizi definiti dalla specifica Web Beans, ma "
#~ "si sarà presto in grado di usare ciascuno di essi come Web Bean &#151; "
#~ "iniettandoli in altri Web Beans, configurandoli tramite strumenti di "
#~ "configurazione XML Web Bean, e perfino aggiungendo a loro interceptor e "
#~ "decoratori &#151; senza toccare il codice esistente."

#~ msgid ""
#~ "Alternatively, we may obtain an instance by directly calling a method of "
#~ "the Web Bean manager:"
#~ msgstr ""
#~ "In alternativa si può ottenere un'istanza chiamando direttamente un "
#~ "metodo del manager Web Bean:"

#~ msgid ""
#~ "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator."
#~ "class);]]>"
#~ msgstr ""
#~ "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator."
#~ "class);]]>"

#~ msgid "So what, <emphasis>exactly</emphasis>, is a Web Bean?"
#~ msgstr "Ma cosa è <emphasis>esattamente</emphasis> un Web Bean?"

#~ msgid ""
#~ "A Web Bean is an application class that contains business logic. A Web "
#~ "Bean may be called directly from Java code, or it may be invoked via "
#~ "Unified EL. A Web Bean may access transactional resources. Dependencies "
#~ "between Web Beans are managed automatically by the Web Bean manager. Most "
#~ "Web Beans are <emphasis>stateful</emphasis> and <emphasis>contextual</"
#~ "emphasis>. The lifecycle of a Web Bean is always managed by the Web Bean "
#~ "manager."
#~ msgstr ""
#~ "Un Web Bean è una classe di un'applicazione che contiene della logica di "
#~ "business. Può essere chiamato direttamente da codice Java, o può essere "
#~ "invocato via Unified EL. Un Web Bean può accedere a risorse "
#~ "transazionali. Le dipendenze tra Web Beans sono gestite automaticamente "
#~ "dal manager Web Bean. La maggior parte dei Web Beans sono "
#~ "<emphasis>stateful</emphasis> e <emphasis>contestuali</emphasis>. Il "
#~ "ciclo di vita di un Web Bean è sempre gestito da un manager Web Bean."

#~ msgid ""
#~ "Let's back up a second. What does it really mean to be \"contextual\"? "
#~ "Since Web Beans may be stateful, it matters <emphasis>which</emphasis> "
#~ "bean instance I have. Unlike a stateless component model (for example, "
#~ "stateless session beans) or a singleton component model (such as "
#~ "servlets, or singleton beans), different clients of a Web Bean see the "
#~ "Web Bean in different states. The client-visible state depends upon which "
#~ "instance of the Web Bean the client has a reference to."
#~ msgstr ""
#~ "Torniamo indietro un attimo. Cosa significa veramente essere \"contestuale"
#~ "\"? Poiché Web Beans può essere stateful, è importante <emphasis>quale</"
#~ "emphasis> istanza di bean si ha. Diversamente da un modello a componenti "
#~ "stateless (per esempio, i session bean stateless) o un modello a "
#~ "componenti singleton (come i servlet o i bean singleton) i client di un "
#~ "Web Bean vedono il Web Bean in stati differenti. Lo stato del client "
#~ "visibile dipende dall'istanza del Web Bean alla quale il client ha il "
#~ "riferimento."

#~ msgid ""
#~ "However, like a stateless or singleton model, but <emphasis>unlike</"
#~ "emphasis> stateful session beans, the client does not control the "
#~ "lifecycle of the instance by explicitly creating and destroying it. "
#~ "Instead, the <emphasis>scope</emphasis> of the Web Bean determines:"
#~ msgstr ""
#~ "Comunque, in modo simile ad un modello stateless o singleton, ma "
#~ "<emphasis>non come</emphasis> i session bean stateful, il client non ha "
#~ "il controllo sul ciclo di vita dell'istanza, creandola e distruggendola "
#~ "esplicitamente. Invece, lo <emphasis>scope</emphasis> del Web Bean "
#~ "determina:"

#~ msgid "the lifecycle of each instance of the Web Bean and"
#~ msgstr "il ciclo di vita di ogni istanza del Web Bean e"

#~ msgid ""
#~ "which clients share a reference to a particular instance of the Web Bean."
#~ msgstr ""
#~ "quali client condividono una referenza con una particolare istanza del "
#~ "Web Bean."

#~ msgid ""
#~ "For a given thread in a Web Beans application, there may be an "
#~ "<emphasis>active context</emphasis> associated with the scope of the Web "
#~ "Bean. This context may be unique to the thread (for example, if the Web "
#~ "Bean is request scoped), or it may be shared with certain other threads "
#~ "(for example, if the Web Bean is session scoped) or even all other "
#~ "threads (if it is application scoped)."
#~ msgstr ""
#~ "Per un dato thread in un'applicazione Web Beans, ci può essere un "
#~ "<emphasis>contesto attivo</emphasis> associato allo scope del Web Bean. "
#~ "Questo contesto può essere univoco nel thread (per esempio, se il Web "
#~ "Bean è con scope di richiesta), o può essere condiviso con alcuni altri "
#~ "thread (per esempio, se il Web Bean è con scope di sessione) od anche "
#~ "tutti gli altri thread (se è scope di applicazione). "

#~ msgid ""
#~ "Clients (for example, other Web Beans) executing in the same context will "
#~ "see the same instance of the Web Bean. But clients in a different context "
#~ "will see a different instance."
#~ msgstr ""
#~ "I client (per esempio, altri Web Beans) che sono in esecuzione nello "
#~ "stesso contesto vedranno la stessa istanza del Web Bean. Ma i client in "
#~ "un contesto diverso vedranno un istanza diversa."

#~ msgid ""
#~ "One great advantage of the contextual model is that it allows stateful "
#~ "Web Beans to be treated like services! The client need not concern itself "
#~ "with managing the lifecycle of the Web Bean it is using, <emphasis>nor "
#~ "does it even need to know what that lifecyle is.</emphasis> Web Beans "
#~ "interact by passing messages, and the Web Bean implementations define the "
#~ "lifecycle of their own state. The Web Beans are loosely coupled because:"
#~ msgstr ""
#~ "Un grande vantaggio del modello contestuale è che consente ai Web Beans "
#~ "stateful di essere trattati come servizi! Il client non deve preoccuparsi "
#~ "di gestire il ciclo di vita del Web Bean che sta utilizzando, <emphasis>e "
#~ "neppure deve sapere quale sia il ciclo di vita.</emphasis> Web Beans "
#~ "interagisce passando i messaggi, e le implementazioni Web Bean "
#~ "definiscono il ciclo di vita del proprio stato. I Web Beans sono "
#~ "debolmente disaccoppiati (loosely coupled) poiché:"

#~ msgid "they interact via well-defined public APIs"
#~ msgstr "interagiscono tramite delle API pubblica ben-definita"

#~ msgid "their lifecycles are completely decoupled"
#~ msgstr "il loro ciclo di vita è completamente disaccoppiato"

#~ msgid ""
#~ "We can replace one Web Bean with a different Web Bean that implements the "
#~ "same API and has a different lifecycle (a different scope) without "
#~ "affecting the other Web Bean implementation. In fact, Web Beans defines a "
#~ "sophisticated facility for overriding Web Bean implementations at "
#~ "deployment time, as we will see in <xref linkend=\"deploymenttypes\"/>."
#~ msgstr ""
#~ "Si può sostituire un Web Bean con un diverso Web Bean che implementa la "
#~ "stessa API ed ha un diverso ciclo di vita (un diverso scope) senza "
#~ "alterare l'implementazione dell'altro Web Bean. Infatti Web Beans "
#~ "definisce un meccanismo sofisticato per fare l'override delle "
#~ "implementazioni Web Bean al momento del deploy, come visto in <xref "
#~ "linkend=\"deploymenttypes\"/>."

#~ msgid ""
#~ "Note that not all clients of a Web Bean are Web Beans. Other objects such "
#~ "as Servlets or Message-Driven Beans &#151; which are by nature not "
#~ "injectable, contextual objects &#151; may also obtain references to Web "
#~ "Beans by injection."
#~ msgstr ""
#~ "Si noti che non tutti i client dei un Web Bean sono Web Bean. Altri "
#~ "oggetti come Servlet o Message-Driven Beans &#151; che sono per natura "
#~ "non iniettabili, oggetti contestuali &#151; possono pure ottenere "
#~ "riferimenti a Web Bean tramite iniezione."

# Tolto "Enough hand-waving."
#~ msgid "Enough hand-waving. More formally, according to the spec:"
#~ msgstr "Più formalmente, secondo la specifica:"

#~ msgid "A Web Bean comprises:"
#~ msgstr "Un Web Bean comprende:"

#~ msgid "A (nonempty) set of API types"
#~ msgstr "Un set (non vuoto) di tipi di API"

#~ msgid "A (nonempty) set of binding annotation types"
#~ msgstr "Un set (non vuoto) di tipi di annotazione di binding"

#~ msgid "A scope"
#~ msgstr "Uno scope"

#~ msgid "A deployment type"
#~ msgstr "Un tipo di deploy"

#~ msgid "Optionally, a Web Bean name"
#~ msgstr "Opzionalmente un nome Web Bean"

#~ msgid "A set of interceptor binding types"
#~ msgstr "Un set di tipi di interceptor binding"

#~ msgid "A Web Bean implementation"
#~ msgstr "Un implementazione Web Bean"

#~ msgid "Let's see what some of these terms mean, to the Web Bean developer."
#~ msgstr ""
#~ "Vediamo cosa significano alcuni di questi termini per lo sviluppatore Web "
#~ "Bean."

#~ msgid "API types, binding types and dependency injection"
#~ msgstr "Tipi di API, tipi di binding e dependency injection"

#~ msgid ""
#~ "Web Beans usually acquire references to other Web Beans via dependency "
#~ "injection. Any injected attribute specifies a \"contract\" that must be "
#~ "satisfied by the Web Bean to be injected. The contract is:"
#~ msgstr ""
#~ "I Web Bean solitamente acquisiscono riferimenti ad altri Web Bean tramite "
#~ "la dependency injection. Ogni attributo iniettato specifica un \"contratto"
#~ "\" che deve essere soddisfatto dal Web Bean per essere iniettato. Il "
#~ "contratto è:"

#~ msgid "an API type, together with"
#~ msgstr "un tipo di API, assieme a"

#~ msgid "a set of binding types."
#~ msgstr "un set di tipi di binding"

# client-visible semantic  =?
#~ msgid ""
#~ "An API is a user-defined class or interface. (If the Web Bean is an EJB "
#~ "session bean, the API type is the <literal>@Local</literal> interface or "
#~ "bean-class local view). A binding type represents some client-visible "
#~ "semantic that is satisfied by some implementations of the API and not by "
#~ "others."
#~ msgstr ""
#~ "Un API è una classe o interfaccia definita dall'utente. (Se il Web Bean è "
#~ "un session bean EJB, il tipo di API è l'interfaccia <literal>@Local</"
#~ "literal> o la vista locale della classe-bean). Un tipo di binding "
#~ "rappresenta un semantica del client che è soddisfatta da certe "
#~ "implementazioni dell'API e non da altre."

#~ msgid ""
#~ "Binding types are represented by user-defined annotations that are "
#~ "themselves annotated <literal>@BindingType</literal>. For example, the "
#~ "following injection point has API type <literal>PaymentProcessor</"
#~ "literal> and binding type <literal>@CreditCard</literal>:"
#~ msgstr ""
#~ "I tipi di binding sono rappresentati da annotazioni definite dall'utente "
#~ "che sono loro stesse annotate con <literal>@BindingType</literal>. Per "
#~ "esempio, il seguente punto di iniezione ha un tipo di API "
#~ "<literal>PaymentProcessor</literal> ed un tipo di binding "
#~ "<literal>@CreditCard</literal>:"

#~ msgid "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"
#~ msgstr "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"

#~ msgid ""
#~ "If no binding type is explicitly specified at an injection point, the "
#~ "default binding type <literal>@Current</literal> is assumed."
#~ msgstr ""
#~ "Se nessun tipo di binding viene specificato in modo esplicito ad un punto "
#~ "di iniezione, il tipo di binding di default si assume essere "
#~ "<literal>@Current</literal>."

#~ msgid ""
#~ "For each injection point, the Web Bean manager searches for a Web Bean "
#~ "which satisfies the contract (implements the API, and has all the binding "
#~ "types), and injects that Web Bean."
#~ msgstr ""
#~ "Per ogni punto di iniezione, il manager Web Bean cerca un Web Bean che "
#~ "soddisfi il contratto (che implementi la API, e che abbia tutti i tipi di "
#~ "binding), ed inietta tale Web Bean."

#~ msgid ""
#~ "The following Web Bean has the binding type <literal>@CreditCard</"
#~ "literal> and implements the API type <literal>PaymentProcessor</literal>. "
#~ "It could therefore be injected to the example injection point:"
#~ msgstr ""
#~ "Il seguente Web Bean ha il tipo binding <literal>@CreditCard</literal> e "
#~ "implementa il tipo API <literal>PaymentProcessor</literal>. Può quindi "
#~ "essere iniettato nel punto di iniezione d'esempio:"

#~ msgid ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"

#~ msgid ""
#~ "If a Web Bean does not explicitly specify a set of binding types, it has "
#~ "exactly one binding type: the default binding type <literal>@Current</"
#~ "literal>."
#~ msgstr ""
#~ "Se un Web Bean non specifica esplicitamente un set di tipi di binding, ha "
#~ "esattamente un solo tipo di binding: il tipo di binding di default "
#~ "<literal>@Current</literal>."

#~ msgid ""
#~ "Web Beans defines a sophisticated but intuitive <emphasis>resolution "
#~ "algorithm</emphasis> that helps the container decide what to do if there "
#~ "is more than one Web Bean that satisfies a particular contract. We'll get "
#~ "into the details in <xref linkend=\"injection\"/>."
#~ msgstr ""
#~ "Web Beans definisce un <emphasis>algoritmo di risoluzione</emphasis> "
#~ "sofisticato ma intuitivo che aiuta il container a decidere cosa fare se "
#~ "più di un Web Bean soddisfa un particolare contratto. Vedremo i dettagli "
#~ "in <xref linkend=\"injection\"/>."

#~ msgid "Deployment types"
#~ msgstr "Tipi di deploy"

#~ msgid ""
#~ "<emphasis>Deployment types</emphasis> let us classify our Web Beans by "
#~ "deployment scenario. A deployment type is an annotation that represents a "
#~ "particular deployment scenario, for example <literal>@Mock</literal>, "
#~ "<literal>@Staging</literal> or <literal>@AustralianTaxLaw</literal>. We "
#~ "apply the annotation to Web Beans which should be deployed in that "
#~ "scenario. A deployment type allows a whole set of Web Beans to be "
#~ "conditionally deployed, with a just single line of configuration."
#~ msgstr ""
#~ "<emphasis>I tipi di deploy</emphasis> consentono di classificare i Web "
#~ "Bean secondo uno scenario di deploy. Un tipo di deploy è un'annotazione "
#~ "che rappresenta un particolare scenario di deploy, per esempio "
#~ "<literal>@Mock</literal>, <literal>@Staging</literal> oppure "
#~ "<literal>@AustralianTaxLaw</literal>. Si applica l'annotazione ai Web "
#~ "Bean che dovrebbero essere deployati in tale scenario. Un tipo di deploy "
#~ "consente ad un intero set di Web Bean di essere deployati in modo "
#~ "condizionato, con una sola linea di configurazione."

#~ msgid ""
#~ "Many Web Beans just use the default deployment type <literal>@Production</"
#~ "literal>, in which case no deployment type need be explicitly specified. "
#~ "All three Web Bean in our example have the deployment type "
#~ "<literal>@Production</literal>."
#~ msgstr ""
#~ "Molti Web Bean usano soltanto il tipo di deploy di default "
#~ "<literal>@Production</literal>, ed in questo caso non occorre specificare "
#~ "esplicitamente nessun tipo di deploy. Tutti e tre i Web Bean d'esempio "
#~ "hanno ul tipo di deploy <literal>@Production</literal>. "

#~ msgid ""
#~ "In a testing environment, we might want to replace the "
#~ "<literal>SentenceTranslator</literal> Web Bean with a \"mock object\":"
#~ msgstr ""
#~ "In un ambiente di test è possibile sostituire il Web Bean "
#~ "<literal>SentenceTranslator</literal> con un \"oggetto mock\":"

#~ msgid ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"

#~ msgid ""
#~ "We would enable the deployment type <literal>@Mock</literal> in our "
#~ "testing environment, to indicate that <literal>MockSentenceTranslator</"
#~ "literal> and any other Web Bean annotated <literal>@Mock</literal> should "
#~ "be used."
#~ msgstr ""
#~ "In ambiente di test si dovrebbe abilitare il tipo di deploy "
#~ "<literal>@Mock</literal> per indicare che l'uso di "
#~ "<literal>MockSentenceTranslator</literal> ed ogni altro Web Bean annotato "
#~ "con <literal>@Mock</literal>."

#~ msgid ""
#~ "We'll talk more about this unique and powerful feature in <xref linkend="
#~ "\"deploymenttypes\"/>."
#~ msgstr ""
#~ "Si discuterà questa potente funzionalità con maggior dettaglio in <xref "
#~ "linkend=\"deploymenttypes\"/>.\" "

#~ msgid "Scope"
#~ msgstr "Scope"

# arbitrary scope è corretto "scope arbitrari" ?
#~ msgid ""
#~ "The <emphasis>scope</emphasis> defines the lifecycle and visibility of "
#~ "instances of the Web Bean. The Web Beans context model is extensible, "
#~ "accommodating arbitrary scopes. However, certain important scopes are "
#~ "built-in to the specification, and provided by the Web Bean manager. A "
#~ "scope is represented by an annotation type."
#~ msgstr ""
#~ "Lo <emphasis>scope</emphasis> definisce il ciclo di vita e la visibilità "
#~ "delle istanze di Web Bean. Il modello di contesto Web Bean è estensibile "
#~ "e facilita gli scope arbitrari. Comunque alcuni importanti scope sono "
#~ "predefiniti all'internodella specifica e vengono forniti dal manager Web "
#~ "Bean. Uno scope è rapresentato da un tipo di annotazione."

#~ msgid ""
#~ "For example, any web application may have <emphasis>session scoped</"
#~ "emphasis> Web Beans:"
#~ msgstr ""
#~ "Per esempio un'applicazione web può avere Web Bean con <emphasis>scope di "
#~ "sessione</emphasis>"

#~ msgid ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid ""
#~ "An instance of a session scoped Web Bean is bound to a user session and "
#~ "is shared by all requests that execute in the context of that session."
#~ msgstr ""
#~ "Un'istanza di un Web Bean con scope sessione è legato ad una sessione "
#~ "utente ed è condivisa da tutte le richieste che si eseguono nel contesto "
#~ "di tale sessione."

#~ msgid ""
#~ "By default, Web Beans belong to a special scope called the "
#~ "<emphasis>dependent pseudo-scope</emphasis>. Web Beans with this scope "
#~ "are pure dependent objects of the object into which they are injected, "
#~ "and their lifecycle is bound to the lifecycle of that object."
#~ msgstr ""
#~ "Di default i Web Bean appartengono ad uno speciale scope chiamato "
#~ "<emphasis>pseudo-scope dipendente</emphasis>. Web Bean con questo scope "
#~ "sono oggetti puri dipendenti dall'oggetto nel quale vengono iniettati ed "
#~ "il loro ciclo di vita è legato al ciclo di vita di tale oggetto."

#~ msgid "We'll talk more about scopes in <xref linkend=\"scopescontexts\"/>."
#~ msgstr "Approfondiremo gli scope in <xref linkend=\"scopescontexts\"/>."

#~ msgid "Web Bean names and Unified EL"
#~ msgstr "Nomi Web Bean e Unified EL"

#~ msgid ""
#~ "A Web Bean may have a <emphasis>name</emphasis>, allowing it to be used "
#~ "in Unified EL expressions. It's easy to specify the name of a Web Bean:"
#~ msgstr ""
#~ "Un Web Bean può avere un <emphasis>nome</emphasis> che gli consente di "
#~ "essere usato in un'espressione Unified EL. E' facile specificare il nome "
#~ "del Web Bean:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "Now we can easily use the Web Bean in any JSF or JSP page:"
#~ msgstr ""
#~ "Ora si può facilmente utilizzare il Web Bean in ogni pagina JSF o JSP:"

#~ msgid ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"
#~ msgstr ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"

#~ msgid ""
#~ "It's even easier to just let the name be defaulted by the Web Bean "
#~ "manager:"
#~ msgstr ""
#~ "Si può anche lasciare assegnare al manager Web Bean il nome di default:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid ""
#~ "In this case, the name defaults to <literal>shoppingCart</literal> &#151; "
#~ "the unqualified class name, with the first character changed to lowercase."
#~ msgstr ""
#~ "In questo caso il nome di default è <literal>shoppingCart</literal> "
#~ "&#151; il nome della classe non qualificata, con il primo carattere messo "
#~ "in minuscolo."

#~ msgid "Interceptor binding types"
#~ msgstr "Tipi di interceptor binding"

#~ msgid ""
#~ "Web Beans supports the interceptor functionality defined by EJB 3, not "
#~ "only for EJB beans, but also for plain Java classes. In addition, Web "
#~ "Beans provides a new approach to binding interceptors to EJB beans and "
#~ "other Web Beans."
#~ msgstr ""
#~ "Web Beans supporta la funzionalità di interceptor definita da EJB 3, non "
#~ "solo per i bean EJB, ma anche per classi Java semplici (plain). In "
#~ "aggiunta, Web Beans fornisce un nuovo approccio al binding di interceptor "
#~ "nei confronti di bean EJB e di altri Web Beans."

#~ msgid ""
#~ "It remains possible to directly specify the interceptor class via use of "
#~ "the <literal>@Interceptors</literal> annotation:"
#~ msgstr ""
#~ "Rimane la possibilità di specificare direttamente la classe interceptor "
#~ "tramite l'uso dell'annotazione <literal>@Interceptors</literal>."

#~ msgid ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"

# indirect = ?
#~ msgid ""
#~ "However, it is more elegant, and better practice, to indirect the "
#~ "interceptor binding through an <emphasis>interceptor binding type</"
#~ "emphasis>:"
#~ msgstr ""
#~ "Comunque è più elegante ed è considerata una pratica migliore quella di "
#~ "giungere indirettamente ad un interceptor binding tramite un "
#~ "<emphasis>tipo di interceptor binding</emphasis>:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid ""
#~ "We'll discuss Web Beans interceptors and decorators in <xref linkend="
#~ "\"interceptors\"/> and <xref linkend=\"decorators\"/>."
#~ msgstr ""
#~ "Si discuteranno gli interceptor e i decoratori di Web BEans in <xref "
#~ "linkend=\"interceptors\"/> e <xref linkend=\"decorators\"/>."

#~ msgid "What kinds of objects can be Web Beans?"
#~ msgstr "Quali tipi di oggetti possono essere Web Beans?"

#~ msgid ""
#~ "We've already seen that JavaBeans, EJBs and some other Java classes can "
#~ "be Web Beans. But exactly what kinds of objects are Web Beans?"
#~ msgstr ""
#~ "Si è già visto che JavaBeans, EJB ed altri tipi di classi Java possono "
#~ "essere Web Bean. Ma esattamente quali tipi di oggetti sono Web Beans?"

#~ msgid "Simple Web Beans"
#~ msgstr "Web Beans Semplici"

#~ msgid ""
#~ "The Web Beans specification says that a concrete Java class is a "
#~ "<emphasis>simple</emphasis> Web Bean if:"
#~ msgstr ""
#~ "La specifica Web Beans dice che una classe concreta Java è un Web Bean "
#~ "<emphasis>semplice</emphasis> se:"

#~ msgid ""
#~ "it is not an EE container-managed component, like an EJB, a Servlet or a "
#~ "JPA entity,"
#~ msgstr ""
#~ "Non è un componente gestito da un container EE, come EJB, un Servlet o un "
#~ "entity JPA,"

#~ msgid "it is not a non-static static inner class,"
#~ msgstr "non è una classe interna statica/non statica,"

#~ msgid "it is not a parameterized type, and"
#~ msgstr "non è un tipo parametrizzato, e"

#~ msgid ""
#~ "it has a constructor with no parameters, or a constructor annotated "
#~ "<literal>@Initializer</literal>."
#~ msgstr ""
#~ "ha un costruttore senza parametro, o un costruttore annotato con "
#~ "<literal>@Initializer</literal>."

#~ msgid "Thus, almost every JavaBean is a simple Web Bean."
#~ msgstr "Quindi quasi ogni JavaBean è un Web Bean semplice."

#~ msgid ""
#~ "Every interface implemented directly or indirectly by a simple Web Bean "
#~ "is an API type of the simple Web Bean. The class and its superclasses are "
#~ "also API types."
#~ msgstr ""
#~ "Ogni interfaccia implementata direttamente o indirettamente da un Web "
#~ "Bean semplice è un tipo di API di un Web Bean semplice. La classe e le "
#~ "sue superclassi sono anch'essere tipi di API."

#~ msgid "Enterprise Web Beans"
#~ msgstr "Web Bean Enterprise"

#~ msgid ""
#~ "The specification says that all EJB 3-style session and singleton beans "
#~ "are <emphasis>enterprise</emphasis> Web Beans. Message driven beans are "
#~ "not Web Beans &#151; since they are not intended to be injected into "
#~ "other objects &#151; but they can take advantage of most of the "
#~ "functionality of Web Beans, including dependency injection and "
#~ "interceptors."
#~ msgstr ""
#~ "La specifica dice che tutti i bean di sessione stile EJB3 e quelli "
#~ "singleton sono Web Bean <emphasis>enterprise</emphasis>. I bean message "
#~ "driven non sono Web Bean &#151; poiché non sono intesi per essere "
#~ "iniettati in altri oggetti &#151; ma possono sfruttare la maggior parte "
#~ "della funzionalità dei Web Bean, inclusi dependency injection e "
#~ "interceptor."

# bean class local view = ?
#~ msgid ""
#~ "Every local interface of an enterprise Web Bean that does not have a "
#~ "wildcard type parameter or type variable, and every one of its "
#~ "superinterfaces, is an API type of the enterprise Web Bean. If the EJB "
#~ "bean has a bean class local view, the bean class, and every one of its "
#~ "superclasses, is also an API type."
#~ msgstr ""
#~ "Ogni interfaccia locale di un Web Bean enterprise che non ha un parametro "
#~ "tipo wildcard o variabile tipo, e ciascuna delle sue superinterfacce, è "
#~ "un tipo di API del Web Bean enterprise. Se il bean EJB ha una vista "
#~ "locale di classe bean, la classe bean e ogni sua superclasse è anch'essa "
#~ "un tipo di API."

#~ msgid ""
#~ "Stateful session beans should declare a remove method with no parameters "
#~ "or a remove method annotated <literal>@Destructor</literal>. The Web Bean "
#~ "manager calls this method to destroy the stateful session bean instance "
#~ "at the end of its lifecycle. This method is called the "
#~ "<emphasis>destructor</emphasis> method of the enterprise Web Bean."
#~ msgstr ""
#~ "I session bean stateful dovrebbero dichiarare un metodo remoto senza "
#~ "parametri od un metodo annotato con <literal>@Destructor</literal>. Il "
#~ "manager Web Bean chiama questo metodo per distruggere l'istanza del "
#~ "session bean statefull alla fine del suo ciclo di vita. Questo metodo è "
#~ "chiamato metodo <emphasis>distruttore</emphasis> del Web Bean enterprise."

#~ msgid ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"

#~ msgid ""
#~ "So when should we use an enterprise Web Bean instead of a simple Web "
#~ "Bean? Well, whenever we need the advanced enterprise services offered by "
#~ "EJB, such as:"
#~ msgstr ""
#~ "Ma allora quando occorre usare un Web Bean enterprise invece di un Web "
#~ "Bean semplice? Quando occorrono servizi enterprise avanzati offerti da "
#~ "EJB, quali:"

#~ msgid "method-level transaction management and security,"
#~ msgstr "gestione delle transazioni a livello di metodo e sicurezza,"

#~ msgid "concurrency management,"
#~ msgstr "gestione della concorrenza,"

#~ msgid ""
#~ "instance-level passivation for stateful session beans and instance-"
#~ "pooling for stateless session beans,"
#~ msgstr ""
#~ "passivazione a livello di istanza per session bean stateful e pooling di "
#~ "istanze per session bean stateless,"

#~ msgid "remote and web service invocation, and"
#~ msgstr "invocazione remota e web service, e"

#~ msgid "timers and asynchronous methods,"
#~ msgstr "timer e metodi asincroni,"

#~ msgid ""
#~ "we should use an enterprise Web Bean. When we don't need any of these "
#~ "things, a simple Web Bean will serve just fine."
#~ msgstr ""
#~ "si dovrebbe usare un Web Bean enterprise. Quando non occorrono queste "
#~ "cose, va bene utilizzare un Web Bean semplice."

#~ msgid ""
#~ "Many Web Beans (including any session or application scoped Web Bean) are "
#~ "available for concurrent access. Therefore, the concurrency management "
#~ "provided by EJB 3.1 is especially useful. Most session and application "
#~ "scoped Web Beans should be EJBs."
#~ msgstr ""
#~ "Molti Web Bean (inclusi Web Bean con scope di sessione o applicazione) "
#~ "sono disponibili per accessi concorrenti. Quindi la gestione della "
#~ "concorrenza fornita da EJB3.1 è molto utile. La maggior parte dei Web "
#~ "Bean con scope sessione e applicazione dovrebbero essere EJB."

# internal state benefit =?
#~ msgid ""
#~ "Web Beans which hold references to heavy-weight resources, or hold a lot "
#~ "of internal state benefit from the advanced container-managed lifecycle "
#~ "defined by the EJB <literal>@Stateless</literal>/<literal>@Stateful</"
#~ "literal>/<literal>@Singleton</literal> model, with its support for "
#~ "passivation and instance pooling."
#~ msgstr ""
#~ "Web Bean che mantengono riferimenti alle risorse pesanti o mantengono "
#~ "molti benefici dello stato interno dal ciclo di vita avanzato, gestito "
#~ "dal container, definito dal modello EJB <literal>@Stateless</literal>/"
#~ "<literal>@Stateful</literal>/<literal>@Singleton</literal>\", con "
#~ "supporto alla passivazione e pooling delle istanze."

#~ msgid ""
#~ "Finally, it's usually obvious when method-level transaction management, "
#~ "method-level security, timers, remote methods or asynchronous methods are "
#~ "needed."
#~ msgstr ""
#~ "Infine è ovvio quando occorre usare la gestione delle transazioni a "
#~ "livello di metodo, la sicurezza a livello di metoto, i timer, i metodi "
#~ "remoti o i metodi asincroni."

#~ msgid ""
#~ "It's usually easy to start with simple Web Bean, and then turn it into an "
#~ "EJB, just by adding an annotation: <literal>@Stateless</literal>, "
#~ "<literal>@Stateful</literal> or <literal>@Singleton</literal>."
#~ msgstr ""
#~ "E' facile iniziare con un Web Bean semplice e poi volgere a EJB "
#~ "semplicemente aggiungendo l'annotazione: <literal>@Stateless</literal>, "
#~ "<literal>@Stateful</literal> o <literal>@Singleton</literal>."

#~ msgid "Producer methods"
#~ msgstr "Metodi produttori"

#~ msgid ""
#~ "A <emphasis>producer method</emphasis> is a method that is called by the "
#~ "Web Bean manager to obtain an instance of the Web Bean when no instance "
#~ "exists in the current context. A producer method lets the application "
#~ "take full control of the instantiation process, instead of leaving "
#~ "instantiation to the Web Bean manager. For example:"
#~ msgstr ""
#~ "Un <emphasis>metodo produttore</emphasis> è un metodo che viene chiamato "
#~ "dal manager Web Bean per ottenere un'istanza di un Web Bean quando non "
#~ "esiste alcuna istanza nel contesto corrente. Un metodo produttore lascia "
#~ "all'applicazione il pieno controllo del processo di istanziamento, invece "
#~ "di lasciare l'istanziamento al manager Web Bean. Per esempio:"

#~ msgid ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid ""
#~ "The result of a producer method is injected just like any other Web Bean."
#~ msgstr ""
#~ "Il risultato del metodo produttore è iniettato come qualsiasi altro Web "
#~ "Bean."

#~ msgid "<![CDATA[@Random int randomNumber]]>"
#~ msgstr "<![CDATA[@Random int randomNumber]]>"

#~ msgid ""
#~ "The method return type and all interfaces it extends/implements directly "
#~ "or indirectly are API types of the producer method. If the return type is "
#~ "a class, all superclasses are also API types."
#~ msgstr ""
#~ "Il tipo di ritorno del metodo e tutte le interfacce che estende/"
#~ "implementa direttamente o indirettamente sono tipi di API del metodo "
#~ "produttore. Se il tipo di ritorno è una classe, tutte le superclassi sono "
#~ "anch'esse tipi di API."

#~ msgid ""
#~ "Some producer methods return objects that require explicit destruction:"
#~ msgstr ""
#~ "Alcuni metodi produttori restituiscono oggetti che richiedono una "
#~ "distruzione esplicita:"

#~ msgid ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"

#~ msgid ""
#~ "These producer methods may define matching <emphasis>disposal methods</"
#~ "emphasis>:"
#~ msgstr ""
#~ "Questi metodi produttori possono definire corrispondenti <emphasis>metodi "
#~ "distruttori</emphasis>:\""

#~ msgid ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"

#~ msgid ""
#~ "This disposal method is called automatically by the Web Bean manager at "
#~ "the end of the request."
#~ msgstr ""
#~ "Il metodo distruttore è chiamato direttamente dal manager Web Bean alla "
#~ "fine della richiesta."

#~ msgid ""
#~ "We'll talk much more about producer methods in <xref linkend="
#~ "\"producermethods\"/>."
#~ msgstr ""
#~ "Si parlerà in maggior dettaglio dei metodi produttori in <xref linkend="
#~ "\"producermethods\"/>."

#~ msgid "JMS endpoints"
#~ msgstr "Endpoint JMS"

#~ msgid ""
#~ "Finally, a JMS queue or topic can be a Web Bean. Web Beans relieves the "
#~ "developer from the tedium of managing the lifecycles of all the various "
#~ "JMS objects required to send messages to queues and topics. We'll discuss "
#~ "JMS endpoints in <xref linkend=\"jms\"/>."
#~ msgstr ""
#~ "Infine una coda od un topic JMS possono essere Web Bean. Web Beans "
#~ "solleva lo sviluppatore dalla noia della gestione dei cicli di vita di "
#~ "tutti i vari oggetti JMS richiesto per inviare messaggi a code o topic. "
#~ "Si discuteranno gli endpoint JMS in <xref linkend=\"jms\"/>."
